{"version":3,"file":"sp-clientsvc.es5.js","sources":["../../../../node_modules/tslib/tslib.es6.js","../../../../packages/sp-clientsvc/src/opactionbuilders.ts","../../../../packages/sp-clientsvc/src/opbuilders.ts","../../../../packages/sp-clientsvc/src/utils.ts","../../../../packages/sp-clientsvc/src/objectpath.ts","../../../../packages/sp-clientsvc/src/parsers.ts","../../../../packages/sp-clientsvc/src/clintsvcqueryable.ts","../../../../packages/sp-clientsvc/src/batch.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { PropertyType } from \"./types\";\nimport { IMethodParamsBuilder } from \"./opbuilders\";\n\nexport function objectPath(): string {\n    return `<ObjectPath Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\" />`;\n}\n\nexport function identityQuery(): string {\n    return `<ObjectIdentityQuery Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\" />`;\n}\n\nexport function opQuery(selectProperties: string[] = null, childSelectProperties: string[] | null = null): string {\n\n    // this is fairly opaque behavior, but is the simplest way to convey the required information.\n    // if selectProperties.length === 0 or null then select all\n    // else select indicated properties\n\n    // if childSelectProperties === null do not include that block\n    // if childSelectProperties.length === 0 then select all\n    // else select indicated properties\n\n    const builder = [];\n    builder.push(`<Query Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\">`);\n    if (selectProperties === null || selectProperties.length < 1) {\n        builder.push(`<Query SelectAllProperties=\"true\" >`);\n        builder.push(`<Properties />`);\n        builder.push(`</Query >`);\n    } else {\n        builder.push(`<Query SelectAllProperties=\"false\" >`);\n        builder.push(`<Properties>`);\n        [].push.apply(builder, selectProperties.map(p => `<Property Name=\"${p}\" SelectAll=\"true\" />`));\n        builder.push(`</Properties>`);\n        builder.push(`</Query >`);\n    }\n\n    if (childSelectProperties !== null) {\n        if (childSelectProperties.length < 1) {\n            builder.push(`<ChildItemQuery SelectAllProperties=\"true\" >`);\n            builder.push(`<Properties />`);\n            builder.push(`</ChildItemQuery >`);\n        } else {\n            builder.push(`<ChildItemQuery SelectAllProperties=\"false\" >`);\n            builder.push(`<Properties>`);\n            [].push.apply(builder, childSelectProperties.map(p => `<Property Name=\"${p}\" SelectAll=\"true\" />`));\n            builder.push(`</Properties>`);\n            builder.push(`</ChildItemQuery >`);\n        }\n    }\n\n    builder.push(`</Query >`);\n\n    return builder.join(\"\");\n}\n\nexport function setProperty(name: string, type: PropertyType, value: string): string {\n    const builder = [];\n    builder.push(`<SetProperty Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\" Name=\"${name}\">`);\n    builder.push(`<Parameter Type=\"${type}\">${value}</Parameter>`);\n    builder.push(`</SetProperty>`);\n    return builder.join(\"\");\n}\n\nexport function methodAction(name: string, params: IMethodParamsBuilder | null): string {\n\n    const builder = [];\n    builder.push(`<Method Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\" Name=\"${name}\">`);\n\n    if (params !== null) {\n        const arrParams = params.toArray();\n        if (arrParams.length < 1) {\n            builder.push(`<Parameters />`);\n        } else {\n            builder.push(`<Parameters>`);\n            [].push.apply(builder, arrParams.map(p => `<Parameter Type=\"${p.type}\">${p.value}</Parameter>`));\n            builder.push(`</Parameters>`);\n        }\n    }\n\n    builder.push(\"</Method>\");\n\n    return builder.join(\"\");\n}\n\nexport function objectProperties(o: any): string[] {\n\n    return Object.getOwnPropertyNames(o).map((name) => {\n\n        const value = o[name];\n        if (typeof value === \"boolean\") {\n            return setProperty(name, \"Boolean\", `${value}`);\n        } else if (typeof value === \"number\") {\n            return setProperty(name, \"Number\", `${value}`);\n        } else if (typeof value === \"string\") {\n            return setProperty(name, \"String\", `${value}`);\n        }\n\n        return \"\";\n    }, []);\n}\n","import { ObjectPath, IObjectPath } from \"./objectpath\";\nimport { PropertyType } from \"./types\";\n\nexport function property(name: string, ...actions: string[]): IObjectPath {\n    return new ObjectPath(`<Property Id=\"$$ID$$\" ParentId=\"$$PARENT_ID$$\" Name=\"${name}\" />`, actions);\n}\n\nexport function staticMethod(name: string, typeId: string, ...actions: string[]): IObjectPath {\n    return new ObjectPath(`<StaticMethod Id=\"$$ID$$\" Name=\"${name}\" TypeId=\"${typeId}\" />`, actions);\n}\n\nexport function staticProperty(name: string, typeId: string, ...actions: string[]): IObjectPath {\n    return new ObjectPath(`<StaticProperty Id=\"$$ID$$\" Name=\"${name}\" TypeId=\"${typeId}\" />`, actions);\n}\n\nexport function objConstructor(typeId: string, ...actions: string[]): IObjectPath {\n    return new ObjectPath(`<Constructor Id=\"$$ID$$\" TypeId=\"${typeId}\" />`, actions);\n}\n\nexport interface IMethodParamsBuilder {\n    string(value: string): this;\n    number(value: number): this;\n    boolean(value: boolean): this;\n    strArray(values: string[]): this;\n    objectPath(inputIndex: number): this;\n    toArray(): { type: PropertyType, value: string }[];\n}\n\n/**\n * Used to build parameters when calling methods\n */\nexport class MethodParams implements IMethodParamsBuilder {\n\n    constructor(private _p: { type: PropertyType, value: string }[] = []) { }\n\n    public static build(initValues: { type: PropertyType, value: string }[] = []): IMethodParamsBuilder {\n        const params = new MethodParams();\n        [].push.apply(params._p, initValues);\n        return params;\n    }\n\n    public string(value: string): this {\n        return this.a(\"String\", value);\n    }\n\n    public number(value: number): this {\n        return this.a(\"Number\", value.toString());\n    }\n\n    public boolean(value: boolean): this {\n        return this.a(\"Boolean\", value.toString());\n    }\n\n    public strArray(values: string[]): this {\n        return this.a(\"Array\", values.map(v => `<Object Type=\"String\">${v}</Object>`).join(\"\"));\n    }\n\n    public objectPath(inputIndex: number): this {\n        return this.a(\"ObjectPath\", inputIndex.toString());\n    }\n\n    public toArray(): { type: PropertyType, value: string }[] {\n        return this._p;\n    }\n\n    private a(type: PropertyType, value: string): this {\n        this._p.push({ type, value });\n        return this;\n    }\n}\n\nexport function method(name: string, params: IMethodParamsBuilder, ...actions: string[]): IObjectPath {\n    const builder = [];\n    builder.push(`<Method Id=\"$$ID$$\" ParentId=\"$$PARENT_ID$$\" Name=\"${name}\">`);\n\n    if (params !== null) {\n        const arrParams = params.toArray();\n        if (arrParams.length < 1) {\n            builder.push(`<Parameters />`);\n        } else {\n            builder.push(`<Parameters>`);\n            [].push.apply(builder, arrParams.map(p => {\n\n                if (p.type === \"ObjectPath\") {\n                    return `<Parameter ObjectPathId=\"$$OP_PARAM_ID_${p.value}$$\" />`;\n                }\n\n                return `<Parameter Type=\"${p.type}\">${p.value}</Parameter>`;\n            }));\n            builder.push(`</Parameters>`);\n        }\n    }\n\n    builder.push(\"</Method>\");\n\n    return new ObjectPath(builder.join(\"\"), actions);\n}\n","import { IObjectPath } from \"./objectpath\";\n\n/**\n * Transforms an array of object paths into a request xml body. Does not do placeholder substitutions.\n * \n * @param objectPaths The object paths for which we want to generate a body\n */\nexport function writeObjectPathBody(objectPaths: IObjectPath[]): string {\n\n    const actions: string[] = [];\n    const paths: string[] = [];\n\n    objectPaths.forEach(op => {\n        paths.push(op.path);\n        actions.push(...op.actions);\n    });\n\n    // create our xml payload\n    return [\n        `<Request xmlns=\"http://schemas.microsoft.com/sharepoint/clientquery/2009\" SchemaVersion=\"15.0.0.0\" LibraryVersion=\"16.0.0.0\" ApplicationName=\"PnPjs\">`,\n        \"<Actions>\",\n        actions.join(\"\"),\n        \"</Actions>\",\n        \"<ObjectPaths>\",\n        paths.join(\"\"),\n        \"</ObjectPaths>\",\n        \"</Request>\",\n    ].join(\"\");\n}\n","import { TypedHash, extend, objectDefinedNotNull } from \"@pnp/common\";\nimport { objectPath } from \"./opactionbuilders\";\nimport { property, staticProperty } from \"./opbuilders\";\nimport { writeObjectPathBody } from \"./utils\";\n\n/**\n * Defines the properties and method of an ObjectPath\n */\nexport interface IObjectPath {\n    /**\n     * The ObjectPath xml node\n     */\n    path: string;\n    /**\n     * Collection of xml action nodes\n     */\n    actions: string[];\n    /**\n     * The id of this object path, used for processing, not set directly\n     */\n    id: number | undefined;\n}\n\n/**\n * Represents an ObjectPath used when querying ProcessQuery\n */\nexport class ObjectPath implements IObjectPath {\n    constructor(public path: string, public actions: string[] = [], public id = -1, public replaceAfter: IObjectPath[] = []) { }\n}\n\n/**\n * Replaces all found instance of the $$ID$$ placeholder in the supplied xml string\n * \n * @param id New value to be insterted\n * @param xml The existing xml fragment in which the replace should occur\n */\nexport function opSetId(id: string, xml: string): string {\n    return xml.replace(/\\$\\$ID\\$\\$/g, id);\n}\n\n/**\n * Replaces all found instance of the $$PATH_ID$$ placeholder in the supplied xml string\n * \n * @param id New value to be insterted\n * @param xml The existing xml fragment in which the replace should occur\n */\nexport function opSetPathId(id: string, xml: string): string {\n    return xml.replace(/\\$\\$PATH_ID\\$\\$/g, id);\n}\n\n/**\n * Replaces all found instance of the $$PARENT_ID$$ placeholder in the supplied xml string\n * \n * @param id New value to be insterted\n * @param xml The existing xml fragment in which the replace should occur\n */\nexport function opSetParentId(id: string, xml: string): string {\n    return xml.replace(/\\$\\$PARENT_ID\\$\\$/g, id);\n}\n\n/**\n * Replaces all found instance of the $$OP_PARAM_ID$$ placeholder in the supplied xml string\n * \n * @param map A mapping where [index] = replaced_object_path_id\n * @param xml The existing xml fragment in which the replace should occur\n * @param indexMapper Used when creating batches, not meant for direct use external to this library\n */\nexport function opSetPathParamId(map: number[], xml: string, indexMapper: (n: number) => number = (n) => n): string {\n\n    // this approach works because input params must come before the things that need them\n    // meaning the right id will always be in the map\n    const matches = /\\$\\$OP_PARAM_ID_(\\d+)\\$\\$/ig.exec(xml);\n    if (matches !== null) {\n        for (let i = 1; i < matches.length; i++) {\n            const index = parseInt(matches[i], 10);\n            const regex = new RegExp(`\\\\$\\\\$OP_PARAM_ID_${index}\\\\$\\\\$`, \"ig\");\n            xml = xml.replace(regex, map[indexMapper(index)].toString());\n        }\n    }\n\n    return xml;\n}\n\n/**\n * Represents a collection of IObjectPaths\n */\nexport class ObjectPathQueue {\n\n    private _xml: string | null;\n    private _contextIndex = -1;\n    private _siteIndex = -1;\n    private _webIndex = -1;\n\n    constructor(protected _paths: IObjectPath[] = [], protected _relationships: TypedHash<number[]> = {}) { }\n\n    /**\n     * Adds an object path to the queue\n     * \n     * @param op The action to add\n     * @returns The index of the added object path\n     */\n    public add(op: IObjectPath): number {\n\n        this.dirty();\n        this._paths.push(op);\n        return this.lastIndex;\n    }\n\n    public addChildRelationship(parentIndex: number, childIndex: number) {\n        if (objectDefinedNotNull(this._relationships[`_${parentIndex}`])) {\n            this._relationships[`_${parentIndex}`].push(childIndex);\n        } else {\n            this._relationships[`_${parentIndex}`] = [childIndex];\n        }\n    }\n\n    public getChildRelationship(parentIndex: number): number[] {\n        if (objectDefinedNotNull(this._relationships[`_${parentIndex}`])) {\n            return this._relationships[`_${parentIndex}`];\n        } else {\n            return [];\n        }\n    }\n\n    public getChildRelationships(): TypedHash<number[]> {\n        return this._relationships;\n    }\n\n    /**\n     * Appends an action to the supplied IObjectPath, replacing placeholders\n     * \n     * @param op IObjectPath to which the action will be appended\n     * @param action The action to append\n     */\n    public appendAction(op: IObjectPath, action: string): this {\n\n        this.dirty();\n        op.actions.push(action);\n        return this;\n    }\n\n    /**\n     * Appends an action to the last IObjectPath in the collection\n     * \n     * @param action \n     */\n    public appendActionToLast(action: string): this {\n\n        return this.appendAction(this.last, action);\n    }\n\n    /**\n     * Creates a linked copy of this ObjectPathQueue\n     */\n    public copy(): ObjectPathQueue {\n        const copy = new ObjectPathQueue(this.toArray(), extend({}, this._relationships));\n        copy._contextIndex = this._contextIndex;\n        copy._siteIndex = this._siteIndex;\n        copy._webIndex = this._webIndex;\n        return copy;\n    }\n\n    /**\n     * Creates an independent clone of this ObjectPathQueue\n     */\n    public clone(): ObjectPathQueue {\n        const clone = new ObjectPathQueue(this.toArray().map(p => Object.assign({}, p)), extend({}, this._relationships));\n        clone._contextIndex = this._contextIndex;\n        clone._siteIndex = this._siteIndex;\n        clone._webIndex = this._webIndex;\n        return clone;\n    }\n\n    /**\n     * Gets a copy of this instance's paths\n     */\n    public toArray(): IObjectPath[] {\n        return this._paths.slice(0);\n    }\n\n    /**\n     * The last IObjectPath instance added to this collection\n     */\n    public get last(): IObjectPath {\n\n        if (this._paths.length < 1) {\n            return null;\n        }\n\n        return this._paths[this.lastIndex];\n    }\n\n    /**\n     * Index of the last IObjectPath added to the queue\n     */\n    public get lastIndex(): number {\n        return this._paths.length - 1;\n    }\n\n    /**\n     * Gets the index of the current site in the queue\n     */\n    public get siteIndex(): number {\n\n        if (this._siteIndex < 0) {\n\n            // this needs to be here in case we create it\n            const contextIndex = this.contextIndex;\n\n            this._siteIndex = this.add(property(\"Site\",\n                // actions\n                objectPath()));\n\n            this.addChildRelationship(contextIndex, this._siteIndex);\n        }\n\n        return this._siteIndex;\n    }\n\n    /**\n     * Gets the index of the current web in the queue\n     */\n    public get webIndex(): number {\n\n        if (this._webIndex < 0) {\n\n            // this needs to be here in case we create it\n            const contextIndex = this.contextIndex;\n\n            this._webIndex = this.add(property(\"Web\",\n                // actions\n                objectPath()));\n\n            this.addChildRelationship(contextIndex, this._webIndex);\n        }\n\n        return this._webIndex;\n    }\n\n    /**\n     * Gets the index of the Current context in the queue, can be used to establish parent -> child rels\n     */\n    public get contextIndex(): number {\n        if (this._contextIndex < 0) {\n            this._contextIndex = this.add(staticProperty(\"Current\", \"{3747adcd-a3c3-41b9-bfab-4a64dd2f1e0a}\",\n                // actions\n                objectPath()));\n        }\n\n        return this._contextIndex;\n    }\n\n    public toBody(): string {\n\n        if (objectDefinedNotNull(this._xml)) {\n            return this._xml;\n        }\n\n        // create our xml payload\n        this._xml = writeObjectPathBody(this.toIndexedTree());\n\n        return this._xml;\n    }\n\n    /**\n     * Conducts the string replacements for id, parent id, and path id\n     * \n     * @returns The tree with all string replacements made\n     */\n    public toIndexedTree(): IObjectPath[] {\n\n        let builderIndex = -1;\n        let lastOpId = -1;\n        const idIndexMap: number[] = [];\n\n        return this.toArray().map((op, index, arr) => {\n\n            const opId = ++builderIndex;\n\n            // track the array index => opId relationship\n            idIndexMap.push(opId);\n\n            // do path replacements\n            op.path = opSetPathParamId(idIndexMap, opSetId(opId.toString(), op.path));\n\n            if (lastOpId >= 0) {\n                // if we have a parent do the replace\n                op.path = opSetParentId(lastOpId.toString(), op.path);\n            }\n\n            // rewrite actions with placeholders replaced\n            op.actions = op.actions.map(a => {\n                const actionId = ++builderIndex;\n                return opSetId(actionId.toString(), opSetPathId(opId.toString(), a));\n            });\n\n            // handle any specific child relationships\n            this.getChildRelationship(index).forEach(childIndex => {\n                // set the parent id for our non-immediate children, thus removing the token so it isn't overwritten\n                arr[childIndex].path = opSetParentId(opId.toString(), arr[childIndex].path);\n            });\n\n            // and remember our last object path id for the parent replace above\n            lastOpId = opId;\n\n            return op;\n        });\n    }\n\n    /**\n     * Dirties this queue clearing any cached data\n     */\n    protected dirty(): void {\n        this._xml = null;\n    }\n}\n","import { getAttrValueFromString, jsS, hOP } from \"@pnp/common\";\nimport { IObjectPath } from \"./objectpath\";\n\n/**\n * Used within the request pipeline to parse ProcessQuery results\n */\nexport class ProcessQueryParser<T = any> {\n\n    constructor(protected op: IObjectPath) { }\n\n    /**\n     * Parses the response checking for errors\n     * \n     * @param r Response object\n     */\n    public parse(r: Response): Promise<T> {\n\n        return r.text().then(t => {\n\n            if (!r.ok) {\n                throw Error(t);\n            }\n\n            try {\n                return JSON.parse(t);\n            } catch (e) {\n                // special case in ProcessQuery where we got an error back, but it is not in json format\n                throw Error(t);\n            }\n\n        }).then((parsed: any[]) => {\n\n            // here we need to check for an error body\n            if (parsed.length > 0 && hOP(parsed[0], \"ErrorInfo\") && parsed[0].ErrorInfo !== null) {\n                throw Error(jsS(parsed[0].ErrorInfo));\n            }\n\n            return this.findResult(parsed);\n        });\n    }\n\n    public findResult(json: any): Promise<T | null> {\n\n        for (let i = 0; i < this.op.actions.length; i++) {\n\n            const a = this.op.actions[i];\n\n            // let's see if the result is null based on the ObjectPath action, if it exists\n            // <ObjectPath Id=\"8\" ObjectPathId=\"7\" />\n            if (/^<ObjectPath /i.test(a)) {\n                const result = this.getParsedResultById<{ IsNull: boolean }>(json, parseInt(getAttrValueFromString(a, \"Id\"), 10));\n                if (!result || (result && result.IsNull)) {\n                    return Promise.resolve(null);\n                }\n            }\n\n            // let's see if we have a query result\n            // <Query Id=\"5\" ObjectPathId = \"3\" >\n            if (/^<Query /i.test(a)) {\n                const result = this.getParsedResultById(json, parseInt(getAttrValueFromString(a, \"Id\"), 10));\n\n                if (result && hOP(result, \"_Child_Items_\")) {\n                    // this is a collection result\n                    /* tslint:disable:no-string-literal */\n                    return Promise.resolve(result[\"_Child_Items_\"]);\n                    /* tslint:enable:no-string-literal */\n                } else {\n                    // this is an instance result\n                    return Promise.resolve(result);\n                }\n            }\n\n            // this is an invokeMethodAction so the last method action corresponds to our result\n            if (i === (this.op.actions.length - 1) && /^<Method /i.test(a)) {\n                return Promise.resolve(this.getParsedResultById(json, parseInt(getAttrValueFromString(a, \"Id\"), 10)));\n            }\n        }\n\n        // no result could be found so we are effectively returning void\n        // issue is we really don't know if we should be returning void (a method invocation with a void return) or\n        // if we just didn't find something above. We will let downstream things worry about that\n    }\n\n    /**\n     * Locates a result by ObjectPath id\n     * \n     * @param parsed the parsed JSON body from the response\n     * @param id The ObjectPath id whose result we want\n     */\n    protected getParsedResultById<R = any>(parsed: any[], id: number): R {\n\n        for (let i = 0; i < parsed.length; i++) {\n\n            if (parsed[i] === id) {\n                return parsed[i + 1];\n            }\n        }\n\n        return null;\n    }\n}\n","import {\n    FetchOptions,\n    combine,\n    extend,\n    getGUID,\n    mergeHeaders,\n    mergeOptions,\n    objectDefinedNotNull,\n    hOP,\n    getHashCode,\n    stringIsNullOrEmpty,\n} from \"@pnp/common\";\nimport { CachingOptions, ICachingOptions, ODataParser, Queryable, RequestContext } from \"@pnp/odata\";\nimport { SPHttpClient, toAbsoluteUrl } from \"@pnp/sp\";\nimport { IObjectPathBatch } from \"./batch\";\nimport { ObjectPathQueue } from \"./objectpath\";\nimport { methodAction, objectPath, objectProperties, opQuery } from \"./opactionbuilders\";\nimport { IMethodParamsBuilder, method, property } from \"./opbuilders\";\nimport { ProcessQueryParser } from \"./parsers\";\n\nexport interface IClientSvcQueryable {\n    select(...selects: string[]): this;\n    usingCaching(options?: ICachingOptions): this;\n    inBatch(batch: IObjectPathBatch): this;\n}\n\nexport interface ClientSvcQueryableConstructor<T> {\n    new(baseUrl: string | ClientSvcQueryable, objectPaths?: ObjectPathQueue): T;\n}\n\nconst ProcessQueryPath = \"_vti_bin/client.svc/ProcessQuery\";\n\nexport class ClientSvcQueryable<GetType = any> extends Queryable<GetType> implements IClientSvcQueryable {\n\n    /**\n     * Collection of select fields\n     */\n    protected _selects: string[];\n\n    /**\n     * Tracks the batch of which this query may be part\n     */\n    protected _batch: IObjectPathBatch | null;\n\n    /**\n     * Allows us to properly block batch execution until everything is loaded\n     */\n    protected _batchDependency: () => void | null;\n\n    constructor(parent: ClientSvcQueryable | string = \"\", protected _objectPaths: ObjectPathQueue | null = null) {\n        super();\n\n        this._selects = [];\n        this._batch = null;\n        this._batchDependency = null;\n\n        if (typeof parent === \"string\") {\n\n            // we assume the parent here is an absolute url to a web\n            this._parentUrl = parent;\n            this._url = combine(parent.replace(ProcessQueryPath, \"\"), ProcessQueryPath);\n            if (!objectDefinedNotNull(this._objectPaths)) {\n                this._objectPaths = new ObjectPathQueue();\n            }\n\n        } else {\n            this._parentUrl = parent._parentUrl;\n            this._url = combine(parent._parentUrl, ProcessQueryPath);\n            if (!objectDefinedNotNull(_objectPaths)) {\n                this._objectPaths = parent._objectPaths.clone();\n            }\n            this.configureFrom(parent);\n        }\n    }\n\n    /**\n     * Choose which fields to return\n     *\n     * @param selects One or more fields to return\n     */\n    public select(...selects: string[]): this {\n        [].push.apply(this._selects, selects);\n        return this;\n    }\n\n    /**\n     * Adds this query to the supplied batch\n     *\n     */\n    public inBatch(batch: IObjectPathBatch): this {\n\n        if (this.batch !== null) {\n            throw Error(\"This query is already part of a batch.\");\n        }\n\n        if (objectDefinedNotNull(batch)) {\n            this._batch = batch;\n            this._batchDependency = batch.addDependency();\n        }\n\n        return this;\n    }\n\n    /**\n     * Gets the full url with query information\n     *\n     */\n    public toUrlAndQuery(): string {\n        return `${super.toUrl()}?${Array.from(this.query).map((v: [string, string]) => v[0] + \"=\" + v[1]).join(\"&\")}`;\n    }\n\n    protected getSelects(): string[] {\n        return objectDefinedNotNull(this._selects) ? this._selects : [];\n    }\n\n    /**\n     * Gets a child object based on this instance's paths and the supplied paramters\n     * \n     * @param factory Instance factory of the child type\n     * @param methodName Name of the method used to load the child\n     * @param params Parameters required by the method to load the child\n     */\n    protected getChild<T>(factory: ClientSvcQueryableConstructor<T>, methodName: string, params: IMethodParamsBuilder | null): T {\n\n        const objectPaths = this._objectPaths.copy();\n\n        objectPaths.add(method(methodName, params,\n            // actions\n            objectPath()));\n\n        return new factory(this, objectPaths);\n    }\n\n    /**\n     * Gets a property of the current instance\n     * \n     * @param factory Instance factory of the child type\n     * @param propertyName Name of the property to load\n     */\n    protected getChildProperty<T>(factory: ClientSvcQueryableConstructor<T>, propertyName: string): T {\n\n        const objectPaths = this._objectPaths.copy();\n\n        objectPaths.add(property(propertyName));\n\n        return new factory(this, objectPaths);\n    }\n\n    /**\n     * Sends a request\n     * \n     * @param op \n     * @param options \n     * @param parser \n     */\n    protected send<T = any>(objectPaths: ObjectPathQueue, options: FetchOptions = {}, parser: ODataParser<T> = null): Promise<T> {\n\n        // here we need to create a clone because all the string indexes and references\n        // will be updated and all need to relate for this operation being sent. The parser\n        // and the postCore method need to share an independent value of the objectPaths\n        // See for https://github.com/pnp/pnpjs/issues/419 for details\n        const clonedOps = objectPaths.clone();\n\n        if (!objectDefinedNotNull(parser)) {\n            // we assume here that we want to return for this index path\n            parser = new ProcessQueryParser(clonedOps.last);\n        }\n\n        if (this.hasBatch) {\n\n            // this is using the options variable to pass some extra information downstream to the batch\n            options = extend(options, {\n                clientsvc_ObjectPaths: clonedOps,\n            });\n\n        } else {\n\n            if (!hOP(options, \"body\")) {\n                options = extend(options, {\n                    body: clonedOps.toBody(),\n                });\n            }\n        }\n\n        return super.postCore(options, parser);\n    }\n\n    /**\n     * Sends the request, merging the result data with a new instance of factory\n     */\n    protected sendGet<DataType, FactoryType>(factory: ClientSvcQueryableConstructor<FactoryType>): Promise<(DataType & FactoryType)> {\n\n        const ops = this._objectPaths.copy().appendActionToLast(opQuery(this.getSelects()));\n\n        return this.send<DataType>(ops).then(r => extend(new factory(this), r));\n    }\n\n    /**\n     * Sends the request, merging the result data array with a new instances of factory\n     */\n    protected sendGetCollection<DataType, FactoryType>(factory: (d: DataType) => FactoryType): Promise<(DataType & FactoryType)[]> {\n\n        const ops = this._objectPaths.copy().appendActionToLast(opQuery([], this.getSelects()));\n\n        return this.send<DataType[]>(ops).then(r => r.map(d => extend(factory(d), d)));\n    }\n\n    /**\n     * Invokes the specified method on the server and returns the result\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param actions Any additional actions to execute in addition to the method invocation (set property for example)\n     */\n    protected invokeMethod<T>(methodName: string, params: IMethodParamsBuilder | null = null, ...actions: string[]): Promise<T> {\n        return this.invokeMethodImpl(methodName, params, actions, opQuery([], null));\n    }\n\n    /**\n     * Invokes a method action that returns a single result and does not have an associated query (ex: GetDescription on Term)\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param actions Any additional actions to execute in addition to the method invocation (set property for example)\n     */\n    protected invokeMethodAction<T>(methodName: string, params: IMethodParamsBuilder | null = null, ...actions: string[]): Promise<T> {\n        return this.invokeMethodImpl(methodName, params, actions, null, true);\n    }\n\n    /**\n     * Invokes the specified non-query method on the server\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param actions Any additional actions to execute in addition to the method invocation (set property for example)\n     */\n    protected invokeNonQuery(methodName: string, params: IMethodParamsBuilder | null = null, ...actions: string[]): Promise<void> {\n        // by definition we are not returning anything from these calls so we should not be caching the results\n        this._useCaching = false;\n        return this.invokeMethodImpl<void>(methodName, params, actions, null, true);\n    }\n\n    /**\n     * Invokes the specified method on the server and returns the resulting collection\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param actions Any additional actions to execute in addition to the method invocation (set property for example)\n     */\n    protected invokeMethodCollection<T>(methodName: string, params: IMethodParamsBuilder | null = null, ...actions: string[]): Promise<T> {\n        return this.invokeMethodImpl(methodName, params, actions, opQuery([], []));\n    }\n\n    /**\n     * Updates this instance, returning a copy merged with the updated data after the update\n     * \n     * @param properties Plain object of the properties and values to update\n     * @param factory Factory method use to create a new instance of FactoryType\n     */\n    protected invokeUpdate<DataType, FactoryType>(properties: any, factory: ClientSvcQueryableConstructor<FactoryType>): Promise<DataType & FactoryType> {\n\n        const ops = this._objectPaths.copy();\n        // append setting all the properties to this instance\n        objectProperties(properties).map(a => ops.appendActionToLast(a));\n        ops.appendActionToLast(opQuery([], null));\n        return this.send<DataType>(ops).then(r => extend(new factory(this), r));\n    }\n\n    /**\n     * Converts the current instance to a request context\n     *\n     * @param verb The request verb\n     * @param options The set of supplied request options\n     * @param parser The supplied ODataParser instance\n     * @param pipeline Optional request processing pipeline\n     */\n    protected toRequestContext<T>(\n        verb: string,\n        options: FetchOptions,\n        parser: ODataParser<T>,\n        pipeline: Array<(c: RequestContext<T>) => Promise<RequestContext<T>>>): Promise<RequestContext<T>> {\n\n        return toAbsoluteUrl(this.toUrlAndQuery()).then(url => {\n\n            mergeOptions(options, this._options);\n\n            const headers = new Headers();\n\n            mergeHeaders(headers, options.headers);\n\n            mergeHeaders(headers, {\n                \"accept\": \"*/*\",\n                \"content-type\": \"text/xml\",\n            });\n\n            options = extend(options, { headers });\n\n            // we need to do some special cache handling to ensure we have a good key\n            if (this._useCaching) {\n\n                let keyStr = options.body;\n\n                if (stringIsNullOrEmpty(keyStr)) {\n\n                    if (hOP(options, \"clientsvc_ObjectPaths\")) {\n                        // if we are using caching and batching together we need to create our string from the paths stored for the\n                        // batching operation (see: https://github.com/pnp/pnpjs/issues/449) but not update the ones passed to\n                        // the batch as they will be indexed during the batch creation process\n                        keyStr = (<{ clientsvc_ObjectPaths: ObjectPathQueue }>options).clientsvc_ObjectPaths.clone().toBody();\n                    } else {\n                        // this case shouldn't happen\n                        keyStr = \"\";\n                    }\n                }\n\n                // because all the requests use the same url they would collide in the cache we use a special key\n                const cacheKey = `PnPjs.ProcessQueryClient(${getHashCode(keyStr)})`;\n\n                if (objectDefinedNotNull(this._cachingOptions)) {\n                    // if our key ends in the ProcessQuery url we overwrite it\n                    if (/\\/client\\.svc\\/ProcessQuery\\?$/i.test(this._cachingOptions.key)) {\n                        this._cachingOptions.key = cacheKey;\n                    }\n                } else {\n                    this._cachingOptions = new CachingOptions(cacheKey);\n                }\n            }\n\n            const dependencyDispose = this.hasBatch ? this._batchDependency : () => { return; };\n\n            // build our request context\n            const context: RequestContext<T> = {\n                batch: this.batch,\n                batchDependency: dependencyDispose,\n                cachingOptions: this._cachingOptions,\n                clientFactory: () => new SPHttpClient(),\n                isBatched: this.hasBatch,\n                isCached: this._useCaching,\n                options: options,\n                parser: parser,\n                pipeline: pipeline,\n                requestAbsoluteUrl: url,\n                requestId: getGUID(),\n                verb: verb,\n            };\n\n            return context;\n        });\n    }\n\n    /**\n     * Blocks a batch call from occuring, MUST be cleared by calling the returned function\n    */\n    protected addBatchDependency(): () => void {\n        if (this._batch !== null) {\n            return this._batch.addDependency();\n        }\n\n        return () => null;\n    }\n\n    /**\n     * Indicates if the current query has a batch associated\n     *\n     */\n    protected get hasBatch(): boolean {\n        return objectDefinedNotNull(this._batch);\n    }\n\n    /**\n     * The batch currently associated with this query or null\n     *\n     */\n    protected get batch(): IObjectPathBatch {\n        return this.hasBatch ? this._batch : null;\n    }\n\n    /**\n     * Executes the actual invoke method call\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param queryAction Specifies the query action to take\n     */\n    private invokeMethodImpl<T>(methodName: string, params: IMethodParamsBuilder | null, actions: string[], queryAction: string, isAction = false): Promise<T> {\n\n        const ops = this._objectPaths.copy();\n\n        if (isAction) {\n            ops.appendActionToLast(methodAction(methodName, params));\n        } else {\n            ops.add(method(methodName, params, ...[objectPath(), ...actions, queryAction]));\n        }\n\n        return this.send<T>(ops);\n    }\n}\n","import { LogLevel, Logger } from \"@pnp/logging\";\nimport { CachingParserWrapper, ODataBatch, ODataBatchRequestInfo } from \"@pnp/odata\";\nimport { ClientSvcQueryable } from \"./clintsvcqueryable\";\nimport { ObjectPath, ObjectPathQueue, opSetId, opSetParentId, opSetPathId, opSetPathParamId } from \"./objectpath\";\nimport { objectPath } from \"./opactionbuilders\";\nimport { staticMethod } from \"./opbuilders\";\nimport { ProcessQueryParser } from \"./parsers\";\nimport { writeObjectPathBody } from \"./utils\";\n\nexport interface IObjectPathBatch extends ODataBatch {\n\n}\n\n/**\n * Implements ODataBatch for use with the ObjectPath framework\n */\nexport class ObjectPathBatch extends ODataBatch implements IObjectPathBatch {\n\n    constructor(protected parentUrl: string, _batchId?: string) {\n        super(_batchId);\n    }\n\n    protected executeImpl(): Promise<void> {\n\n        // if we don't have any requests, don't bother sending anything\n        // this could be due to caching further upstream, or just an empty batch\n        if (this.requests.length < 1) {\n            Logger.write(`Resolving empty batch.`, LogLevel.Info);\n            return Promise.resolve();\n        }\n\n        const executor = new BatchExecutor(this.parentUrl, this.batchId);\n        executor.appendRequests(this.requests);\n        return executor.execute();\n    }\n}\n\nclass BatchExecutor extends ClientSvcQueryable {\n\n    private _builderIndex: number;\n    private _requests: ODataBatchRequestInfo[];\n\n    constructor(parentUrl: string, public batchId: string) {\n        super(parentUrl);\n\n        this._requests = [];\n        this._builderIndex = 1;\n\n        // we add our session object path and hard code in the IDs so we can reference it\n        const method = staticMethod(\"GetTaxonomySession\", \"{981cbc68-9edc-4f8d-872f-71146fcbb84f}\");\n        method.path = opSetId(\"0\", method.path);\n        method.actions.push(opSetId(\"1\", opSetPathId(\"0\", objectPath())));\n\n        this._objectPaths.add(method);\n    }\n\n    public appendRequests(requests: ODataBatchRequestInfo[]): void {\n\n        requests.forEach(request => {\n\n            // grab the special property we added to options when we created the batch info\n            const pathQueue: ObjectPathQueue = (<any>request.options).clientsvc_ObjectPaths;\n\n            let paths = pathQueue.toArray();\n\n            // getChildRelationships\n            if (paths.length < 0) {\n                return;\n            }\n\n            let indexMappingFunction = (n: number) => n;\n\n            if (/GetTaxonomySession/i.test(paths[0].path)) {\n\n                // drop the first thing as it is a get session object path, which we add once for the entire batch\n                paths = paths.slice(1);\n\n                // replace the next item's parent id with 0, which will be the id of the session call at the root of this request\n                paths[0].path = opSetParentId(\"0\", paths[0].path);\n\n                indexMappingFunction = (n: number) => n - 1;\n            }\n\n            let lastOpId = -1;\n            const idIndexMap: number[] = [];\n\n            paths.map((op, index, arr) => {\n\n                // rewrite the path string\n                const opId = ++this._builderIndex;\n\n                // track the array index => opId relationship\n                idIndexMap.push(opId);\n\n                let path = opSetPathParamId(idIndexMap, opSetId(opId.toString(), op.path), indexMappingFunction);\n                if (lastOpId >= 0) {\n                    path = opSetParentId(lastOpId.toString(), path);\n                }\n\n                // rewrite actions with placeholders replaced\n                const opActions = op.actions.map(a => {\n                    const actionId = ++this._builderIndex;\n                    return opSetId(actionId.toString(), opSetPathId(opId.toString(), a));\n                });\n\n                // handle any specific child relationships\n                // the childIndex is reduced by 1 because we are removing the Session Path\n                pathQueue.getChildRelationship(index + 1).map(i => i - 1).forEach(childIndex => {\n                    // set the parent id for our non-immediate children\n                    arr[childIndex].path = opSetParentId(opId.toString(), arr[childIndex].path);\n                });\n\n                // and remember our last object path id for the parent replace above\n                lastOpId = opId;\n\n                // return our now substituted path and actions as a new object path instance\n                return new ObjectPath(path, opActions);\n\n            }).forEach(op => this._objectPaths.add(op));\n\n            // get this once\n            const obPaths = this._objectPaths.toArray();\n\n            // create a new parser to handle finding the result based on the path\n            const parser = new ProcessQueryParser(obPaths[obPaths.length - 1]);\n\n            if (request.parser instanceof CachingParserWrapper) {\n                // handle special case of caching\n                request.parser = new ProcessQueryCachingParserWrapper(parser, request.parser);\n            } else {\n                request.parser = parser;\n            }\n\n            // add the request to our batch requests\n            this._requests.push(request);\n\n            // remove the temp property\n            delete (<any>request.options).clientsvc_ObjectPaths;\n        });\n    }\n\n    public execute(): Promise<void> {\n\n        Logger.write(`[${this.batchId}] (${(new Date()).getTime()}) Executing batch with ${this._requests.length} requests.`, LogLevel.Info);\n\n        // create our request body from all the merged object paths\n        const options = {\n            body: writeObjectPathBody(this._objectPaths.toArray()),\n        };\n\n        Logger.write(`[${this.batchId}] (${(new Date()).getTime()}) Sending batch request.`, LogLevel.Info);\n\n        // send the batch\n        return super.postCore(options, new BatchParser()).then((rawResponse: any) => {\n\n            Logger.write(`[${this.batchId}] (${(new Date()).getTime()}) Resolving batched requests.`, LogLevel.Info);\n\n            return this._requests.reduce((chain, request) => {\n\n                Logger.write(`[${request.id}] (${(new Date()).getTime()}) Resolving request in batch ${this.batchId}.`, LogLevel.Info);\n\n                return chain.then(_ => (<ProcessQueryParser>request.parser).findResult(rawResponse).then(request.resolve).catch(request.reject));\n\n            }, Promise.resolve());\n        });\n    }\n}\n\n/**\n * Used to return the raw results from parsing the batch\n */\nclass BatchParser<T = any> extends ProcessQueryParser<T> {\n\n    constructor() {\n        super(null);\n    }\n\n    public findResult(json: any): Promise<T> {\n        // we leave it to the individual request parsers to find their results in the raw json body\n        return json;\n    }\n}\n\n/**\n * Handles processing batched results that are also cached\n */\nclass ProcessQueryCachingParserWrapper<T> extends CachingParserWrapper<T> {\n\n    constructor(parser: ProcessQueryParser, wrapper: CachingParserWrapper<T>) {\n        super(parser, wrapper.cacheOptions);\n    }\n\n    public findResult(json: any): Promise<T> {\n        return (<any>this.parser).findResult(json).then((d: any) => this.cacheData(d));\n    }\n}\n"],"names":["tslib_1.__extends","method"],"mappings":"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"}