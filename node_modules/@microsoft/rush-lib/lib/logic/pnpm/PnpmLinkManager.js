"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const path = require("path");
const uriEncode = require("strict-uri-encode");
const link_bins_1 = require("@pnpm/link-bins");
const node_core_library_1 = require("@microsoft/node-core-library");
const BaseLinkManager_1 = require("../base/BaseLinkManager");
const BasePackage_1 = require("../base/BasePackage");
const RushConstants_1 = require("../../logic/RushConstants");
// special flag for debugging, will print extra diagnostic information,
// but comes with performance cost
const DEBUG = false;
class PnpmLinkManager extends BaseLinkManager_1.BaseLinkManager {
    _linkProjects() {
        try {
            const rushLinkJson = {
                localLinks: {}
            };
            let promise = Promise.resolve();
            for (const rushProject of this._rushConfiguration.projects) {
                promise = promise.then(() => {
                    console.log(os.EOL + 'LINKING: ' + rushProject.packageName);
                    return this._linkProject(rushProject, rushLinkJson);
                });
            }
            return promise.then(() => {
                console.log(`Writing "${this._rushConfiguration.rushLinkJsonFilename}"`);
                node_core_library_1.JsonFile.save(rushLinkJson, this._rushConfiguration.rushLinkJsonFilename);
            });
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    /**
     * This is called once for each local project from Rush.json.
     * @param project             The local project that we will create symlinks for
     * @param rushLinkJson        The common/temp/rush-link.json output file
     */
    _linkProject(project, rushLinkJson) {
        // first, read the temp package.json information
        // Example: "project1"
        const unscopedTempProjectName = node_core_library_1.PackageName.getUnscopedName(project.tempProjectName);
        // Example: "C:\MyRepo\common\temp\projects\project1
        const extractedFolder = path.join(this._rushConfiguration.commonTempFolder, RushConstants_1.RushConstants.rushTempProjectsFolderName, unscopedTempProjectName);
        // Example: "C:\MyRepo\common\temp\projects\project1\package.json"
        const packageJsonFilename = path.join(extractedFolder, "package.json" /* PackageJson */);
        // Example: "C:\MyRepo\common\temp\node_modules\@rush-temp\project1"
        const installFolderName = path.join(this._rushConfiguration.commonTempFolder, RushConstants_1.RushConstants.nodeModulesFolderName, RushConstants_1.RushConstants.rushTempNpmScope, unscopedTempProjectName);
        const commonPackage = BasePackage_1.BasePackage.createVirtualTempPackage(packageJsonFilename, installFolderName);
        const localPackage = BasePackage_1.BasePackage.createLinkedPackage(project.packageJsonEditor.name, commonPackage.version, project.projectFolder);
        // now that we have the temp package.json, we can go ahead and link up all the direct dependencies
        // first, start with the rush dependencies, we just need to link to the project folder
        for (const dependencyName of Object.keys(commonPackage.packageJson.rushDependencies || {})) {
            const matchedRushPackage = this._rushConfiguration.getProjectByName(dependencyName);
            if (matchedRushPackage) {
                // We found a suitable match, so place a new local package that
                // symlinks to the Rush project
                const matchedVersion = matchedRushPackage.packageJsonEditor.version;
                let localLinks = rushLinkJson.localLinks[localPackage.name];
                if (!localLinks) {
                    localLinks = [];
                    rushLinkJson.localLinks[localPackage.name] = localLinks;
                }
                localLinks.push(dependencyName);
                // e.g. "C:\my-repo\project-a\node_modules\project-b" if project-b is a rush dependency of project-a
                const newLocalFolderPath = path.join(localPackage.folderPath, 'node_modules', dependencyName);
                const newLocalPackage = BasePackage_1.BasePackage.createLinkedPackage(dependencyName, matchedVersion, newLocalFolderPath);
                newLocalPackage.symlinkTargetFolderPath = matchedRushPackage.projectFolder;
                localPackage.children.push(newLocalPackage);
            }
            else {
                // weird state or program bug
                throw Error(`Cannot find dependency "${dependencyName}" for "${project.packageName}" in rush configuration`);
            }
        }
        // Iterate through all the regular dependencies
        // With npm, it's possible for two different projects to have dependencies on
        // the same version of the same library, but end up with different implementations
        // of that library, if the library is installed twice and with different secondary
        // dependencies.The NpmLinkManager recursively links dependency folders to try to
        // honor this. Since PNPM always uses the same physical folder to represent a given
        // version of a library, we only need to link directly to the folder that PNPM has chosen,
        // and it will have a consistent set of secondary dependencies.
        // each of these dependencies should be linked in a special folder that pnpm
        // creates for the installed version of each .TGZ package, all we need to do
        // is re-use that symlink in order to get linked to whatever PNPM thought was
        // appropriate. This folder is usually something like:
        // C:\{uri-encoed-path-to-tgz}\node_modules\{package-name}
        // e.g.: C:\wbt\common\temp\projects\api-documenter.tgz
        const pathToTgzFile = path.join(this._rushConfiguration.commonTempFolder, 'projects', `${unscopedTempProjectName}.tgz`);
        // e.g.: C%3A%2Fwbt%2Fcommon%2Ftemp%2Fprojects%2Fapi-documenter.tgz
        const escapedPathToTgzFile = uriEncode(node_core_library_1.Text.replaceAll(pathToTgzFile, path.sep, '/'));
        // tslint:disable-next-line:max-line-length
        // e.g.: C:\wbt\common\temp\node_modules\.local\C%3A%2Fwbt%2Fcommon%2Ftemp%2Fprojects%2Fapi-documenter.tgz\node_modules
        const pathToLocalInstallation = path.join(this._rushConfiguration.commonTempFolder, RushConstants_1.RushConstants.nodeModulesFolderName, '.local', escapedPathToTgzFile, RushConstants_1.RushConstants.nodeModulesFolderName);
        for (const dependencyName of Object.keys(commonPackage.packageJson.dependencies || {})) {
            // the dependency we are looking for should have already created a symlink here
            // FYI dependencyName might contain an NPM scope, here it gets converted into a filesystem folder name
            // e.g. if the dependency is supi:
            // tslint:disable-next-line:max-line-length
            // "C:\wbt\common\temp\node_modules\.local\C%3A%2Fwbt%2Fcommon%2Ftemp%2Fprojects%2Fapi-documenter.tgz\node_modules\supi"
            const dependencyLocalInstallationSymlink = path.join(pathToLocalInstallation, dependencyName);
            if (!node_core_library_1.FileSystem.exists(dependencyLocalInstallationSymlink)) {
                // if this occurs, it is a bug in Rush algorithm or unexpected PNPM behavior
                throw Error(`Cannot find installed dependency "${dependencyName}" in "${pathToLocalInstallation}"`);
            }
            if (!node_core_library_1.FileSystem.getLinkStatistics(dependencyLocalInstallationSymlink).isSymbolicLink()) {
                // if this occurs, it is a bug in Rush algorithm or unexpected PNPM behavior
                throw Error(`Dependency "${dependencyName}" is not a symlink in "${pathToLocalInstallation}`);
            }
            // The dependencyLocalInstallationSymlink is just a symlink to another folder.
            // To reduce the number of filesystem reads that are needed, we will link to where that symlink
            // it pointed, rather than linking to a link.
            const dependencyLocalInstallationRealpath = node_core_library_1.FileSystem.getRealPath(dependencyLocalInstallationSymlink);
            const newLocalFolderPath = path.join(localPackage.folderPath, 'node_modules', dependencyName);
            let version = undefined;
            if (DEBUG) {
                // read the version number for diagnostic purposes
                const packageJsonForDependency = node_core_library_1.JsonFile.load(path.join(dependencyLocalInstallationRealpath, "package.json" /* PackageJson */));
                version = packageJsonForDependency.version;
            }
            const newLocalPackage = BasePackage_1.BasePackage.createLinkedPackage(dependencyName, version, newLocalFolderPath);
            newLocalPackage.symlinkTargetFolderPath = dependencyLocalInstallationRealpath;
            localPackage.addChild(newLocalPackage);
        }
        if (DEBUG) {
            localPackage.printTree();
        }
        PnpmLinkManager._createSymlinksForTopLevelProject(localPackage);
        // Also symlink the ".bin" folder
        const projectFolder = path.join(localPackage.folderPath, 'node_modules');
        const projectBinFolder = path.join(localPackage.folderPath, 'node_modules', '.bin');
        // Return type is Promise<void[]> because the API returns Promise.all()
        return link_bins_1.default(projectFolder, projectBinFolder)
            .then(() => { });
    }
}
exports.PnpmLinkManager = PnpmLinkManager;
//# sourceMappingURL=PnpmLinkManager.js.map