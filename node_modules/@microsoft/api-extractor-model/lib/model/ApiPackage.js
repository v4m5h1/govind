"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const ApiItem_1 = require("../items/ApiItem");
const ApiItemContainerMixin_1 = require("../mixins/ApiItemContainerMixin");
const node_core_library_1 = require("@microsoft/node-core-library");
const ApiDocumentedItem_1 = require("../items/ApiDocumentedItem");
const ApiNameMixin_1 = require("../mixins/ApiNameMixin");
var ApiJsonSchemaVersion;
(function (ApiJsonSchemaVersion) {
    /**
     * The initial release.
     */
    ApiJsonSchemaVersion[ApiJsonSchemaVersion["V_1000"] = 1000] = "V_1000";
})(ApiJsonSchemaVersion = exports.ApiJsonSchemaVersion || (exports.ApiJsonSchemaVersion = {}));
/**
 * Represents an NPM package containing API declarations.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * @public
 */
class ApiPackage extends ApiItemContainerMixin_1.ApiItemContainerMixin(ApiNameMixin_1.ApiNameMixin(ApiDocumentedItem_1.ApiDocumentedItem)) {
    static loadFromJsonFile(apiJsonFilename) {
        const jsonObject = node_core_library_1.JsonFile.load(apiJsonFilename);
        return ApiItem_1.ApiItem.deserialize(jsonObject);
    }
    constructor(options) {
        super(options);
    }
    /** @override */
    get kind() {
        return "Package" /* Package */;
    }
    /** @override */
    get canonicalReference() {
        return this.name;
    }
    get entryPoints() {
        return this.members;
    }
    /** @override */
    addMember(member) {
        if (member.kind !== "EntryPoint" /* EntryPoint */) {
            throw new Error('Only items of type ApiEntryPoint may be added to an ApiPackage');
        }
        super.addMember(member);
    }
    findEntryPointsByPath(importPath) {
        return this.findMembersByName(importPath);
    }
    saveToJsonFile(apiJsonFilename, options) {
        if (!options) {
            options = {};
        }
        const packageJson = node_core_library_1.PackageJsonLookup.loadOwnPackageJson(__dirname);
        const jsonObject = {
            metadata: {
                toolPackage: options.toolPackage || packageJson.name,
                // In test mode, we don't write the real version, since that would cause spurious diffs whenever
                // the verison is bumped.  Instead we write a placeholder string.
                toolVersion: options.testMode ? '[test mode]' : options.toolVersion || packageJson.version,
                schemaVersion: ApiJsonSchemaVersion.V_1000
            }
        };
        this.serializeInto(jsonObject);
        node_core_library_1.JsonFile.save(jsonObject, apiJsonFilename, options);
    }
}
exports.ApiPackage = ApiPackage;
//# sourceMappingURL=ApiPackage.js.map