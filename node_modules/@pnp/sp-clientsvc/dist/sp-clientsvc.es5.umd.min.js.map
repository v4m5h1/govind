{"version":3,"file":"sp-clientsvc.es5.umd.min.js","sources":["../../../../node_modules/tslib/tslib.es6.js","../../../../packages/sp-clientsvc/src/opactionbuilders.ts","../../../../packages/sp-clientsvc/src/opbuilders.ts","../../../../packages/sp-clientsvc/src/utils.ts","../../../../packages/sp-clientsvc/src/objectpath.ts","../../../../packages/sp-clientsvc/src/parsers.ts","../../../../packages/sp-clientsvc/src/clintsvcqueryable.ts","../../../../packages/sp-clientsvc/src/batch.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { PropertyType } from \"./types\";\nimport { IMethodParamsBuilder } from \"./opbuilders\";\n\nexport function objectPath(): string {\n    return `<ObjectPath Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\" />`;\n}\n\nexport function identityQuery(): string {\n    return `<ObjectIdentityQuery Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\" />`;\n}\n\nexport function opQuery(selectProperties: string[] = null, childSelectProperties: string[] | null = null): string {\n\n    // this is fairly opaque behavior, but is the simplest way to convey the required information.\n    // if selectProperties.length === 0 or null then select all\n    // else select indicated properties\n\n    // if childSelectProperties === null do not include that block\n    // if childSelectProperties.length === 0 then select all\n    // else select indicated properties\n\n    const builder = [];\n    builder.push(`<Query Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\">`);\n    if (selectProperties === null || selectProperties.length < 1) {\n        builder.push(`<Query SelectAllProperties=\"true\" >`);\n        builder.push(`<Properties />`);\n        builder.push(`</Query >`);\n    } else {\n        builder.push(`<Query SelectAllProperties=\"false\" >`);\n        builder.push(`<Properties>`);\n        [].push.apply(builder, selectProperties.map(p => `<Property Name=\"${p}\" SelectAll=\"true\" />`));\n        builder.push(`</Properties>`);\n        builder.push(`</Query >`);\n    }\n\n    if (childSelectProperties !== null) {\n        if (childSelectProperties.length < 1) {\n            builder.push(`<ChildItemQuery SelectAllProperties=\"true\" >`);\n            builder.push(`<Properties />`);\n            builder.push(`</ChildItemQuery >`);\n        } else {\n            builder.push(`<ChildItemQuery SelectAllProperties=\"false\" >`);\n            builder.push(`<Properties>`);\n            [].push.apply(builder, childSelectProperties.map(p => `<Property Name=\"${p}\" SelectAll=\"true\" />`));\n            builder.push(`</Properties>`);\n            builder.push(`</ChildItemQuery >`);\n        }\n    }\n\n    builder.push(`</Query >`);\n\n    return builder.join(\"\");\n}\n\nexport function setProperty(name: string, type: PropertyType, value: string): string {\n    const builder = [];\n    builder.push(`<SetProperty Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\" Name=\"${name}\">`);\n    builder.push(`<Parameter Type=\"${type}\">${value}</Parameter>`);\n    builder.push(`</SetProperty>`);\n    return builder.join(\"\");\n}\n\nexport function methodAction(name: string, params: IMethodParamsBuilder | null): string {\n\n    const builder = [];\n    builder.push(`<Method Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\" Name=\"${name}\">`);\n\n    if (params !== null) {\n        const arrParams = params.toArray();\n        if (arrParams.length < 1) {\n            builder.push(`<Parameters />`);\n        } else {\n            builder.push(`<Parameters>`);\n            [].push.apply(builder, arrParams.map(p => `<Parameter Type=\"${p.type}\">${p.value}</Parameter>`));\n            builder.push(`</Parameters>`);\n        }\n    }\n\n    builder.push(\"</Method>\");\n\n    return builder.join(\"\");\n}\n\nexport function objectProperties(o: any): string[] {\n\n    return Object.getOwnPropertyNames(o).map((name) => {\n\n        const value = o[name];\n        if (typeof value === \"boolean\") {\n            return setProperty(name, \"Boolean\", `${value}`);\n        } else if (typeof value === \"number\") {\n            return setProperty(name, \"Number\", `${value}`);\n        } else if (typeof value === \"string\") {\n            return setProperty(name, \"String\", `${value}`);\n        }\n\n        return \"\";\n    }, []);\n}\n","import { ObjectPath, IObjectPath } from \"./objectpath\";\nimport { PropertyType } from \"./types\";\n\nexport function property(name: string, ...actions: string[]): IObjectPath {\n    return new ObjectPath(`<Property Id=\"$$ID$$\" ParentId=\"$$PARENT_ID$$\" Name=\"${name}\" />`, actions);\n}\n\nexport function staticMethod(name: string, typeId: string, ...actions: string[]): IObjectPath {\n    return new ObjectPath(`<StaticMethod Id=\"$$ID$$\" Name=\"${name}\" TypeId=\"${typeId}\" />`, actions);\n}\n\nexport function staticProperty(name: string, typeId: string, ...actions: string[]): IObjectPath {\n    return new ObjectPath(`<StaticProperty Id=\"$$ID$$\" Name=\"${name}\" TypeId=\"${typeId}\" />`, actions);\n}\n\nexport function objConstructor(typeId: string, ...actions: string[]): IObjectPath {\n    return new ObjectPath(`<Constructor Id=\"$$ID$$\" TypeId=\"${typeId}\" />`, actions);\n}\n\nexport interface IMethodParamsBuilder {\n    string(value: string): this;\n    number(value: number): this;\n    boolean(value: boolean): this;\n    strArray(values: string[]): this;\n    objectPath(inputIndex: number): this;\n    toArray(): { type: PropertyType, value: string }[];\n}\n\n/**\n * Used to build parameters when calling methods\n */\nexport class MethodParams implements IMethodParamsBuilder {\n\n    constructor(private _p: { type: PropertyType, value: string }[] = []) { }\n\n    public static build(initValues: { type: PropertyType, value: string }[] = []): IMethodParamsBuilder {\n        const params = new MethodParams();\n        [].push.apply(params._p, initValues);\n        return params;\n    }\n\n    public string(value: string): this {\n        return this.a(\"String\", value);\n    }\n\n    public number(value: number): this {\n        return this.a(\"Number\", value.toString());\n    }\n\n    public boolean(value: boolean): this {\n        return this.a(\"Boolean\", value.toString());\n    }\n\n    public strArray(values: string[]): this {\n        return this.a(\"Array\", values.map(v => `<Object Type=\"String\">${v}</Object>`).join(\"\"));\n    }\n\n    public objectPath(inputIndex: number): this {\n        return this.a(\"ObjectPath\", inputIndex.toString());\n    }\n\n    public toArray(): { type: PropertyType, value: string }[] {\n        return this._p;\n    }\n\n    private a(type: PropertyType, value: string): this {\n        this._p.push({ type, value });\n        return this;\n    }\n}\n\nexport function method(name: string, params: IMethodParamsBuilder, ...actions: string[]): IObjectPath {\n    const builder = [];\n    builder.push(`<Method Id=\"$$ID$$\" ParentId=\"$$PARENT_ID$$\" Name=\"${name}\">`);\n\n    if (params !== null) {\n        const arrParams = params.toArray();\n        if (arrParams.length < 1) {\n            builder.push(`<Parameters />`);\n        } else {\n            builder.push(`<Parameters>`);\n            [].push.apply(builder, arrParams.map(p => {\n\n                if (p.type === \"ObjectPath\") {\n                    return `<Parameter ObjectPathId=\"$$OP_PARAM_ID_${p.value}$$\" />`;\n                }\n\n                return `<Parameter Type=\"${p.type}\">${p.value}</Parameter>`;\n            }));\n            builder.push(`</Parameters>`);\n        }\n    }\n\n    builder.push(\"</Method>\");\n\n    return new ObjectPath(builder.join(\"\"), actions);\n}\n","import { IObjectPath } from \"./objectpath\";\n\n/**\n * Transforms an array of object paths into a request xml body. Does not do placeholder substitutions.\n * \n * @param objectPaths The object paths for which we want to generate a body\n */\nexport function writeObjectPathBody(objectPaths: IObjectPath[]): string {\n\n    const actions: string[] = [];\n    const paths: string[] = [];\n\n    objectPaths.forEach(op => {\n        paths.push(op.path);\n        actions.push(...op.actions);\n    });\n\n    // create our xml payload\n    return [\n        `<Request xmlns=\"http://schemas.microsoft.com/sharepoint/clientquery/2009\" SchemaVersion=\"15.0.0.0\" LibraryVersion=\"16.0.0.0\" ApplicationName=\"PnPjs\">`,\n        \"<Actions>\",\n        actions.join(\"\"),\n        \"</Actions>\",\n        \"<ObjectPaths>\",\n        paths.join(\"\"),\n        \"</ObjectPaths>\",\n        \"</Request>\",\n    ].join(\"\");\n}\n","import { TypedHash, extend, objectDefinedNotNull } from \"@pnp/common\";\nimport { objectPath } from \"./opactionbuilders\";\nimport { property, staticProperty } from \"./opbuilders\";\nimport { writeObjectPathBody } from \"./utils\";\n\n/**\n * Defines the properties and method of an ObjectPath\n */\nexport interface IObjectPath {\n    /**\n     * The ObjectPath xml node\n     */\n    path: string;\n    /**\n     * Collection of xml action nodes\n     */\n    actions: string[];\n    /**\n     * The id of this object path, used for processing, not set directly\n     */\n    id: number | undefined;\n}\n\n/**\n * Represents an ObjectPath used when querying ProcessQuery\n */\nexport class ObjectPath implements IObjectPath {\n    constructor(public path: string, public actions: string[] = [], public id = -1, public replaceAfter: IObjectPath[] = []) { }\n}\n\n/**\n * Replaces all found instance of the $$ID$$ placeholder in the supplied xml string\n * \n * @param id New value to be insterted\n * @param xml The existing xml fragment in which the replace should occur\n */\nexport function opSetId(id: string, xml: string): string {\n    return xml.replace(/\\$\\$ID\\$\\$/g, id);\n}\n\n/**\n * Replaces all found instance of the $$PATH_ID$$ placeholder in the supplied xml string\n * \n * @param id New value to be insterted\n * @param xml The existing xml fragment in which the replace should occur\n */\nexport function opSetPathId(id: string, xml: string): string {\n    return xml.replace(/\\$\\$PATH_ID\\$\\$/g, id);\n}\n\n/**\n * Replaces all found instance of the $$PARENT_ID$$ placeholder in the supplied xml string\n * \n * @param id New value to be insterted\n * @param xml The existing xml fragment in which the replace should occur\n */\nexport function opSetParentId(id: string, xml: string): string {\n    return xml.replace(/\\$\\$PARENT_ID\\$\\$/g, id);\n}\n\n/**\n * Replaces all found instance of the $$OP_PARAM_ID$$ placeholder in the supplied xml string\n * \n * @param map A mapping where [index] = replaced_object_path_id\n * @param xml The existing xml fragment in which the replace should occur\n * @param indexMapper Used when creating batches, not meant for direct use external to this library\n */\nexport function opSetPathParamId(map: number[], xml: string, indexMapper: (n: number) => number = (n) => n): string {\n\n    // this approach works because input params must come before the things that need them\n    // meaning the right id will always be in the map\n    const matches = /\\$\\$OP_PARAM_ID_(\\d+)\\$\\$/ig.exec(xml);\n    if (matches !== null) {\n        for (let i = 1; i < matches.length; i++) {\n            const index = parseInt(matches[i], 10);\n            const regex = new RegExp(`\\\\$\\\\$OP_PARAM_ID_${index}\\\\$\\\\$`, \"ig\");\n            xml = xml.replace(regex, map[indexMapper(index)].toString());\n        }\n    }\n\n    return xml;\n}\n\n/**\n * Represents a collection of IObjectPaths\n */\nexport class ObjectPathQueue {\n\n    private _xml: string | null;\n    private _contextIndex = -1;\n    private _siteIndex = -1;\n    private _webIndex = -1;\n\n    constructor(protected _paths: IObjectPath[] = [], protected _relationships: TypedHash<number[]> = {}) { }\n\n    /**\n     * Adds an object path to the queue\n     * \n     * @param op The action to add\n     * @returns The index of the added object path\n     */\n    public add(op: IObjectPath): number {\n\n        this.dirty();\n        this._paths.push(op);\n        return this.lastIndex;\n    }\n\n    public addChildRelationship(parentIndex: number, childIndex: number) {\n        if (objectDefinedNotNull(this._relationships[`_${parentIndex}`])) {\n            this._relationships[`_${parentIndex}`].push(childIndex);\n        } else {\n            this._relationships[`_${parentIndex}`] = [childIndex];\n        }\n    }\n\n    public getChildRelationship(parentIndex: number): number[] {\n        if (objectDefinedNotNull(this._relationships[`_${parentIndex}`])) {\n            return this._relationships[`_${parentIndex}`];\n        } else {\n            return [];\n        }\n    }\n\n    public getChildRelationships(): TypedHash<number[]> {\n        return this._relationships;\n    }\n\n    /**\n     * Appends an action to the supplied IObjectPath, replacing placeholders\n     * \n     * @param op IObjectPath to which the action will be appended\n     * @param action The action to append\n     */\n    public appendAction(op: IObjectPath, action: string): this {\n\n        this.dirty();\n        op.actions.push(action);\n        return this;\n    }\n\n    /**\n     * Appends an action to the last IObjectPath in the collection\n     * \n     * @param action \n     */\n    public appendActionToLast(action: string): this {\n\n        return this.appendAction(this.last, action);\n    }\n\n    /**\n     * Creates a linked copy of this ObjectPathQueue\n     */\n    public copy(): ObjectPathQueue {\n        const copy = new ObjectPathQueue(this.toArray(), extend({}, this._relationships));\n        copy._contextIndex = this._contextIndex;\n        copy._siteIndex = this._siteIndex;\n        copy._webIndex = this._webIndex;\n        return copy;\n    }\n\n    /**\n     * Creates an independent clone of this ObjectPathQueue\n     */\n    public clone(): ObjectPathQueue {\n        const clone = new ObjectPathQueue(this.toArray().map(p => Object.assign({}, p)), extend({}, this._relationships));\n        clone._contextIndex = this._contextIndex;\n        clone._siteIndex = this._siteIndex;\n        clone._webIndex = this._webIndex;\n        return clone;\n    }\n\n    /**\n     * Gets a copy of this instance's paths\n     */\n    public toArray(): IObjectPath[] {\n        return this._paths.slice(0);\n    }\n\n    /**\n     * The last IObjectPath instance added to this collection\n     */\n    public get last(): IObjectPath {\n\n        if (this._paths.length < 1) {\n            return null;\n        }\n\n        return this._paths[this.lastIndex];\n    }\n\n    /**\n     * Index of the last IObjectPath added to the queue\n     */\n    public get lastIndex(): number {\n        return this._paths.length - 1;\n    }\n\n    /**\n     * Gets the index of the current site in the queue\n     */\n    public get siteIndex(): number {\n\n        if (this._siteIndex < 0) {\n\n            // this needs to be here in case we create it\n            const contextIndex = this.contextIndex;\n\n            this._siteIndex = this.add(property(\"Site\",\n                // actions\n                objectPath()));\n\n            this.addChildRelationship(contextIndex, this._siteIndex);\n        }\n\n        return this._siteIndex;\n    }\n\n    /**\n     * Gets the index of the current web in the queue\n     */\n    public get webIndex(): number {\n\n        if (this._webIndex < 0) {\n\n            // this needs to be here in case we create it\n            const contextIndex = this.contextIndex;\n\n            this._webIndex = this.add(property(\"Web\",\n                // actions\n                objectPath()));\n\n            this.addChildRelationship(contextIndex, this._webIndex);\n        }\n\n        return this._webIndex;\n    }\n\n    /**\n     * Gets the index of the Current context in the queue, can be used to establish parent -> child rels\n     */\n    public get contextIndex(): number {\n        if (this._contextIndex < 0) {\n            this._contextIndex = this.add(staticProperty(\"Current\", \"{3747adcd-a3c3-41b9-bfab-4a64dd2f1e0a}\",\n                // actions\n                objectPath()));\n        }\n\n        return this._contextIndex;\n    }\n\n    public toBody(): string {\n\n        if (objectDefinedNotNull(this._xml)) {\n            return this._xml;\n        }\n\n        // create our xml payload\n        this._xml = writeObjectPathBody(this.toIndexedTree());\n\n        return this._xml;\n    }\n\n    /**\n     * Conducts the string replacements for id, parent id, and path id\n     * \n     * @returns The tree with all string replacements made\n     */\n    public toIndexedTree(): IObjectPath[] {\n\n        let builderIndex = -1;\n        let lastOpId = -1;\n        const idIndexMap: number[] = [];\n\n        return this.toArray().map((op, index, arr) => {\n\n            const opId = ++builderIndex;\n\n            // track the array index => opId relationship\n            idIndexMap.push(opId);\n\n            // do path replacements\n            op.path = opSetPathParamId(idIndexMap, opSetId(opId.toString(), op.path));\n\n            if (lastOpId >= 0) {\n                // if we have a parent do the replace\n                op.path = opSetParentId(lastOpId.toString(), op.path);\n            }\n\n            // rewrite actions with placeholders replaced\n            op.actions = op.actions.map(a => {\n                const actionId = ++builderIndex;\n                return opSetId(actionId.toString(), opSetPathId(opId.toString(), a));\n            });\n\n            // handle any specific child relationships\n            this.getChildRelationship(index).forEach(childIndex => {\n                // set the parent id for our non-immediate children, thus removing the token so it isn't overwritten\n                arr[childIndex].path = opSetParentId(opId.toString(), arr[childIndex].path);\n            });\n\n            // and remember our last object path id for the parent replace above\n            lastOpId = opId;\n\n            return op;\n        });\n    }\n\n    /**\n     * Dirties this queue clearing any cached data\n     */\n    protected dirty(): void {\n        this._xml = null;\n    }\n}\n","import { getAttrValueFromString, jsS, hOP } from \"@pnp/common\";\nimport { IObjectPath } from \"./objectpath\";\n\n/**\n * Used within the request pipeline to parse ProcessQuery results\n */\nexport class ProcessQueryParser<T = any> {\n\n    constructor(protected op: IObjectPath) { }\n\n    /**\n     * Parses the response checking for errors\n     * \n     * @param r Response object\n     */\n    public parse(r: Response): Promise<T> {\n\n        return r.text().then(t => {\n\n            if (!r.ok) {\n                throw Error(t);\n            }\n\n            try {\n                return JSON.parse(t);\n            } catch (e) {\n                // special case in ProcessQuery where we got an error back, but it is not in json format\n                throw Error(t);\n            }\n\n        }).then((parsed: any[]) => {\n\n            // here we need to check for an error body\n            if (parsed.length > 0 && hOP(parsed[0], \"ErrorInfo\") && parsed[0].ErrorInfo !== null) {\n                throw Error(jsS(parsed[0].ErrorInfo));\n            }\n\n            return this.findResult(parsed);\n        });\n    }\n\n    public findResult(json: any): Promise<T | null> {\n\n        for (let i = 0; i < this.op.actions.length; i++) {\n\n            const a = this.op.actions[i];\n\n            // let's see if the result is null based on the ObjectPath action, if it exists\n            // <ObjectPath Id=\"8\" ObjectPathId=\"7\" />\n            if (/^<ObjectPath /i.test(a)) {\n                const result = this.getParsedResultById<{ IsNull: boolean }>(json, parseInt(getAttrValueFromString(a, \"Id\"), 10));\n                if (!result || (result && result.IsNull)) {\n                    return Promise.resolve(null);\n                }\n            }\n\n            // let's see if we have a query result\n            // <Query Id=\"5\" ObjectPathId = \"3\" >\n            if (/^<Query /i.test(a)) {\n                const result = this.getParsedResultById(json, parseInt(getAttrValueFromString(a, \"Id\"), 10));\n\n                if (result && hOP(result, \"_Child_Items_\")) {\n                    // this is a collection result\n                    /* tslint:disable:no-string-literal */\n                    return Promise.resolve(result[\"_Child_Items_\"]);\n                    /* tslint:enable:no-string-literal */\n                } else {\n                    // this is an instance result\n                    return Promise.resolve(result);\n                }\n            }\n\n            // this is an invokeMethodAction so the last method action corresponds to our result\n            if (i === (this.op.actions.length - 1) && /^<Method /i.test(a)) {\n                return Promise.resolve(this.getParsedResultById(json, parseInt(getAttrValueFromString(a, \"Id\"), 10)));\n            }\n        }\n\n        // no result could be found so we are effectively returning void\n        // issue is we really don't know if we should be returning void (a method invocation with a void return) or\n        // if we just didn't find something above. We will let downstream things worry about that\n    }\n\n    /**\n     * Locates a result by ObjectPath id\n     * \n     * @param parsed the parsed JSON body from the response\n     * @param id The ObjectPath id whose result we want\n     */\n    protected getParsedResultById<R = any>(parsed: any[], id: number): R {\n\n        for (let i = 0; i < parsed.length; i++) {\n\n            if (parsed[i] === id) {\n                return parsed[i + 1];\n            }\n        }\n\n        return null;\n    }\n}\n","import {\n    FetchOptions,\n    combine,\n    extend,\n    getGUID,\n    mergeHeaders,\n    mergeOptions,\n    objectDefinedNotNull,\n    hOP,\n    getHashCode,\n    stringIsNullOrEmpty,\n} from \"@pnp/common\";\nimport { CachingOptions, ICachingOptions, ODataParser, Queryable, RequestContext } from \"@pnp/odata\";\nimport { SPHttpClient, toAbsoluteUrl } from \"@pnp/sp\";\nimport { IObjectPathBatch } from \"./batch\";\nimport { ObjectPathQueue } from \"./objectpath\";\nimport { methodAction, objectPath, objectProperties, opQuery } from \"./opactionbuilders\";\nimport { IMethodParamsBuilder, method, property } from \"./opbuilders\";\nimport { ProcessQueryParser } from \"./parsers\";\n\nexport interface IClientSvcQueryable {\n    select(...selects: string[]): this;\n    usingCaching(options?: ICachingOptions): this;\n    inBatch(batch: IObjectPathBatch): this;\n}\n\nexport interface ClientSvcQueryableConstructor<T> {\n    new(baseUrl: string | ClientSvcQueryable, objectPaths?: ObjectPathQueue): T;\n}\n\nconst ProcessQueryPath = \"_vti_bin/client.svc/ProcessQuery\";\n\nexport class ClientSvcQueryable<GetType = any> extends Queryable<GetType> implements IClientSvcQueryable {\n\n    /**\n     * Collection of select fields\n     */\n    protected _selects: string[];\n\n    /**\n     * Tracks the batch of which this query may be part\n     */\n    protected _batch: IObjectPathBatch | null;\n\n    /**\n     * Allows us to properly block batch execution until everything is loaded\n     */\n    protected _batchDependency: () => void | null;\n\n    constructor(parent: ClientSvcQueryable | string = \"\", protected _objectPaths: ObjectPathQueue | null = null) {\n        super();\n\n        this._selects = [];\n        this._batch = null;\n        this._batchDependency = null;\n\n        if (typeof parent === \"string\") {\n\n            // we assume the parent here is an absolute url to a web\n            this._parentUrl = parent;\n            this._url = combine(parent.replace(ProcessQueryPath, \"\"), ProcessQueryPath);\n            if (!objectDefinedNotNull(this._objectPaths)) {\n                this._objectPaths = new ObjectPathQueue();\n            }\n\n        } else {\n            this._parentUrl = parent._parentUrl;\n            this._url = combine(parent._parentUrl, ProcessQueryPath);\n            if (!objectDefinedNotNull(_objectPaths)) {\n                this._objectPaths = parent._objectPaths.clone();\n            }\n            this.configureFrom(parent);\n        }\n    }\n\n    /**\n     * Choose which fields to return\n     *\n     * @param selects One or more fields to return\n     */\n    public select(...selects: string[]): this {\n        [].push.apply(this._selects, selects);\n        return this;\n    }\n\n    /**\n     * Adds this query to the supplied batch\n     *\n     */\n    public inBatch(batch: IObjectPathBatch): this {\n\n        if (this.batch !== null) {\n            throw Error(\"This query is already part of a batch.\");\n        }\n\n        if (objectDefinedNotNull(batch)) {\n            this._batch = batch;\n            this._batchDependency = batch.addDependency();\n        }\n\n        return this;\n    }\n\n    /**\n     * Gets the full url with query information\n     *\n     */\n    public toUrlAndQuery(): string {\n        return `${super.toUrl()}?${Array.from(this.query).map((v: [string, string]) => v[0] + \"=\" + v[1]).join(\"&\")}`;\n    }\n\n    protected getSelects(): string[] {\n        return objectDefinedNotNull(this._selects) ? this._selects : [];\n    }\n\n    /**\n     * Gets a child object based on this instance's paths and the supplied paramters\n     * \n     * @param factory Instance factory of the child type\n     * @param methodName Name of the method used to load the child\n     * @param params Parameters required by the method to load the child\n     */\n    protected getChild<T>(factory: ClientSvcQueryableConstructor<T>, methodName: string, params: IMethodParamsBuilder | null): T {\n\n        const objectPaths = this._objectPaths.copy();\n\n        objectPaths.add(method(methodName, params,\n            // actions\n            objectPath()));\n\n        return new factory(this, objectPaths);\n    }\n\n    /**\n     * Gets a property of the current instance\n     * \n     * @param factory Instance factory of the child type\n     * @param propertyName Name of the property to load\n     */\n    protected getChildProperty<T>(factory: ClientSvcQueryableConstructor<T>, propertyName: string): T {\n\n        const objectPaths = this._objectPaths.copy();\n\n        objectPaths.add(property(propertyName));\n\n        return new factory(this, objectPaths);\n    }\n\n    /**\n     * Sends a request\n     * \n     * @param op \n     * @param options \n     * @param parser \n     */\n    protected send<T = any>(objectPaths: ObjectPathQueue, options: FetchOptions = {}, parser: ODataParser<T> = null): Promise<T> {\n\n        // here we need to create a clone because all the string indexes and references\n        // will be updated and all need to relate for this operation being sent. The parser\n        // and the postCore method need to share an independent value of the objectPaths\n        // See for https://github.com/pnp/pnpjs/issues/419 for details\n        const clonedOps = objectPaths.clone();\n\n        if (!objectDefinedNotNull(parser)) {\n            // we assume here that we want to return for this index path\n            parser = new ProcessQueryParser(clonedOps.last);\n        }\n\n        if (this.hasBatch) {\n\n            // this is using the options variable to pass some extra information downstream to the batch\n            options = extend(options, {\n                clientsvc_ObjectPaths: clonedOps,\n            });\n\n        } else {\n\n            if (!hOP(options, \"body\")) {\n                options = extend(options, {\n                    body: clonedOps.toBody(),\n                });\n            }\n        }\n\n        return super.postCore(options, parser);\n    }\n\n    /**\n     * Sends the request, merging the result data with a new instance of factory\n     */\n    protected sendGet<DataType, FactoryType>(factory: ClientSvcQueryableConstructor<FactoryType>): Promise<(DataType & FactoryType)> {\n\n        const ops = this._objectPaths.copy().appendActionToLast(opQuery(this.getSelects()));\n\n        return this.send<DataType>(ops).then(r => extend(new factory(this), r));\n    }\n\n    /**\n     * Sends the request, merging the result data array with a new instances of factory\n     */\n    protected sendGetCollection<DataType, FactoryType>(factory: (d: DataType) => FactoryType): Promise<(DataType & FactoryType)[]> {\n\n        const ops = this._objectPaths.copy().appendActionToLast(opQuery([], this.getSelects()));\n\n        return this.send<DataType[]>(ops).then(r => r.map(d => extend(factory(d), d)));\n    }\n\n    /**\n     * Invokes the specified method on the server and returns the result\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param actions Any additional actions to execute in addition to the method invocation (set property for example)\n     */\n    protected invokeMethod<T>(methodName: string, params: IMethodParamsBuilder | null = null, ...actions: string[]): Promise<T> {\n        return this.invokeMethodImpl(methodName, params, actions, opQuery([], null));\n    }\n\n    /**\n     * Invokes a method action that returns a single result and does not have an associated query (ex: GetDescription on Term)\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param actions Any additional actions to execute in addition to the method invocation (set property for example)\n     */\n    protected invokeMethodAction<T>(methodName: string, params: IMethodParamsBuilder | null = null, ...actions: string[]): Promise<T> {\n        return this.invokeMethodImpl(methodName, params, actions, null, true);\n    }\n\n    /**\n     * Invokes the specified non-query method on the server\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param actions Any additional actions to execute in addition to the method invocation (set property for example)\n     */\n    protected invokeNonQuery(methodName: string, params: IMethodParamsBuilder | null = null, ...actions: string[]): Promise<void> {\n        // by definition we are not returning anything from these calls so we should not be caching the results\n        this._useCaching = false;\n        return this.invokeMethodImpl<void>(methodName, params, actions, null, true);\n    }\n\n    /**\n     * Invokes the specified method on the server and returns the resulting collection\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param actions Any additional actions to execute in addition to the method invocation (set property for example)\n     */\n    protected invokeMethodCollection<T>(methodName: string, params: IMethodParamsBuilder | null = null, ...actions: string[]): Promise<T> {\n        return this.invokeMethodImpl(methodName, params, actions, opQuery([], []));\n    }\n\n    /**\n     * Updates this instance, returning a copy merged with the updated data after the update\n     * \n     * @param properties Plain object of the properties and values to update\n     * @param factory Factory method use to create a new instance of FactoryType\n     */\n    protected invokeUpdate<DataType, FactoryType>(properties: any, factory: ClientSvcQueryableConstructor<FactoryType>): Promise<DataType & FactoryType> {\n\n        const ops = this._objectPaths.copy();\n        // append setting all the properties to this instance\n        objectProperties(properties).map(a => ops.appendActionToLast(a));\n        ops.appendActionToLast(opQuery([], null));\n        return this.send<DataType>(ops).then(r => extend(new factory(this), r));\n    }\n\n    /**\n     * Converts the current instance to a request context\n     *\n     * @param verb The request verb\n     * @param options The set of supplied request options\n     * @param parser The supplied ODataParser instance\n     * @param pipeline Optional request processing pipeline\n     */\n    protected toRequestContext<T>(\n        verb: string,\n        options: FetchOptions,\n        parser: ODataParser<T>,\n        pipeline: Array<(c: RequestContext<T>) => Promise<RequestContext<T>>>): Promise<RequestContext<T>> {\n\n        return toAbsoluteUrl(this.toUrlAndQuery()).then(url => {\n\n            mergeOptions(options, this._options);\n\n            const headers = new Headers();\n\n            mergeHeaders(headers, options.headers);\n\n            mergeHeaders(headers, {\n                \"accept\": \"*/*\",\n                \"content-type\": \"text/xml\",\n            });\n\n            options = extend(options, { headers });\n\n            // we need to do some special cache handling to ensure we have a good key\n            if (this._useCaching) {\n\n                let keyStr = options.body;\n\n                if (stringIsNullOrEmpty(keyStr)) {\n\n                    if (hOP(options, \"clientsvc_ObjectPaths\")) {\n                        // if we are using caching and batching together we need to create our string from the paths stored for the\n                        // batching operation (see: https://github.com/pnp/pnpjs/issues/449) but not update the ones passed to\n                        // the batch as they will be indexed during the batch creation process\n                        keyStr = (<{ clientsvc_ObjectPaths: ObjectPathQueue }>options).clientsvc_ObjectPaths.clone().toBody();\n                    } else {\n                        // this case shouldn't happen\n                        keyStr = \"\";\n                    }\n                }\n\n                // because all the requests use the same url they would collide in the cache we use a special key\n                const cacheKey = `PnPjs.ProcessQueryClient(${getHashCode(keyStr)})`;\n\n                if (objectDefinedNotNull(this._cachingOptions)) {\n                    // if our key ends in the ProcessQuery url we overwrite it\n                    if (/\\/client\\.svc\\/ProcessQuery\\?$/i.test(this._cachingOptions.key)) {\n                        this._cachingOptions.key = cacheKey;\n                    }\n                } else {\n                    this._cachingOptions = new CachingOptions(cacheKey);\n                }\n            }\n\n            const dependencyDispose = this.hasBatch ? this._batchDependency : () => { return; };\n\n            // build our request context\n            const context: RequestContext<T> = {\n                batch: this.batch,\n                batchDependency: dependencyDispose,\n                cachingOptions: this._cachingOptions,\n                clientFactory: () => new SPHttpClient(),\n                isBatched: this.hasBatch,\n                isCached: this._useCaching,\n                options: options,\n                parser: parser,\n                pipeline: pipeline,\n                requestAbsoluteUrl: url,\n                requestId: getGUID(),\n                verb: verb,\n            };\n\n            return context;\n        });\n    }\n\n    /**\n     * Blocks a batch call from occuring, MUST be cleared by calling the returned function\n    */\n    protected addBatchDependency(): () => void {\n        if (this._batch !== null) {\n            return this._batch.addDependency();\n        }\n\n        return () => null;\n    }\n\n    /**\n     * Indicates if the current query has a batch associated\n     *\n     */\n    protected get hasBatch(): boolean {\n        return objectDefinedNotNull(this._batch);\n    }\n\n    /**\n     * The batch currently associated with this query or null\n     *\n     */\n    protected get batch(): IObjectPathBatch {\n        return this.hasBatch ? this._batch : null;\n    }\n\n    /**\n     * Executes the actual invoke method call\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param queryAction Specifies the query action to take\n     */\n    private invokeMethodImpl<T>(methodName: string, params: IMethodParamsBuilder | null, actions: string[], queryAction: string, isAction = false): Promise<T> {\n\n        const ops = this._objectPaths.copy();\n\n        if (isAction) {\n            ops.appendActionToLast(methodAction(methodName, params));\n        } else {\n            ops.add(method(methodName, params, ...[objectPath(), ...actions, queryAction]));\n        }\n\n        return this.send<T>(ops);\n    }\n}\n","import { LogLevel, Logger } from \"@pnp/logging\";\nimport { CachingParserWrapper, ODataBatch, ODataBatchRequestInfo } from \"@pnp/odata\";\nimport { ClientSvcQueryable } from \"./clintsvcqueryable\";\nimport { ObjectPath, ObjectPathQueue, opSetId, opSetParentId, opSetPathId, opSetPathParamId } from \"./objectpath\";\nimport { objectPath } from \"./opactionbuilders\";\nimport { staticMethod } from \"./opbuilders\";\nimport { ProcessQueryParser } from \"./parsers\";\nimport { writeObjectPathBody } from \"./utils\";\n\nexport interface IObjectPathBatch extends ODataBatch {\n\n}\n\n/**\n * Implements ODataBatch for use with the ObjectPath framework\n */\nexport class ObjectPathBatch extends ODataBatch implements IObjectPathBatch {\n\n    constructor(protected parentUrl: string, _batchId?: string) {\n        super(_batchId);\n    }\n\n    protected executeImpl(): Promise<void> {\n\n        // if we don't have any requests, don't bother sending anything\n        // this could be due to caching further upstream, or just an empty batch\n        if (this.requests.length < 1) {\n            Logger.write(`Resolving empty batch.`, LogLevel.Info);\n            return Promise.resolve();\n        }\n\n        const executor = new BatchExecutor(this.parentUrl, this.batchId);\n        executor.appendRequests(this.requests);\n        return executor.execute();\n    }\n}\n\nclass BatchExecutor extends ClientSvcQueryable {\n\n    private _builderIndex: number;\n    private _requests: ODataBatchRequestInfo[];\n\n    constructor(parentUrl: string, public batchId: string) {\n        super(parentUrl);\n\n        this._requests = [];\n        this._builderIndex = 1;\n\n        // we add our session object path and hard code in the IDs so we can reference it\n        const method = staticMethod(\"GetTaxonomySession\", \"{981cbc68-9edc-4f8d-872f-71146fcbb84f}\");\n        method.path = opSetId(\"0\", method.path);\n        method.actions.push(opSetId(\"1\", opSetPathId(\"0\", objectPath())));\n\n        this._objectPaths.add(method);\n    }\n\n    public appendRequests(requests: ODataBatchRequestInfo[]): void {\n\n        requests.forEach(request => {\n\n            // grab the special property we added to options when we created the batch info\n            const pathQueue: ObjectPathQueue = (<any>request.options).clientsvc_ObjectPaths;\n\n            let paths = pathQueue.toArray();\n\n            // getChildRelationships\n            if (paths.length < 0) {\n                return;\n            }\n\n            let indexMappingFunction = (n: number) => n;\n\n            if (/GetTaxonomySession/i.test(paths[0].path)) {\n\n                // drop the first thing as it is a get session object path, which we add once for the entire batch\n                paths = paths.slice(1);\n\n                // replace the next item's parent id with 0, which will be the id of the session call at the root of this request\n                paths[0].path = opSetParentId(\"0\", paths[0].path);\n\n                indexMappingFunction = (n: number) => n - 1;\n            }\n\n            let lastOpId = -1;\n            const idIndexMap: number[] = [];\n\n            paths.map((op, index, arr) => {\n\n                // rewrite the path string\n                const opId = ++this._builderIndex;\n\n                // track the array index => opId relationship\n                idIndexMap.push(opId);\n\n                let path = opSetPathParamId(idIndexMap, opSetId(opId.toString(), op.path), indexMappingFunction);\n                if (lastOpId >= 0) {\n                    path = opSetParentId(lastOpId.toString(), path);\n                }\n\n                // rewrite actions with placeholders replaced\n                const opActions = op.actions.map(a => {\n                    const actionId = ++this._builderIndex;\n                    return opSetId(actionId.toString(), opSetPathId(opId.toString(), a));\n                });\n\n                // handle any specific child relationships\n                // the childIndex is reduced by 1 because we are removing the Session Path\n                pathQueue.getChildRelationship(index + 1).map(i => i - 1).forEach(childIndex => {\n                    // set the parent id for our non-immediate children\n                    arr[childIndex].path = opSetParentId(opId.toString(), arr[childIndex].path);\n                });\n\n                // and remember our last object path id for the parent replace above\n                lastOpId = opId;\n\n                // return our now substituted path and actions as a new object path instance\n                return new ObjectPath(path, opActions);\n\n            }).forEach(op => this._objectPaths.add(op));\n\n            // get this once\n            const obPaths = this._objectPaths.toArray();\n\n            // create a new parser to handle finding the result based on the path\n            const parser = new ProcessQueryParser(obPaths[obPaths.length - 1]);\n\n            if (request.parser instanceof CachingParserWrapper) {\n                // handle special case of caching\n                request.parser = new ProcessQueryCachingParserWrapper(parser, request.parser);\n            } else {\n                request.parser = parser;\n            }\n\n            // add the request to our batch requests\n            this._requests.push(request);\n\n            // remove the temp property\n            delete (<any>request.options).clientsvc_ObjectPaths;\n        });\n    }\n\n    public execute(): Promise<void> {\n\n        Logger.write(`[${this.batchId}] (${(new Date()).getTime()}) Executing batch with ${this._requests.length} requests.`, LogLevel.Info);\n\n        // create our request body from all the merged object paths\n        const options = {\n            body: writeObjectPathBody(this._objectPaths.toArray()),\n        };\n\n        Logger.write(`[${this.batchId}] (${(new Date()).getTime()}) Sending batch request.`, LogLevel.Info);\n\n        // send the batch\n        return super.postCore(options, new BatchParser()).then((rawResponse: any) => {\n\n            Logger.write(`[${this.batchId}] (${(new Date()).getTime()}) Resolving batched requests.`, LogLevel.Info);\n\n            return this._requests.reduce((chain, request) => {\n\n                Logger.write(`[${request.id}] (${(new Date()).getTime()}) Resolving request in batch ${this.batchId}.`, LogLevel.Info);\n\n                return chain.then(_ => (<ProcessQueryParser>request.parser).findResult(rawResponse).then(request.resolve).catch(request.reject));\n\n            }, Promise.resolve());\n        });\n    }\n}\n\n/**\n * Used to return the raw results from parsing the batch\n */\nclass BatchParser<T = any> extends ProcessQueryParser<T> {\n\n    constructor() {\n        super(null);\n    }\n\n    public findResult(json: any): Promise<T> {\n        // we leave it to the individual request parsers to find their results in the raw json body\n        return json;\n    }\n}\n\n/**\n * Handles processing batched results that are also cached\n */\nclass ProcessQueryCachingParserWrapper<T> extends CachingParserWrapper<T> {\n\n    constructor(parser: ProcessQueryParser, wrapper: CachingParserWrapper<T>) {\n        super(parser, wrapper.cacheOptions);\n    }\n\n    public findResult(json: any): Promise<T> {\n        return (<any>this.parser).findResult(json).then((d: any) => this.cacheData(d));\n    }\n}\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","objectPath","opQuery","selectProperties","childSelectProperties","builder","push","length","apply","map","join","setProperty","name","type","value","methodAction","params","arrParams","toArray","objectProperties","o","getOwnPropertyNames","property","_i","actions","ObjectPath","staticMethod","typeId","staticProperty","MethodParams","initValues","_p","a","toString","values","v","inputIndex","method","writeObjectPathBody","objectPaths","paths","forEach","op","path","id","replaceAfter","opSetId","xml","replace","opSetPathId","opSetParentId","opSetPathParamId","indexMapper","n","matches","exec","i","index","parseInt","regex","RegExp","ObjectPathQueue","dirty","_paths","lastIndex","parentIndex","childIndex","objectDefinedNotNull","_relationships","action","appendAction","last","copy","extend","_contextIndex","_siteIndex","_webIndex","clone","assign","slice","contextIndex","add","addChildRelationship","_xml","toIndexedTree","builderIndex","lastOpId","idIndexMap","arr","opId","_this","getChildRelationship","ProcessQueryParser","r","text","then","t","ok","Error","JSON","parse","e","parsed","hOP","ErrorInfo","jsS","findResult","json","result","test","getParsedResultById","getAttrValueFromString","IsNull","Promise","resolve","ProcessQueryPath","tslib_1.__extends","Queryable","ClientSvcQueryable","selects","_selects","batch","_batch","_batchDependency","addDependency","_super","toUrl","from","query","factory","methodName","_objectPaths","propertyName","options","parser","clonedOps","hasBatch","clientsvc_ObjectPaths","body","toBody","postCore","ops","appendActionToLast","getSelects","send","invokeMethodImpl","_useCaching","properties","verb","pipeline","toAbsoluteUrl","toUrlAndQuery","url","mergeOptions","_options","headers","Headers","mergeHeaders","accept","content-type","keyStr","stringIsNullOrEmpty","cacheKey","getHashCode","_cachingOptions","key","CachingOptions","dependencyDispose","batchDependency","cachingOptions","clientFactory","SPHttpClient","isBatched","isCached","requestAbsoluteUrl","requestId","getGUID","queryAction","isAction","parent","_parentUrl","_url","combine","configureFrom","ODataBatch","ObjectPathBatch","requests","Logger","write","executor","BatchExecutor","parentUrl","batchId","appendRequests","execute","_batchId","request","pathQueue","indexMappingFunction","_builderIndex","opActions","obPaths","CachingParserWrapper","ProcessQueryCachingParserWrapper","_requests","Date","getTime","BatchParser","rawResponse","reduce","chain","_","catch","reject","cacheData","wrapper","cacheOptions"],"mappings":"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"}