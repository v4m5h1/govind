"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const os = require("os");
const stream_collator_1 = require("@microsoft/stream-collator");
const Stopwatch_1 = require("../../utilities/Stopwatch");
const TaskStatus_1 = require("./TaskStatus");
/**
 * A class which manages the execution of a set of tasks with interdependencies.
 * Any class of task definition may be registered, and dependencies between tasks are
 * easily specified. Initially, and at the end of each task execution, all unblocked tasks
 * are added to a ready queue which is then executed. This is done continually until all
 * tasks are complete, or prematurely fails if any of the tasks fail. Note that all task
 * definitions must
 * @todo #168352: add unit tests
 */
class TaskRunner {
    constructor(quietMode, parallelism, changedProjectsOnly) {
        this._tasks = new Map();
        this._buildQueue = [];
        this._quietMode = quietMode;
        this._hasAnyFailures = false;
        this._changedProjectsOnly = changedProjectsOnly;
        const numberOfCores = os.cpus().length;
        if (parallelism) {
            if (parallelism === 'max') {
                this._parallelism = numberOfCores;
            }
            else {
                const parallelismInt = parseInt(parallelism, 10);
                if (isNaN(parallelismInt)) {
                    throw new Error(`Invalid parallelism value of '${parallelism}', expected a number or 'max'`);
                }
                this._parallelism = parallelismInt;
            }
        }
        else {
            // If an explicit parallelism number wasn't provided, then choose a sensible
            // default.
            if (os.platform() === 'win32') {
                // On desktop Windows, some people have complained that their system becomes
                // sluggish if Rush is using all the CPU cores.  Leave one thread for
                // other operations. For CI environments, you can use the "max" argument to use all available cores.
                this._parallelism = Math.max(numberOfCores - 1, 1);
            }
            else {
                // Unix-like operating systems have more balanced scheduling, so default
                // to the number of CPU cores
                this._parallelism = numberOfCores;
            }
        }
    }
    /**
     * Registers a task definition to the map of defined tasks
     */
    addTask(taskDefinition) {
        if (this._tasks.has(taskDefinition.name)) {
            throw new Error('A task with that name has already been registered.');
        }
        const task = taskDefinition;
        task.dependencies = new Set();
        task.dependents = new Set();
        task.status = TaskStatus_1.TaskStatus.Ready;
        task.criticalPathLength = undefined;
        this._tasks.set(task.name, task);
        if (!this._quietMode) {
            console.log(`Registered ${task.name}`);
        }
    }
    /**
     * Returns true if a task with that name has been registered
     */
    hasTask(taskName) {
        return this._tasks.has(taskName);
    }
    /**
     * Defines the list of dependencies for an individual task.
     * @param taskName - the string name of the task for which we are defining dependencies. A task with this
     * name must already have been registered.
     * @taskDependencies
     */
    addDependencies(taskName, taskDependencies) {
        const task = this._tasks.get(taskName);
        if (!task) {
            throw new Error(`The task '${taskName}' has not been registered`);
        }
        if (!taskDependencies) {
            throw new Error('The list of dependencies must be defined');
        }
        for (const dependencyName of taskDependencies) {
            if (!this._tasks.has(dependencyName)) {
                throw new Error(`The project '${dependencyName}' has not been registered.`);
            }
            const dependency = this._tasks.get(dependencyName);
            task.dependencies.add(dependency);
            dependency.dependents.add(task);
        }
    }
    /**
     * Executes all tasks which have been registered, returning a promise which is resolved when all the
     * tasks are completed successfully, or rejects when any task fails.
     */
    execute() {
        this._currentActiveTasks = 0;
        this._completedTasks = 0;
        this._totalTasks = this._tasks.size;
        console.log(`Executing a maximum of ${this._parallelism} simultaneous processes...${os.EOL}`);
        this._checkForCyclicDependencies(this._tasks.values(), []);
        // Precalculate the number of dependent packages
        this._tasks.forEach((task) => {
            this._calculateCriticalPaths(task);
        });
        // Add everything to the buildQueue
        this._tasks.forEach((task) => {
            this._buildQueue.push(task);
        });
        // Sort the queue in descending order, nothing will mess with the order
        this._buildQueue.sort((taskA, taskB) => {
            return taskB.criticalPathLength - taskA.criticalPathLength;
        });
        return this._startAvailableTasks().then(() => {
            this._printTaskStatus();
            if (this._hasAnyFailures) {
                return Promise.reject(new Error('Project(s) failed to build'));
            }
            else {
                return Promise.resolve();
            }
        });
    }
    /**
     * Pulls the next task with no dependencies off the build queue
     * Removes any non-ready tasks from the build queue (this should only be blocked tasks)
     */
    _getNextTask() {
        for (let i = 0; i < this._buildQueue.length; i++) {
            const task = this._buildQueue[i];
            if (task.status !== TaskStatus_1.TaskStatus.Ready) {
                // It shouldn't be on the queue, remove it
                this._buildQueue.splice(i, 1);
                // Decrement since we modified the array
                i--;
            }
            else if (task.dependencies.size === 0 && task.status === TaskStatus_1.TaskStatus.Ready) {
                // this is a task which is ready to go. remove it and return it
                return this._buildQueue.splice(i, 1)[0];
            }
            // Otherwise task is still waiting
        }
        return undefined; // There are no tasks ready to go at this time
    }
    /**
     * Helper function which finds any tasks which are available to run and begins executing them.
     * It calls the complete callback when all tasks are completed, or rejects if any task fails.
     */
    _startAvailableTasks() {
        const taskPromises = [];
        let ctask;
        while (this._currentActiveTasks < this._parallelism && (ctask = this._getNextTask())) {
            this._currentActiveTasks++;
            const task = ctask;
            task.status = TaskStatus_1.TaskStatus.Executing;
            console.log(colors.white(`[${task.name}] started`));
            task.stopwatch = Stopwatch_1.Stopwatch.start();
            task.writer = stream_collator_1.Interleaver.registerTask(task.name, this._quietMode);
            taskPromises.push(task.execute(task.writer)
                .then((result) => {
                task.stopwatch.stop();
                task.writer.close();
                this._currentActiveTasks--;
                this._completedTasks++;
                switch (result) {
                    case TaskStatus_1.TaskStatus.Success:
                        this._markTaskAsSuccess(task);
                        break;
                    case TaskStatus_1.TaskStatus.SuccessWithWarning:
                        this._markTaskAsSuccessWithWarning(task);
                        break;
                    case TaskStatus_1.TaskStatus.Skipped:
                        this._markTaskAsSkipped(task);
                        break;
                    case TaskStatus_1.TaskStatus.Failure:
                        this._hasAnyFailures = true;
                        this._markTaskAsFailed(task);
                        break;
                }
            }).catch((error) => {
                task.writer.close();
                this._currentActiveTasks--;
                this._hasAnyFailures = true;
                task.error = error;
                this._markTaskAsFailed(task);
            }).then(() => this._startAvailableTasks()));
        }
        return Promise.all(taskPromises).then(() => { });
    }
    /**
     * Marks a task as having failed and marks each of its dependents as blocked
     */
    _markTaskAsFailed(task) {
        console.log(colors.red(`${os.EOL}${this._getCurrentCompletedTaskString()}[${task.name}] failed to build!`));
        task.status = TaskStatus_1.TaskStatus.Failure;
        task.dependents.forEach((dependent) => {
            this._markTaskAsBlocked(dependent, task);
        });
    }
    /**
     * Marks a task and all its dependents as blocked
     */
    _markTaskAsBlocked(task, failedTask) {
        if (task.status === TaskStatus_1.TaskStatus.Ready) {
            this._completedTasks++;
            console.log(colors.red(`${this._getCurrentCompletedTaskString()}`
                + `[${task.name}] blocked by [${failedTask.name}]!`));
            task.status = TaskStatus_1.TaskStatus.Blocked;
            task.dependents.forEach((dependent) => {
                this._markTaskAsBlocked(dependent, failedTask);
            });
        }
    }
    /**
     * Marks a task as being completed, and removes it from the dependencies list of all its dependents
     */
    _markTaskAsSuccess(task) {
        console.log(colors.green(`${this._getCurrentCompletedTaskString()}`
            + `[${task.name}] completed successfully in ${task.stopwatch.toString()}`));
        task.status = TaskStatus_1.TaskStatus.Success;
        task.dependents.forEach((dependent) => {
            if (!this._changedProjectsOnly) {
                dependent.isIncrementalBuildAllowed = false;
            }
            dependent.dependencies.delete(task);
        });
    }
    /**
     * Marks a task as being completed, but with warnings written to stderr, and removes it from the dependencies
     * list of all its dependents
     */
    _markTaskAsSuccessWithWarning(task) {
        console.log(colors.yellow(`${this._getCurrentCompletedTaskString()}`
            + `[${task.name}] completed with warnings in ${task.stopwatch.toString()}`));
        task.status = TaskStatus_1.TaskStatus.SuccessWithWarning;
        task.dependents.forEach((dependent) => {
            if (!this._changedProjectsOnly) {
                dependent.isIncrementalBuildAllowed = false;
            }
            dependent.dependencies.delete(task);
        });
    }
    /**
     * Marks a task as skipped.
     */
    _markTaskAsSkipped(task) {
        console.log(colors.green(`${this._getCurrentCompletedTaskString()}[${task.name}] skipped`));
        task.status = TaskStatus_1.TaskStatus.Skipped;
        task.dependents.forEach((dependent) => {
            dependent.dependencies.delete(task);
        });
    }
    _getCurrentCompletedTaskString() {
        return `${this._completedTasks} of ${this._totalTasks}: `;
    }
    /**
     * Checks for projects that indirectly depend on themselves.
     */
    _checkForCyclicDependencies(tasks, dependencyChain) {
        for (const task of tasks) {
            if (dependencyChain.indexOf(task.name) >= 0) {
                throw new Error('A cyclic dependency was encountered:\n'
                    + '  ' + [...dependencyChain, task.name].reverse().join('\n  -> ')
                    + '\nConsider using the cyclicDependencyProjects option for rush.json.');
            }
            dependencyChain.push(task.name);
            this._checkForCyclicDependencies(task.dependents, dependencyChain);
            dependencyChain.pop();
        }
    }
    /**
     * Calculate the number of packages which must be built before we reach
     * the furthest away "root" node
     */
    _calculateCriticalPaths(task) {
        // Return the memoized value
        if (task.criticalPathLength !== undefined) {
            return task.criticalPathLength;
        }
        // If no dependents, we are in a "root"
        if (task.dependents.size === 0) {
            return task.criticalPathLength = 0;
        }
        else {
            // Otherwise we are as long as the longest package + 1
            const depsLengths = [];
            task.dependents.forEach(dep => this._calculateCriticalPaths(dep));
            return task.criticalPathLength = Math.max(...depsLengths) + 1;
        }
    }
    /**
     * Prints out a report of the status of each project
     */
    _printTaskStatus() {
        const tasksByStatus = {};
        this._tasks.forEach((task) => {
            if (tasksByStatus[task.status]) {
                tasksByStatus[task.status].push(task);
            }
            else {
                tasksByStatus[task.status] = [task];
            }
        });
        console.log('');
        this._printStatus(TaskStatus_1.TaskStatus.Executing, tasksByStatus, colors.yellow);
        this._printStatus(TaskStatus_1.TaskStatus.Ready, tasksByStatus, colors.white);
        this._printStatus(TaskStatus_1.TaskStatus.Skipped, tasksByStatus, colors.grey);
        this._printStatus(TaskStatus_1.TaskStatus.Success, tasksByStatus, colors.green);
        this._printStatus(TaskStatus_1.TaskStatus.SuccessWithWarning, tasksByStatus, colors.yellow.underline);
        this._printStatus(TaskStatus_1.TaskStatus.Blocked, tasksByStatus, colors.red);
        this._printStatus(TaskStatus_1.TaskStatus.Failure, tasksByStatus, colors.red);
        const tasksWithErrors = tasksByStatus[TaskStatus_1.TaskStatus.Failure];
        if (tasksWithErrors) {
            tasksWithErrors.forEach((task) => {
                if (task.error) {
                    console.log(colors.red(`[${task.name}] ${task.error.message}`));
                }
            });
        }
        console.log('');
    }
    _printStatus(status, tasksByStatus, color) {
        const tasks = tasksByStatus[status];
        if (tasks && tasks.length) {
            console.log(color(`${status} (${tasks.length})`));
            console.log(color('================================'));
            for (let i = 0; i < tasks.length; i++) {
                const task = tasks[i];
                switch (status) {
                    case TaskStatus_1.TaskStatus.Executing:
                    case TaskStatus_1.TaskStatus.Ready:
                    case TaskStatus_1.TaskStatus.Skipped:
                        console.log(color(task.name));
                        break;
                    case TaskStatus_1.TaskStatus.Success:
                    case TaskStatus_1.TaskStatus.SuccessWithWarning:
                    case TaskStatus_1.TaskStatus.Blocked:
                    case TaskStatus_1.TaskStatus.Failure:
                        if (task.stopwatch) {
                            const time = task.stopwatch.toString();
                            console.log(color(`${task.name} (${time})`));
                        }
                        else {
                            console.log(color(`${task.name}`));
                        }
                        break;
                }
                if (task.writer) {
                    let stderr = task.writer.getStdError();
                    if (stderr && (task.status === TaskStatus_1.TaskStatus.Failure || task.status === TaskStatus_1.TaskStatus.SuccessWithWarning)) {
                        stderr = stderr.split(os.EOL)
                            .map(text => text.trim())
                            .filter(text => text)
                            .join(os.EOL);
                        console.log(stderr + (i !== tasks.length - 1 ? os.EOL : ''));
                    }
                }
            }
            console.log(color('================================' + os.EOL));
        }
    }
}
exports.TaskRunner = TaskRunner;
//# sourceMappingURL=TaskRunner.js.map