{"version":3,"file":"dom.js","sourceRoot":"../src/","sources":["dom.ts"],"names":[],"mappings":"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","sourcesContent":["import { IRectangle } from './IRectangle';\r\n\r\n/**\r\n * Attached interface for elements which support virtual references.\r\n * Used internally by the virtual hierarchy methods.\r\n */\r\ninterface IVirtualElement extends HTMLElement {\r\n  _virtual: {\r\n    parent?: IVirtualElement;\r\n    children: IVirtualElement[];\r\n  };\r\n}\r\n\r\nexport const DATA_PORTAL_ATTRIBUTE = 'data-portal-element';\r\n\r\n/**\r\n * Sets the virtual parent of an element.\r\n * Pass `undefined` as the `parent` to clear the virtual parent.\r\n *\r\n * @public\r\n */\r\nexport function setVirtualParent(child: HTMLElement, parent: HTMLElement): void {\r\n  let virtualChild = <IVirtualElement>child;\r\n  let virtualParent = <IVirtualElement>parent;\r\n\r\n  if (!virtualChild._virtual) {\r\n    virtualChild._virtual = {\r\n      children: []\r\n    };\r\n  }\r\n\r\n  let oldParent = virtualChild._virtual.parent;\r\n\r\n  if (oldParent && oldParent !== parent) {\r\n    // Remove the child from its old parent.\r\n    let index = oldParent._virtual.children.indexOf(virtualChild);\r\n\r\n    if (index > -1) {\r\n      oldParent._virtual.children.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  virtualChild._virtual.parent = virtualParent || undefined;\r\n\r\n  if (virtualParent) {\r\n    if (!virtualParent._virtual) {\r\n      virtualParent._virtual = {\r\n        children: []\r\n      };\r\n    }\r\n\r\n    virtualParent._virtual.children.push(virtualChild);\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the virtual parent given the child element, if it exists.\r\n *\r\n * @public\r\n */\r\nexport function getVirtualParent(child: HTMLElement): HTMLElement | undefined {\r\n  let parent: HTMLElement | undefined;\r\n\r\n  if (child && isVirtualElement(child)) {\r\n    parent = child._virtual.parent;\r\n  }\r\n\r\n  return parent;\r\n}\r\n\r\n/**\r\n * Gets the element which is the parent of a given element.\r\n * If `allowVirtuaParents` is `true`, this method prefers the virtual parent over\r\n * real DOM parent when present.\r\n *\r\n * @public\r\n */\r\nexport function getParent(child: HTMLElement, allowVirtualParents: boolean = true): HTMLElement | null {\r\n  return child && ((allowVirtualParents && getVirtualParent(child)) || (child.parentNode && (child.parentNode as HTMLElement)));\r\n}\r\n\r\n/**\r\n * Gets the elements which are child elements of the given element.\r\n * If `allowVirtualChildren` is `true`, this method enumerates virtual child elements\r\n * after the original children.\r\n * @param parent - The element to get the children of.\r\n * @param allowVirtualChildren - true if the method should enumerate virtual child elements.\r\n */\r\nexport function getChildren(parent: HTMLElement, allowVirtualChildren: boolean = true): HTMLElement[] {\r\n  const children: HTMLElement[] = [];\r\n\r\n  if (parent) {\r\n    for (let i = 0; i < parent.children.length; i++) {\r\n      children.push(parent.children.item(i) as HTMLElement);\r\n    }\r\n\r\n    if (allowVirtualChildren && isVirtualElement(parent)) {\r\n      children.push(...parent._virtual.children);\r\n    }\r\n  }\r\n\r\n  return children;\r\n}\r\n\r\n/**\r\n * Determines whether or not a parent element contains a given child element.\r\n * If `allowVirtualParents` is true, this method may return `true` if the child\r\n * has the parent in its virtual element hierarchy.\r\n *\r\n * @public\r\n */\r\nexport function elementContains(parent: HTMLElement | null, child: HTMLElement | null, allowVirtualParents: boolean = true): boolean {\r\n  let isContained = false;\r\n\r\n  if (parent && child) {\r\n    if (allowVirtualParents) {\r\n      isContained = false;\r\n\r\n      while (child) {\r\n        let nextParent: HTMLElement | null = getParent(child);\r\n\r\n        if (nextParent === parent) {\r\n          isContained = true;\r\n          break;\r\n        }\r\n\r\n        child = nextParent;\r\n      }\r\n    } else if (parent.contains) {\r\n      isContained = parent.contains(child);\r\n    }\r\n  }\r\n\r\n  return isContained;\r\n}\r\n\r\nlet _isSSR = false;\r\n\r\n/**\r\n * Helper to set ssr mode to simulate no window object returned from getWindow helper.\r\n *\r\n * @public\r\n */\r\nexport function setSSR(isEnabled: boolean): void {\r\n  _isSSR = isEnabled;\r\n}\r\n\r\n/**\r\n * Helper to get the window object.\r\n *\r\n * @public\r\n */\r\nexport function getWindow(rootElement?: Element | null): Window | undefined {\r\n  if (_isSSR || typeof window === 'undefined') {\r\n    return undefined;\r\n  } else {\r\n    return rootElement && rootElement.ownerDocument && rootElement.ownerDocument.defaultView\r\n      ? rootElement.ownerDocument.defaultView\r\n      : window;\r\n  }\r\n}\r\n\r\n/**\r\n * Helper to get the document object.\r\n *\r\n * @public\r\n */\r\nexport function getDocument(rootElement?: HTMLElement | null): Document | undefined {\r\n  if (_isSSR || typeof document === 'undefined') {\r\n    return undefined;\r\n  } else {\r\n    return rootElement && rootElement.ownerDocument ? rootElement.ownerDocument : document;\r\n  }\r\n}\r\n\r\n/**\r\n * Helper to get bounding client rect, works with window.\r\n *\r\n * @public\r\n */\r\nexport function getRect(element: HTMLElement | Window | null): IRectangle | undefined {\r\n  let rect: IRectangle | undefined;\r\n\r\n  if (element) {\r\n    if (element === window) {\r\n      rect = {\r\n        left: 0,\r\n        top: 0,\r\n        width: window.innerWidth,\r\n        height: window.innerHeight,\r\n        right: window.innerWidth,\r\n        bottom: window.innerHeight\r\n      };\r\n    } else if ((element as HTMLElement).getBoundingClientRect) {\r\n      rect = (element as HTMLElement).getBoundingClientRect();\r\n    }\r\n  }\r\n\r\n  return rect;\r\n}\r\n\r\n/**\r\n * Identify element as a portal by setting an attribute.\r\n * @param element - Element to mark as a portal.\r\n */\r\nexport function setPortalAttribute(element: HTMLElement): void {\r\n  element.setAttribute(DATA_PORTAL_ATTRIBUTE, 'true');\r\n}\r\n\r\n/**\r\n * Determine whether a target is within a portal from perspective of root or optional parent.\r\n * This function only works against portal components that use the setPortalAttribute function.\r\n * If both parent and child are within the same portal this function will return false.\r\n * @param target - Element to query portal containment status of.\r\n * @param parent - Optional parent perspective. Search for containing portal stops at parent (or root if parent is undefined or invalid.)\r\n */\r\nexport function portalContainsElement(target: HTMLElement, parent?: HTMLElement): boolean {\r\n  const elementMatch = findElementRecursive(\r\n    target,\r\n    (testElement: HTMLElement) => parent === testElement || testElement.hasAttribute(DATA_PORTAL_ATTRIBUTE)\r\n  );\r\n  return elementMatch !== null && elementMatch.hasAttribute(DATA_PORTAL_ATTRIBUTE);\r\n}\r\n\r\n/**\r\n * Finds the first parent element where the matchFunction returns true\r\n * @param element - element to start searching at\r\n * @param matchFunction - the function that determines if the element is a match\r\n * @returns the matched element or null no match was found\r\n */\r\nexport function findElementRecursive(element: HTMLElement | null, matchFunction: (element: HTMLElement) => boolean): HTMLElement | null {\r\n  if (!element || element === document.body) {\r\n    return null;\r\n  }\r\n\r\n  return matchFunction(element) ? element : findElementRecursive(getParent(element), matchFunction);\r\n}\r\n\r\n/**\r\n * Determines if an element, or any of its ancestors, contain the given attribute\r\n * @param element - element to start searching at\r\n * @param attribute - the attribute to search for\r\n * @returns the value of the first instance found\r\n */\r\nexport function elementContainsAttribute(element: HTMLElement, attribute: string): string | null {\r\n  let elementMatch = findElementRecursive(element, (testElement: HTMLElement) => testElement.hasAttribute(attribute));\r\n  return elementMatch && elementMatch.getAttribute(attribute);\r\n}\r\n\r\n/**\r\n * Determines whether or not an element has the virtual hierarchy extension.\r\n *\r\n * @public\r\n */\r\nfunction isVirtualElement(element: HTMLElement | IVirtualElement): element is IVirtualElement {\r\n  return element && !!(<IVirtualElement>element)._virtual;\r\n}\r\n"]}