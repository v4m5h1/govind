define(["require", "exports", "tslib", "react", "../../Utilities"], function (require, exports, tslib_1, React, Utilities_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FocusTrapZone = /** @class */ (function (_super) {
        tslib_1.__extends(FocusTrapZone, _super);
        function FocusTrapZone() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._root = React.createRef();
            _this._onFocusCapture = function (ev) {
                if (_this.props.onFocusCapture) {
                    _this.props.onFocusCapture(ev);
                }
                if (ev.target !== ev.currentTarget) {
                    // every time focus changes within the trap zone, remember the focused element so that
                    // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))
                    _this._previouslyFocusedElementInTrapZone = ev.target;
                }
            };
            _this._onKeyboardHandler = function (ev) {
                if (_this.props.onKeyDown) {
                    _this.props.onKeyDown(ev);
                }
                // If the default has been prevented, do not process keyboard events.
                if (ev.isDefaultPrevented()) {
                    return;
                }
                if (ev.which !== Utilities_1.KeyCodes.tab) {
                    return;
                }
                if (!_this._root.current) {
                    return;
                }
                var _firstTabbableChild = Utilities_1.getFirstTabbable(_this._root.current, _this._root.current.firstChild, true);
                var _lastTabbableChild = Utilities_1.getLastTabbable(_this._root.current, _this._root.current.lastChild, true);
                if (ev.shiftKey && _firstTabbableChild === ev.target) {
                    Utilities_1.focusAsync(_lastTabbableChild);
                    ev.preventDefault();
                    ev.stopPropagation();
                }
                else if (!ev.shiftKey && _lastTabbableChild === ev.target) {
                    Utilities_1.focusAsync(_firstTabbableChild);
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            };
            return _this;
        }
        FocusTrapZone.prototype.componentDidMount = function () {
            this._bringFocusIntoZone();
            this._updateEventHandlers(this.props);
        };
        FocusTrapZone.prototype.componentWillReceiveProps = function (nextProps) {
            var elementToFocusOnDismiss = nextProps.elementToFocusOnDismiss;
            if (elementToFocusOnDismiss && this._previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {
                this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;
            }
            this._updateEventHandlers(nextProps);
        };
        FocusTrapZone.prototype.componentDidUpdate = function (prevProps) {
            var prevForceFocusInsideTrap = prevProps.forceFocusInsideTrap !== undefined ? prevProps.forceFocusInsideTrap : true;
            var newForceFocusInsideTrap = this.props.forceFocusInsideTrap !== undefined ? this.props.forceFocusInsideTrap : true;
            if (!prevForceFocusInsideTrap && newForceFocusInsideTrap) {
                // Transition from forceFocusInsideTrap disabled to enabled. Emulate what happens when a FocusTrapZone gets mounted
                this._bringFocusIntoZone();
            }
            else if (prevForceFocusInsideTrap && !newForceFocusInsideTrap) {
                // Transition from forceFocusInsideTrap enabled to disabled. Emulate what happens when a FocusTrapZone gets unmounted
                this._returnFocusToInitiator();
            }
        };
        FocusTrapZone.prototype.componentWillUnmount = function () {
            this._events.dispose();
            this._returnFocusToInitiator();
        };
        FocusTrapZone.prototype.render = function () {
            var _a = this.props, className = _a.className, ariaLabelledBy = _a.ariaLabelledBy;
            var divProps = Utilities_1.getNativeProps(this.props, Utilities_1.divProperties);
            return (React.createElement("div", tslib_1.__assign({}, divProps, { className: className, ref: this._root, "aria-labelledby": ariaLabelledBy, onKeyDown: this._onKeyboardHandler, onFocusCapture: this._onFocusCapture }), this.props.children));
        };
        FocusTrapZone.prototype.focus = function () {
            var _a = this.props, focusPreviouslyFocusedInnerElement = _a.focusPreviouslyFocusedInnerElement, firstFocusableSelector = _a.firstFocusableSelector;
            if (focusPreviouslyFocusedInnerElement &&
                this._previouslyFocusedElementInTrapZone &&
                Utilities_1.elementContains(this._root.current, this._previouslyFocusedElementInTrapZone)) {
                // focus on the last item that had focus in the zone before we left the zone
                Utilities_1.focusAsync(this._previouslyFocusedElementInTrapZone);
                return;
            }
            var focusSelector = typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector && firstFocusableSelector();
            var _firstFocusableChild;
            if (this._root.current) {
                if (focusSelector) {
                    _firstFocusableChild = this._root.current.querySelector('.' + focusSelector);
                }
                else {
                    _firstFocusableChild = Utilities_1.getNextElement(this._root.current, this._root.current.firstChild, true, false, false, true);
                }
            }
            if (_firstFocusableChild) {
                Utilities_1.focusAsync(_firstFocusableChild);
            }
        };
        FocusTrapZone.prototype._bringFocusIntoZone = function () {
            var _a = this.props, elementToFocusOnDismiss = _a.elementToFocusOnDismiss, _b = _a.disableFirstFocus, disableFirstFocus = _b === void 0 ? false : _b;
            FocusTrapZone._focusStack.push(this);
            this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss
                ? elementToFocusOnDismiss
                : document.activeElement;
            if (!Utilities_1.elementContains(this._root.current, this._previouslyFocusedElementOutsideTrapZone) && !disableFirstFocus) {
                this.focus();
            }
        };
        FocusTrapZone.prototype._returnFocusToInitiator = function () {
            var _this = this;
            var ignoreExternalFocusing = this.props.ignoreExternalFocusing;
            FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter(function (value) {
                return _this !== value;
            });
            var activeElement = document.activeElement;
            if (!ignoreExternalFocusing &&
                this._previouslyFocusedElementOutsideTrapZone &&
                typeof this._previouslyFocusedElementOutsideTrapZone.focus === 'function' &&
                (Utilities_1.elementContains(this._root.current, activeElement) || activeElement === document.body)) {
                Utilities_1.focusAsync(this._previouslyFocusedElementOutsideTrapZone);
            }
        };
        FocusTrapZone.prototype._updateEventHandlers = function (newProps) {
            var _a = newProps.isClickableOutsideFocusTrap, isClickableOutsideFocusTrap = _a === void 0 ? false : _a, _b = newProps.forceFocusInsideTrap, forceFocusInsideTrap = _b === void 0 ? true : _b;
            if (forceFocusInsideTrap && !this._hasFocusHandler) {
                this._events.on(window, 'focus', this._forceFocusInTrap, true);
            }
            else if (!forceFocusInsideTrap && this._hasFocusHandler) {
                this._events.off(window, 'focus', this._forceFocusInTrap, true);
            }
            this._hasFocusHandler = forceFocusInsideTrap;
            if (!isClickableOutsideFocusTrap && !this._hasClickHandler) {
                this._events.on(window, 'click', this._forceClickInTrap, true);
            }
            else if (isClickableOutsideFocusTrap && this._hasClickHandler) {
                this._events.off(window, 'click', this._forceClickInTrap, true);
            }
            this._hasClickHandler = !isClickableOutsideFocusTrap;
        };
        FocusTrapZone.prototype._forceFocusInTrap = function (ev) {
            if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {
                var focusedElement = ev.relatedTarget || document.activeElement;
                if (!Utilities_1.elementContains(this._root.current, focusedElement)) {
                    this.focus();
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        };
        FocusTrapZone.prototype._forceClickInTrap = function (ev) {
            if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {
                var clickedElement = ev.target;
                if (clickedElement && !Utilities_1.elementContains(this._root.current, clickedElement)) {
                    this.focus();
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        };
        FocusTrapZone._focusStack = [];
        return FocusTrapZone;
    }(Utilities_1.BaseComponent));
    exports.FocusTrapZone = FocusTrapZone;
});
//# sourceMappingURL=FocusTrapZone.js.map