"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Url = require("url");
const path = require("path");
const glob = require("glob");
const Webpack = require("webpack");
const fsx = require("fs-extra");
const lodash = require("lodash");
const rush_lib_1 = require("@microsoft/rush-lib");
const node_core_library_1 = require("@microsoft/node-core-library");
const OdspGulpTask_1 = require("./../OdspGulpTask");
const cumulativeManifestProcessor_1 = require("./../cumulativeManifestProcessor");
const deployToAzure_1 = require("./../deployAzureStorage/uploadCDN/deployToAzure");
const ensureBlobService_1 = require("./../utilities/azureStorage/ensureBlobService");
const ensureContainer_1 = require("./../utilities//azureStorage/ensureContainer");
const uploadFilesToAzure_1 = require("./../utilities//azureStorage/uploadFilesToAzure");
const url_1 = require("./../utilities/url");
const RetryablePromise_1 = require("./../utilities/RetryablePromise");
const WriteManifestsTask_1 = require("../writeManifests/WriteManifestsTask");
const DevDeployLinkPrinter_1 = require("./DevDeployLinkPrinter");
const constants_1 = require("../constants");
const MANIFESTS_AZURE_FILENAME = 'manifests.js';
const SP_LOADER_ASSEMBLY_ID = '44bae1a2-d2eb-4e10-8c21-a1dbdce1036f';
const MAX_UPLOAD_RETRIES = 3;
const RETRY_DELAY_MS = 250;
const SOURCE_BRANCH_ENV_VAR_NAME = 'BUILD_SOURCEBRANCH';
class DevDeployTask extends OdspGulpTask_1.default {
    constructor() {
        super('dev-deploy', {
            useRush: false,
            isolateProjects: true
        });
    }
    executeTask(gulp, completeCallback) {
        if (this.taskConfig.requireContainerDirectoryName &&
            (!this.taskConfig.containerDirectoryName || this.taskConfig.containerDirectoryName.trim() === '')) {
            completeCallback('containerDirectoryName must be set to ensure files aren\'t deployed to the same directory as another user');
        }
        const metadataFilePath = this._getMetadataDropPath();
        if (fsx.existsSync(metadataFilePath)) {
            // Proactively delete the metadata file so we aren't left with invalid metadata from a previous deploy if
            // this deploy fails
            fsx.unlinkSync(metadataFilePath);
        }
        if (!this.taskConfig.account) {
            completeCallback('Azure storage account not set.');
            return;
        }
        if (!this.taskConfig.accessKey) {
            completeCallback('Azure storage account access key not set.');
            return;
        }
        if (!this.taskConfig.container) {
            completeCallback('Azure container name not set.');
            return;
        }
        if (!this.taskConfig.containerDirectoryName) {
            this.logWarning('It is strongly recommended a directory inside the container be used to avoid clobbering other ' +
                'users\' dev deployments.');
        }
        this.taskConfig.useRush = this.taskConfig.useRush || (process.argv.indexOf('--rush') !== -1);
        const ciMode = process.argv.indexOf('--ciMode') !== -1;
        if (ciMode) {
            const branchName = process.env[SOURCE_BRANCH_ENV_VAR_NAME];
            const containerDirectoryName = branchName
                ? branchName.replace(/[^A-Za-z0-9\-]+/g, '_')
                : `${this.taskConfig.containerDirectoryName}_tab`;
            this.setConfig({
                containerDirectoryName,
                useRush: true,
                isolateProjects: false
            });
        }
        const cumulativeManifestProcessor = cumulativeManifestProcessor_1.default.initializeFromGulpTask(this, { explicitInclude: [SP_LOADER_ASSEMBLY_ID] });
        let manifests;
        try {
            manifests = this._getManifests(cumulativeManifestProcessor);
        }
        catch (e) {
            completeCallback(e);
            return;
        }
        const manifestsArray = [];
        this.logVerbose(`Discovered ${Object.keys(manifests).length} projects.`);
        const storageDirName = this._getStorageDirName();
        const containerUrl = this._getContainerUrl();
        const filesToUpload = [];
        const dirsToUpload = new Map();
        const projectContainerNames = new Map(); // Ensure we don't reuse a name
        let spLoaderPath;
        let debugSPLoader;
        // Loop through the manifests and collect files and directories to be uploaded, and fix up manifest fields
        for (const id in manifests) {
            if (manifests.hasOwnProperty(id)) {
                for (const version in manifests[id]) {
                    if (manifests[id].hasOwnProperty(version)) {
                        const referencedProject = manifests[id][version];
                        const manifest = referencedProject.manifestData;
                        const loaderConfig = manifest.loaderConfig;
                        manifestsArray.push(manifest);
                        const projectContainerName = this.taskConfig.isolateProjects
                            ? this._getAzureDirName(projectContainerNames, referencedProject.packagePath)
                            : '';
                        const projectBasePath = url_1.joinUrlSegments(storageDirName, projectContainerName);
                        const projectBaseFullUrl = url_1.joinUrlSegments(containerUrl, projectBasePath);
                        // A relative base URL applies when the paths are based on the tenant URL.
                        // This applies, for example, in the JSOM library, that takes the JS files from a known place
                        //  available on every tenant.
                        const isBaseUrlRelative = loaderConfig.internalModuleBaseUrls.length > 0
                            && !Url.parse(loaderConfig.internalModuleBaseUrls[0]).protocol;
                        // If the Base URL is a relative path, keep the relative path
                        if (!isBaseUrlRelative) {
                            loaderConfig.internalModuleBaseUrls = [url_1.ensureTrailingSlash(projectBaseFullUrl)];
                        }
                        // Ensure we don't reuse a name
                        const resourceContainerNames = new Map();
                        const processPath = (rawResourcePath) => {
                            const resourcePath = this._disambiguatePath(rawResourcePath);
                            // If the base URL was relative, a relative path for a resource doesn't need to be fixed up
                            if (url_1.isUrl(resourcePath) || isBaseUrlRelative) {
                                return resourcePath; // Do not deal with fully-qualified URL.
                            }
                            else {
                                const filesystemPath = path.join(referencedProject.packagePath, resourcePath);
                                const filename = path.basename(resourcePath);
                                // Path resources are in the 'dist' directory by default and usually have some secondary
                                //  references, so let's just upload the whole directory.
                                const filesystemDirectory = path.dirname(filesystemPath);
                                const azureResourceDirName = this.taskConfig.isolateProjects
                                    ? this._getAzureDirName(resourceContainerNames, filesystemDirectory) :
                                    '';
                                const azureDirectory = url_1.joinUrlSegments(projectBasePath, azureResourceDirName);
                                dirsToUpload.set(filesystemDirectory, azureDirectory);
                                if (!spLoaderPath && id === SP_LOADER_ASSEMBLY_ID) {
                                    spLoaderPath = azureDirectory;
                                    debugSPLoader = filename;
                                }
                                return url_1.joinUrlSegments(azureResourceDirName, filename);
                            }
                        };
                        this._doComponentTypeSpecificFixup(manifest, processPath);
                        for (const scriptResourceId in loaderConfig.scriptResources) {
                            if (loaderConfig.scriptResources.hasOwnProperty(scriptResourceId)) {
                                const scriptResource = loaderConfig.scriptResources[scriptResourceId];
                                switch (scriptResource.type) {
                                    case 'path':
                                        // Path script resource, we need to fix up its path and upload it
                                        const pathResource = scriptResource;
                                        pathResource.path = processPath(pathResource.path);
                                        break;
                                    case 'component':
                                        // We probably don't need to upload the fallback file, and it's nigh-impossible to tell if we'll
                                        // miss secondary dependencies by only uploading the file at the failoverPath, so we'll just clear
                                        // it out and hope this dependency is either satisfied by another dev-deploy manifest or by the OOB
                                        // framework
                                        const componentResource = scriptResource;
                                        componentResource.failoverPath = undefined;
                                        break;
                                    case 'localizedPath':
                                        // Localized path script resource, we need to fix up the paths for each locale and upload each file
                                        const localizedPathResource = scriptResource;
                                        // Select en-us if it exists, otherwise pass through the default path.
                                        localizedPathResource.defaultPath = processPath((localizedPathResource.paths
                                            ? localizedPathResource.paths[constants_1.default.defaultLocale]
                                            : localizedPathResource.defaultPath) ||
                                            localizedPathResource.defaultPath);
                                        if (localizedPathResource.paths) {
                                            for (const locale in localizedPathResource.paths) {
                                                if (localizedPathResource.paths.hasOwnProperty(locale)) {
                                                    localizedPathResource.paths[locale] = processPath(localizedPathResource.paths[locale]);
                                                }
                                            }
                                        }
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        // Expand directories to individual files
        const directoryExpandPromises = [];
        const collisionDetectionMap = new Map();
        dirsToUpload.forEach((azureDirName, localDirName) => {
            directoryExpandPromises.push(this._getFilesInDirectory(localDirName).then((files) => {
                files.forEach((file) => {
                    const azureUrl = url_1.joinUrlSegments(azureDirName, file.replace(/\\/g, '/'));
                    const localPath = path.join(localDirName, file);
                    if (fsx.statSync(localPath).isDirectory()) {
                        return; // Continue on directories
                    }
                    if (!this.taskConfig.isolateProjects) {
                        if (collisionDetectionMap.has(azureUrl)) {
                            collisionDetectionMap.get(azureUrl).push(localPath);
                        }
                        else {
                            collisionDetectionMap.set(azureUrl, [localPath]);
                        }
                    }
                    filesToUpload.push({
                        localPath,
                        azurePath: azureUrl
                    });
                });
            }));
        });
        const blobServicePromise = ensureBlobService_1.default(this.taskConfig.account, this.taskConfig.accessKey)
            .then((blobService) => ensureContainer_1.default(blobService, this.taskConfig.container, 
        /* createContainerOptions */ undefined, this.log.bind(this)));
        const uploadPromise = blobServicePromise.then((blobService) => {
            const rawUploadPromise = Promise.all(directoryExpandPromises).then(() => {
                return uploadFilesToAzure_1.default(blobService, this.taskConfig.container, filesToUpload, this.log.bind(this));
            });
            return RetryablePromise_1.default.allWithRetries([new RetryablePromise_1.default(rawUploadPromise)], MAX_UPLOAD_RETRIES, RETRY_DELAY_MS).then((services) => {
                return services[0];
            });
        });
        const manifestsFilePromise = uploadPromise.then((blobService) => {
            const webpackConfig = cumulativeManifestProcessor.getManifestsFileWebpackConfig(manifestsArray);
            const manifestsFilename = 'devDeployManifests.js';
            const manifestsFileFullPath = path.join(webpackConfig.output.path, manifestsFilename);
            webpackConfig.output.filename = manifestsFilename;
            return new Promise((resolve, reject) => {
                Webpack(webpackConfig, (err) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            }).then(() => {
                return RetryablePromise_1.default.allWithRetries([new RetryablePromise_1.default(uploadFilesToAzure_1.default(blobService, this.taskConfig.container, [{
                            localPath: manifestsFileFullPath,
                            azurePath: url_1.joinUrlSegments(storageDirName, MANIFESTS_AZURE_FILENAME)
                        }], this.log.bind(this)))], MAX_UPLOAD_RETRIES, RETRY_DELAY_MS).then((services) => {
                    return services[0];
                });
            });
        });
        return manifestsFilePromise.then(() => {
            const devDeployUrl = this.getDebugManifestUrl();
            const loaderUrl = url_1.joinUrlSegments(containerUrl, spLoaderPath, debugSPLoader);
            this.log('UPLOAD COMPLETE.');
            // Warn about collisions
            collisionDetectionMap.forEach((localPaths, url) => {
                if (localPaths.length > 1 && !this._doesFilenameAppearToContainHash(localPaths[0])) {
                    this.logWarning(`COLLISION DETECTED: [${localPaths.join(',')}] all deployed to the same URL (${url}). ` +
                        `It is very probable that the dev-deploy will not work as expected. This may indicate a ` +
                        `serious issue for production environments as well.`);
                }
            });
            this._devDeployMetadata = {
                loaderUrl,
                debugManifestUrl: devDeployUrl,
                deployUrl: this.getDeployUrl()
            };
            DevDeployLinkPrinter_1.printDevDeployLink(this.log.bind(this), this._devDeployMetadata);
            this.properties.devDeployManifestFileUrl = devDeployUrl;
            this.properties.devDeployModuleLoaderUrl = loaderUrl;
            const dropPath = this._getMetadataDropPath();
            fsx.ensureDirSync(path.dirname(dropPath));
            node_core_library_1.JsonFile.save(this._devDeployMetadata, dropPath);
            completeCallback();
            return {};
        }).catch((error) => {
            completeCallback(error.message);
            return {};
        });
    }
    getDebugManifestUrl() {
        return url_1.joinUrlSegments(this.getDeployUrl(), MANIFESTS_AZURE_FILENAME);
    }
    getDeployUrl() {
        return url_1.joinUrlSegments(this._getContainerUrl(), this._getStorageDirName());
    }
    getExistingDeployMetadata() {
        if (this._devDeployMetadata) {
            return this._devDeployMetadata;
        }
        else {
            const dropPath = this._getMetadataDropPath();
            if (fsx.existsSync(dropPath)) {
                return node_core_library_1.JsonFile.load(dropPath);
            }
            else {
                return undefined;
            }
        }
    }
    _getMetadataDropPath() {
        const METADATA_FILENAME = 'dev-deploy-metadata.json';
        const rushConfig = this._getRushConfig();
        if (rushConfig) {
            const commonTempDirectory = rushConfig.commonTempFolder;
            return path.join(commonTempDirectory, METADATA_FILENAME);
        }
        else {
            return path.join(this.buildConfig.rootPath, this.buildConfig.tempFolder, METADATA_FILENAME);
        }
    }
    _getContainerUrl() {
        return deployToAzure_1.getAzureStorageUrl(this.taskConfig.account, this.taskConfig.container);
    }
    _getStorageDirName() {
        return this.taskConfig.containerDirectoryName || '';
    }
    _getRushConfig() {
        if (!this._rushConfig) {
            this._rushConfig = rush_lib_1.RushConfiguration.loadFromDefaultLocation();
        }
        return this._rushConfig;
    }
    _disambiguatePath(pathToDisambiguate) {
        return typeof pathToDisambiguate === 'string'
            ? pathToDisambiguate
            : pathToDisambiguate.default;
    }
    _getFilesInDirectory(dirName) {
        return new Promise((resolve, reject) => {
            glob(path.join('**', '*.*'), { cwd: dirName }, (error, files) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(files || []);
                }
            });
        });
    }
    /**
     * This function returns a directory name to be used in a directory on Azure storage, ensuring that the name does
     *  not collide with another directory's name. It also ensures that if the specified filesystem path has already
     *  been mapped to an Azure directory, the same name is used on Azure.
     */
    _getAzureDirName(directoryMap, filesystemPath) {
        let azureDirName = path.basename(filesystemPath).toLowerCase();
        if (directoryMap.has(azureDirName)) {
            const existingPaths = directoryMap.get(azureDirName);
            const currentPathId = existingPaths.indexOf(filesystemPath);
            if (currentPathId === -1) {
                azureDirName = `${azureDirName}_${existingPaths.length}`;
                existingPaths.push(filesystemPath);
            }
            else if (currentPathId > 0) {
                azureDirName = `${azureDirName}_${currentPathId}`;
            }
        }
        else {
            directoryMap.set(azureDirName, [filesystemPath]);
        }
        return azureDirName;
    }
    _getManifests(cumulativeManifestProcessor) {
        if (this.taskConfig.useRush) {
            const rushConfig = this._getRushConfig();
            if (!rushConfig) {
                throw 'Unable to find the rush configuration file.';
            }
            let manifests;
            const directories = rushConfig.projects.map((proj) => proj.projectFolder);
            manifests = cumulativeManifestProcessor.discoverManifests(directories[0], cumulativeManifestProcessor_1.ForceSearch.deepSparse);
            for (let i = 1; i < directories.length; i++) {
                const projectManifests = cumulativeManifestProcessor.discoverManifests(directories[i], cumulativeManifestProcessor_1.ForceSearch.deepSparse);
                manifests = this._mergeReferencedProjectLists(manifests, projectManifests);
            }
            return manifests;
        }
        else {
            return cumulativeManifestProcessor.discoverManifests(this.buildConfig.rootPath, cumulativeManifestProcessor_1.ForceSearch.deepSparse);
        }
    }
    _mergeReferencedProjectLists(list1, list2) {
        const ids = new Set();
        Object.keys(list1).concat(Object.keys(list2)).forEach((id) => ids.add(id));
        const result = {};
        ids.forEach((id) => {
            const list1Versions = list1[id];
            const list2Versions = list2[id];
            if (!list1Versions || !list2Versions) {
                // Element is only present in one list
                result[id] = list1Versions || list2Versions;
            }
            else {
                // Arrays are present in both lists, merge them together
                const versionMapping = {};
                function addVersionsToMapping(referencedVersions) {
                    for (const version in referencedVersions) {
                        if (!versionMapping[version] ||
                            referencedVersions[version].manifestCreationTime > versionMapping[version].manifestCreationTime) {
                            versionMapping[version] = referencedVersions[version];
                        }
                    }
                }
                addVersionsToMapping(list1Versions);
                addVersionsToMapping(list2Versions);
                result[id] = versionMapping;
            }
        });
        return result;
    }
    _doComponentTypeSpecificFixup(manifest, processPath) {
        switch (manifest.componentType) {
            case 'WebPart':
                // tslint:disable-next-line:no-any
                const webpartManifest = manifest;
                for (const preconfiguredEntry of webpartManifest.preconfiguredEntries) {
                    if (preconfiguredEntry.iconImageUrl) {
                        preconfiguredEntry.iconImageUrl = this._fixupIconPath(preconfiguredEntry.iconImageUrl, processPath);
                    }
                }
                break;
            case 'Extension':
                const extensionManifest = manifest;
                switch (extensionManifest.extensionType) {
                    case 'ListViewCommandSet':
                        const commandSetManifest = extensionManifest;
                        for (const itemId in commandSetManifest.items) {
                            if (commandSetManifest.items.hasOwnProperty(itemId)) {
                                const item = commandSetManifest.items[itemId];
                                if (item.iconImageUrl) {
                                    item.iconImageUrl = this._fixupIconPath(item.iconImageUrl, processPath);
                                }
                            }
                        }
                        break;
                    default:
                        // Nothing to do for the other extension types
                        break;
                }
                break;
            default:
                // Nothing to do for the other component types
                break;
        }
    }
    _fixupIconPath(iconPath, processPath) {
        if (WriteManifestsTask_1.getIconPathType(iconPath) === WriteManifestsTask_1.IconPathType.RelativeUrl) {
            const relativeIconPath = lodash.trimStart(iconPath, '/');
            return processPath(relativeIconPath);
        }
        else {
            return iconPath;
        }
    }
    _doesFilenameAppearToContainHash(filePath) {
        const filename = path.basename(filePath, path.extname(filePath));
        // Look for a hexadecimal string at the end of the filename that is at least 5 characters long and
        // starts with an underscore (_) or a hyphen (-).
        return !!filename.match(/[_-][a-f0-9]{5,}$/i);
    }
}
exports.DevDeployTask = DevDeployTask;
//# sourceMappingURL=DevDeployTask.js.map