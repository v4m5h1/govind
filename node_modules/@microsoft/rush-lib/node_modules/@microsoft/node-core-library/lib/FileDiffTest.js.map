{"version":3,"file":"FileDiffTest.js","sourceRoot":"","sources":["../src/FileDiffTest.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;AAE3D,6BAA6B;AAE7B,2DAAwD;AACxD,iCAA8B;AAC9B,6CAA0C;AAG1C;;;;;;GAMG;AACH,MAAa,YAAY;IAGvB;;;;OAIG;IACI,MAAM,CAAC,UAAU;QACtB,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE,CAAC;IACvC,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,aAAa,CAAC,eAAuB,EAAE,UAAkB;QACrE,MAAM,qBAAqB,GACvB,IAAI,CAAC,kBAAkB,CAAC,sBAAsB,CAAC,eAAe,CAAC,CAAC;QAEpE,IAAI,qBAAqB,KAAK,SAAS,EAAE;YACvC,MAAM,IAAI,KAAK,CAAC,wDAAwD,GAAG,eAAe,CAAC,CAAC;SAC7F;QAED,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YACvC,MAAM,IAAI,KAAK,CAAC,4BAA4B,GAAG,UAAU,CAAC,CAAC;SAC5D;QAED,MAAM,YAAY,GAAW,IAAI,CAAC,IAAI,CAAC,qBAAqB,EAAE,MAAM,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC;QAChG,uBAAU,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;QAEtC,uBAAU,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;QAE3C,OAAO,YAAY,CAAC;IACtB,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,WAAW,CAAC,cAAsB,EAAE,gBAAwB;QACxE,MAAM,aAAa,GAAW,uBAAU,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;QAClE,MAAM,eAAe,GAAW,uBAAU,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC;QAEtE,wCAAwC;QACxC,MAAM,gBAAgB,GAAW,YAAY,CAAC,qBAAqB,CAAC,aAAa,CAAC,CAAC;QACnF,MAAM,kBAAkB,GAAW,YAAY,CAAC,qBAAqB,CAAC,eAAe,CAAC,CAAC;QAEvF,IAAI,gBAAgB,KAAK,kBAAkB,EAAE;YAC3C,wFAAwF;YACxF,MAAM,oBAAoB,GAAW,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC,CAAC;YAC9G,IAAI,uBAAU,CAAC,MAAM,CAAC,oBAAoB,CAAC,EAAE;gBAC3C,MAAM,IAAI,KAAK,CAAC,2EAA2E;sBACvF,6BAA6B,GAAG,oBAAoB,CAAC,CAAC;aAC3D;YACD,uBAAU,CAAC,QAAQ,CAAC;gBAClB,UAAU,EAAE,gBAAgB;gBAC5B,eAAe,EAAE,oBAAoB;aACtC,CAAC,CAAC;YAEH,gFAAgF;YAChF,uBAAU,CAAC,mBAAmB,CAAC,oBAAoB,oBAAwB,CAAC;YAE5E,MAAM,IAAI,KAAK,CAAC,2DAA2D;kBACvE,cAAc,CAAC,CAAC;SACrB;IACH,CAAC;IAEO,MAAM,CAAC,qBAAqB,CAAC,CAAS;QAC5C,OAAO,WAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,iCAAiC;aACzD,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,gCAAgC;aACxD,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAE,kCAAkC;IAC9D,CAAC;;AA9Ec,+BAAkB,GAAsB,IAAI,qCAAiB,EAAE,CAAC;AADjF,oCAgFC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\n\r\nimport { PackageJsonLookup } from './PackageJsonLookup';\r\nimport { Text } from './Text';\r\nimport { FileSystem } from './FileSystem';\r\nimport { PosixModeBits } from './PosixModeBits';\r\n\r\n/**\r\n * Implements a unit testing strategy that generates output files, and then\r\n * compares them against the expected input.  If the files are different, then\r\n * the test fails.\r\n *\r\n * @public\r\n */\r\nexport class FileDiffTest {\r\n  private static _packageJsonLookup: PackageJsonLookup = new PackageJsonLookup();\r\n\r\n  /**\r\n   * Clears the internal file cache.\r\n   * @remarks\r\n   * Call this method if changes have been made to the package.json files on disk.\r\n   */\r\n  public static clearCache(): void {\r\n    this._packageJsonLookup.clearCache();\r\n  }\r\n\r\n  /**\r\n   * Sets up a folder in the temp directory where the unit test should write its output files\r\n   * to be diffed.  Any previous contents of the folder will be deleted.\r\n   *\r\n   * @param unitTestDirName - the \"__dirname\" variable, evaluated in the context of the unit test\r\n   * @param testModule - the name of the class being unit tested; must contain only letters, numbers, and underscores.\r\n   * @returns A fully qualified path of the folder where the unit test should write its output\r\n   */\r\n  public static prepareFolder(unitTestDirName: string, testModule: string): string {\r\n    const packageJsonFolderPath: string | undefined\r\n      = this._packageJsonLookup.tryGetPackageFolderFor(unitTestDirName);\r\n\r\n    if (packageJsonFolderPath === undefined) {\r\n      throw new Error('Unable to find a package.json in any parent folder of ' + unitTestDirName);\r\n    }\r\n\r\n    if (!/^[a-zA-Z0-9_]+$/.test(testModule)) {\r\n      throw new Error('Invalid test module name: ' + testModule);\r\n    }\r\n\r\n    const diffTestPath: string = path.join(packageJsonFolderPath, 'temp', 'diff-tests', testModule);\r\n    FileSystem.ensureFolder(diffTestPath);\r\n\r\n    FileSystem.ensureEmptyFolder(diffTestPath);\r\n\r\n    return diffTestPath;\r\n  }\r\n\r\n  /**\r\n   * Compares the contents of two files, and returns true if they are equivalent.\r\n   * Note that these files are not normally edited by a human; the \"equivalence\"\r\n   * comparison here is intended to ignore spurious changes that might be introduced\r\n   * by a tool, e.g. Git newline normalization or an editor that strips\r\n   * whitespace when saving.\r\n   */\r\n  public static assertEqual(actualFilePath: string, expectedFilePath: string): void {\r\n    const actualContent: string = FileSystem.readFile(actualFilePath);\r\n    const expectedContent: string = FileSystem.readFile(expectedFilePath);\r\n\r\n    // NOTE: \"\\s\" also matches \"\\r\" and \"\\n\"\r\n    const normalizedActual: string = FileDiffTest._getNormalizedContent(actualContent);\r\n    const normalizedExpected: string = FileDiffTest._getNormalizedContent(expectedContent);\r\n\r\n    if (normalizedActual !== normalizedExpected) {\r\n      // Copy the expected file into the same folder as the actual file for easier comparisons\r\n      const expectedCopyFilename: string = path.join(path.dirname(actualFilePath), path.basename(expectedFilePath));\r\n      if (FileSystem.exists(expectedCopyFilename)) {\r\n        throw new Error('The FileDiffTest failed, but the expected output cannot be copied because'\r\n          + ' the file already exists:\\n' + expectedCopyFilename);\r\n      }\r\n      FileSystem.copyFile({\r\n        sourcePath: expectedFilePath,\r\n        destinationPath: expectedCopyFilename\r\n      });\r\n\r\n      // Set to read-only so that developer doesn't accidentally modify the wrong file\r\n      FileSystem.changePosixModeBits(expectedCopyFilename, PosixModeBits.AllRead);\r\n\r\n      throw new Error('The test output file does not match the expected input:\\n'\r\n        + actualFilePath);\r\n    }\r\n  }\r\n\r\n  private static _getNormalizedContent(s: string): string {\r\n    return Text.convertToLf(s) // convert to Unix-style newlines\r\n      .replace(/\\s+\\n/g, '\\n') // strip spaces from end of line\r\n      .replace(/\\n+$/g, '');  // strip newlines from end of file\r\n  }\r\n}\r\n"]}