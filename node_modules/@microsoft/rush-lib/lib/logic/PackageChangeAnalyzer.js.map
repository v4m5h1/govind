{"version":3,"file":"PackageChangeAnalyzer.js","sourceRoot":"","sources":["../../src/logic/PackageChangeAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as colors from 'colors';\r\n\r\nimport {\r\n  getPackageDeps,\r\n  IPackageDeps\r\n} from '@microsoft/package-deps-hash';\r\nimport { Path } from '@microsoft/node-core-library';\r\n\r\nimport { RushConstants } from '../logic/RushConstants';\r\nimport { RushConfiguration } from '../api/RushConfiguration';\r\nimport { Git } from './Git';\r\n\r\nexport class PackageChangeAnalyzer {\r\n  // Allow this function to be overwritten during unit tests\r\n  public static getPackageDeps: (path: string, ignoredFiles: string[]) => IPackageDeps;\r\n\r\n  private _data: Map<string, IPackageDeps>;\r\n  private _rushConfiguration: RushConfiguration;\r\n  private _isGitSupported: boolean;\r\n\r\n  public constructor(rushConfiguration: RushConfiguration) {\r\n    this._rushConfiguration = rushConfiguration;\r\n    this._isGitSupported = Git.isPathUnderGitWorkingTree();\r\n    this._data = this._getData();\r\n  }\r\n\r\n  public getPackageDepsHash(projectName: string): IPackageDeps | undefined {\r\n    if (!this._data) {\r\n      this._data = this._getData();\r\n    }\r\n\r\n    return this._data.get(projectName);\r\n  }\r\n\r\n  private _getData(): Map<string, IPackageDeps> {\r\n    // If we are not in a unit test, use the correct resources\r\n    if (!PackageChangeAnalyzer.getPackageDeps) {\r\n      PackageChangeAnalyzer.getPackageDeps = getPackageDeps;\r\n    }\r\n\r\n    const projectHashDeps: Map<string, IPackageDeps> = new Map<string, IPackageDeps>();\r\n\r\n    // pre-populate the map with the projects from the config\r\n    for (const project of this._rushConfiguration.projects) {\r\n      projectHashDeps.set(project.packageName, {\r\n        files: {}\r\n      });\r\n    }\r\n\r\n    const noProjectHashes: { [key: string]: string } = {};\r\n\r\n    let repoDeps: IPackageDeps;\r\n    try {\r\n      if (this._isGitSupported) {\r\n        // Load the package deps hash for the whole repository\r\n        repoDeps = PackageChangeAnalyzer.getPackageDeps(\r\n          this._rushConfiguration.rushJsonFolder,\r\n          [RushConstants.packageDepsFilename]\r\n        );\r\n      } else {\r\n        return projectHashDeps;\r\n      }\r\n    } catch (e) {\r\n      // If getPackageDeps fails, don't fail the whole build. Treat this case as if we don't know anything about\r\n      // the state of the files in the repo. This can happen if the environment doesn't have Git.\r\n      console.log(colors.yellow(\r\n        `Error calculating the state of the repo. (inner error: ${e}). Continuing without diffing files.`\r\n      ));\r\n\r\n      return projectHashDeps;\r\n    }\r\n\r\n    // Sort each project folder into its own package deps hash\r\n    Object.keys(repoDeps.files).forEach((filePath: string) => {\r\n      const fileHash: string = repoDeps.files[filePath];\r\n\r\n      const projectName: string | undefined = this._getProjectForFile(filePath);\r\n\r\n      // If we found a project for the file, go ahead and store this file's hash\r\n      if (projectName) {\r\n        projectHashDeps.get(projectName)!.files[filePath] = fileHash;\r\n      } else {\r\n        noProjectHashes[filePath] = fileHash;\r\n      }\r\n    });\r\n\r\n    /* Incremental Build notes:\r\n     *\r\n     * Temporarily revert below code in favor of replacing this solution with something more\r\n     * flexible. Idea is essentially that we should have gulp-core-build (or other build tool)\r\n     * create the package-deps.json. The build tool would default to using the 'simple'\r\n     * algorithm (e.g. only files that are in a project folder are associated with the project), however it would\r\n     * also provide a hook which would allow certain tasks to modify the package-deps-hash before being written.\r\n     * At the end of the build, a we would create a package-deps.json file like so:\r\n     *\r\n     *  {\r\n     *    commandLine: [\"--production\"],\r\n     *    files: {\r\n     *      \"src/index.ts\": \"478789a7fs8a78989afd8\",\r\n     *      \"src/fileOne.ts\": \"a8sfa8979871fdjiojlk\",\r\n     *      \"common/api/review\": \"324598afasfdsd\",     // this entry was added by the API Extractor task (for example)\r\n     *      \"node_modules.json\": \"3428789dsafdsfaf\"    // this is a file which will be created by rush link describing\r\n     *                                                 //   the state of the node_modules folder\r\n     *    }\r\n     *  }\r\n     *\r\n     * Verifying this file should be fairly straightforward, we would simply need to check if:\r\n     *   A) no files were added or deleted from the current folder\r\n     *   B) all file hashes match\r\n     *   C) the node_modules hash/contents match\r\n     *   D) the command line parameters match or are compatible\r\n     *\r\n     *   Notes:\r\n     *   * We need to store the command line arguments, which is currently done by rush instead of GCB\r\n     *   * We need to store the hash/text of the a file which describes the state of the node_modules folder\r\n     *   * The package-deps.json should be a complete list of dependencies, and it should be extremely cheap\r\n     *       to validate/check the file (even if creating it is more computationally costly).\r\n     */\r\n\r\n    // Add the \"NO_PROJECT\" files to every project's dependencies\r\n    // for (const project of PackageChangeAnalyzer.rushConfig.projects) {\r\n    //  Object.keys(noProjectHashes).forEach((filePath: string) => {\r\n    //    const fileHash: string = noProjectHashes[filePath];\r\n    //    projectHashDeps.get(project.packageName).files[filePath] = fileHash;\r\n    //  });\r\n    // }\r\n\r\n    // Determine the current variant from the link JSON.\r\n    const variant: string | undefined = this._rushConfiguration.currentInstalledVariant;\r\n\r\n    // Add the shrinkwrap file to every project's dependencies\r\n\r\n    const shrinkwrapFile: string =\r\n      path.relative(this._rushConfiguration.rushJsonFolder,\r\n        this._rushConfiguration.getCommittedShrinkwrapFilename(variant))\r\n        .replace(/\\\\/g, '/');\r\n\r\n    for (const project of this._rushConfiguration.projects) {\r\n      const shrinkwrapHash: string | undefined = noProjectHashes[shrinkwrapFile];\r\n      if (shrinkwrapHash) {\r\n        projectHashDeps.get(project.packageName)!.files[shrinkwrapFile] = shrinkwrapHash;\r\n      }\r\n    }\r\n\r\n    return projectHashDeps;\r\n  }\r\n\r\n  private _getProjectForFile(filePath: string): string | undefined {\r\n    for (const project of this._rushConfiguration.projects) {\r\n      if (this._fileExistsInFolder(filePath, project.projectRelativeFolder)) {\r\n        return project.packageName;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  private _fileExistsInFolder(filePath: string, folderPath: string): boolean {\r\n    return Path.isUnder(filePath, folderPath);\r\n  }\r\n}\r\n"]}