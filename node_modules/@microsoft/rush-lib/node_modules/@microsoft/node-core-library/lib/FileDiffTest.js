"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const PackageJsonLookup_1 = require("./PackageJsonLookup");
const Text_1 = require("./Text");
const FileSystem_1 = require("./FileSystem");
/**
 * Implements a unit testing strategy that generates output files, and then
 * compares them against the expected input.  If the files are different, then
 * the test fails.
 *
 * @public
 */
class FileDiffTest {
    /**
     * Clears the internal file cache.
     * @remarks
     * Call this method if changes have been made to the package.json files on disk.
     */
    static clearCache() {
        this._packageJsonLookup.clearCache();
    }
    /**
     * Sets up a folder in the temp directory where the unit test should write its output files
     * to be diffed.  Any previous contents of the folder will be deleted.
     *
     * @param unitTestDirName - the "__dirname" variable, evaluated in the context of the unit test
     * @param testModule - the name of the class being unit tested; must contain only letters, numbers, and underscores.
     * @returns A fully qualified path of the folder where the unit test should write its output
     */
    static prepareFolder(unitTestDirName, testModule) {
        const packageJsonFolderPath = this._packageJsonLookup.tryGetPackageFolderFor(unitTestDirName);
        if (packageJsonFolderPath === undefined) {
            throw new Error('Unable to find a package.json in any parent folder of ' + unitTestDirName);
        }
        if (!/^[a-zA-Z0-9_]+$/.test(testModule)) {
            throw new Error('Invalid test module name: ' + testModule);
        }
        const diffTestPath = path.join(packageJsonFolderPath, 'temp', 'diff-tests', testModule);
        FileSystem_1.FileSystem.ensureFolder(diffTestPath);
        FileSystem_1.FileSystem.ensureEmptyFolder(diffTestPath);
        return diffTestPath;
    }
    /**
     * Compares the contents of two files, and returns true if they are equivalent.
     * Note that these files are not normally edited by a human; the "equivalence"
     * comparison here is intended to ignore spurious changes that might be introduced
     * by a tool, e.g. Git newline normalization or an editor that strips
     * whitespace when saving.
     */
    static assertEqual(actualFilePath, expectedFilePath) {
        const actualContent = FileSystem_1.FileSystem.readFile(actualFilePath);
        const expectedContent = FileSystem_1.FileSystem.readFile(expectedFilePath);
        // NOTE: "\s" also matches "\r" and "\n"
        const normalizedActual = FileDiffTest._getNormalizedContent(actualContent);
        const normalizedExpected = FileDiffTest._getNormalizedContent(expectedContent);
        if (normalizedActual !== normalizedExpected) {
            // Copy the expected file into the same folder as the actual file for easier comparisons
            const expectedCopyFilename = path.join(path.dirname(actualFilePath), path.basename(expectedFilePath));
            if (FileSystem_1.FileSystem.exists(expectedCopyFilename)) {
                throw new Error('The FileDiffTest failed, but the expected output cannot be copied because'
                    + ' the file already exists:\n' + expectedCopyFilename);
            }
            FileSystem_1.FileSystem.copyFile({
                sourcePath: expectedFilePath,
                destinationPath: expectedCopyFilename
            });
            // Set to read-only so that developer doesn't accidentally modify the wrong file
            FileSystem_1.FileSystem.changePosixModeBits(expectedCopyFilename, 292 /* AllRead */);
            throw new Error('The test output file does not match the expected input:\n'
                + actualFilePath);
        }
    }
    static _getNormalizedContent(s) {
        return Text_1.Text.convertToLf(s) // convert to Unix-style newlines
            .replace(/\s+\n/g, '\n') // strip spaces from end of line
            .replace(/\n+$/g, ''); // strip newlines from end of file
    }
}
FileDiffTest._packageJsonLookup = new PackageJsonLookup_1.PackageJsonLookup();
exports.FileDiffTest = FileDiffTest;
//# sourceMappingURL=FileDiffTest.js.map