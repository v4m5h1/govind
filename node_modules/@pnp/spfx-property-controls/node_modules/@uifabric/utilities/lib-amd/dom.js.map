{"version":3,"file":"dom.js","sourceRoot":"../src/","sources":["dom.ts"],"names":[],"mappings":";;;IAaA;;;;;OAKG;IACH,0BAAiC,KAAkB,EAAE,MAAmB;QACtE,IAAI,YAAY,GAAoB,KAAK,CAAC;QAC1C,IAAI,aAAa,GAAoB,MAAM,CAAC;QAE5C,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE;YAC1B,YAAY,CAAC,QAAQ,GAAG;gBACtB,QAAQ,EAAE,EAAE;aACb,CAAC;SACH;QAED,IAAI,SAAS,GAAG,YAAY,CAAC,QAAQ,CAAC,MAAM,CAAC;QAE7C,IAAI,SAAS,IAAI,SAAS,KAAK,MAAM,EAAE;YACrC,wCAAwC;YACxC,IAAI,KAAK,GAAG,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;YAE9D,IAAI,KAAK,GAAG,CAAC,CAAC,EAAE;gBACd,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;aAC9C;SACF;QAED,YAAY,CAAC,QAAQ,CAAC,MAAM,GAAG,aAAa,IAAI,SAAS,CAAC;QAE1D,IAAI,aAAa,EAAE;YACjB,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE;gBAC3B,aAAa,CAAC,QAAQ,GAAG;oBACvB,QAAQ,EAAE,EAAE;iBACb,CAAC;aACH;YAED,aAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;SACpD;IACH,CAAC;IAhCD,4CAgCC;IAED;;;;OAIG;IACH,0BAAiC,KAAkB;QACjD,IAAI,MAA+B,CAAC;QAEpC,IAAI,KAAK,IAAI,gBAAgB,CAAC,KAAK,CAAC,EAAE;YACpC,MAAM,GAAG,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC;SAChC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IARD,4CAQC;IAED;;;;;;OAMG;IACH,mBAA0B,KAAkB,EAAE,mBAAmC;QAAnC,oCAAA,EAAA,0BAAmC;QAC/E,OAAO,KAAK,IAAI,CACd,mBAAmB,IAAI,gBAAgB,CAAC,KAAK,CAAC;YAC9C,KAAK,CAAC,UAAU,IAAI,KAAK,CAAC,UAAyB,CACpD,CAAC;IACJ,CAAC;IALD,8BAKC;IAED;;;;;;OAMG;IACH,qBAA4B,MAAmB,EAAE,oBAAoC;QAApC,qCAAA,EAAA,2BAAoC;QACnF,IAAM,QAAQ,GAAkB,EAAE,CAAC;QAEnC,IAAI,MAAM,EAAE;YACV,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC/C,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAgB,CAAC,CAAC;aACvD;YAED,IAAI,oBAAoB,IAAI,gBAAgB,CAAC,MAAM,CAAC,EAAE;gBACpD,QAAQ,CAAC,IAAI,OAAb,QAAQ,EAAS,MAAM,CAAC,QAAQ,CAAC,QAAQ,EAAE;aAC5C;SACF;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;IAdD,kCAcC;IAED;;;;;;OAMG;IACH,yBAAgC,MAA0B,EAAE,KAAyB,EAAE,mBAAmC;QAAnC,oCAAA,EAAA,0BAAmC;QACxH,IAAI,WAAW,GAAG,KAAK,CAAC;QAExB,IAAI,MAAM,IAAI,KAAK,EAAE;YACnB,IAAI,mBAAmB,EAAE;gBACvB,WAAW,GAAG,KAAK,CAAC;gBAEpB,OAAO,KAAK,EAAE;oBACZ,IAAI,UAAU,GAAuB,SAAS,CAAC,KAAK,CAAC,CAAC;oBAEtD,IAAI,UAAU,KAAK,MAAM,EAAE;wBACzB,WAAW,GAAG,IAAI,CAAC;wBACnB,MAAM;qBACP;oBAED,KAAK,GAAG,UAAU,CAAC;iBACpB;aACF;iBAAM,IAAI,MAAM,CAAC,QAAQ,EAAE;gBAC1B,WAAW,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;aACtC;SACF;QAED,OAAO,WAAW,CAAC;IACrB,CAAC;IAvBD,0CAuBC;IAED,IAAI,MAAM,GAAG,KAAK,CAAC;IAEnB;;;;OAIG;IACH,gBAAuB,SAAkB;QACvC,MAAM,GAAG,SAAS,CAAC;IACrB,CAAC;IAFD,wBAEC;IAED;;;;OAIG;IACH,mBAA0B,WAA4B;QACpD,IAAI,MAAM,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE;YAC3C,OAAO,SAAS,CAAC;SAClB;aAAM;YACL,OAAO,CACL,WAAW;gBACT,WAAW,CAAC,aAAa;gBACzB,WAAW,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;gBACvC,WAAW,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;gBACvC,MAAM,CACT,CAAC;SACH;IACH,CAAC;IAZD,8BAYC;IAED;;;;OAIG;IACH,qBAA4B,WAAgC;QAC1D,IAAI,MAAM,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE;YAC7C,OAAO,SAAS,CAAC;SAClB;aAAM;YACL,OAAO,WAAW,IAAI,WAAW,CAAC,aAAa,CAAC,CAAC,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC,CAAC,QAAQ,CAAC;SACxF;IACH,CAAC;IAND,kCAMC;IAED;;;;OAIG;IACH,iBAAwB,OAAoC;QAC1D,IAAI,IAA4B,CAAC;QAEjC,IAAI,OAAO,EAAE;YACX,IAAI,OAAO,KAAK,MAAM,EAAE;gBACtB,IAAI,GAAG;oBACL,IAAI,EAAE,CAAC;oBACP,GAAG,EAAE,CAAC;oBACN,KAAK,EAAE,MAAM,CAAC,UAAU;oBACxB,MAAM,EAAE,MAAM,CAAC,WAAW;oBAC1B,KAAK,EAAE,MAAM,CAAC,UAAU;oBACxB,MAAM,EAAE,MAAM,CAAC,WAAW;iBAC3B,CAAC;aACH;iBAAM,IAAK,OAAuB,CAAC,qBAAqB,EAAE;gBACzD,IAAI,GAAI,OAAuB,CAAC,qBAAqB,EAAE,CAAC;aACzD;SACF;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAnBD,0BAmBC;IAED;;;;;OAKG;IACH,8BAAqC,OAA2B,EAAE,aAAgD;QAChH,IAAI,CAAC,OAAO,IAAI,OAAO,KAAK,QAAQ,CAAC,IAAI,EAAE;YACzC,OAAO,IAAI,CAAC;SACb;QAED,OAAO,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,oBAAoB,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,aAAa,CAAC,CAAC;IACpG,CAAC;IAND,oDAMC;IAED;;;;;OAKG;IACH,kCAAyC,OAAoB,EAAE,SAAiB;QAC9E,IAAI,YAAY,GAAG,oBAAoB,CAAC,OAAO,EAAE,UAAC,WAAwB,IAAK,OAAA,WAAW,CAAC,YAAY,CAAC,SAAS,CAAC,EAAnC,CAAmC,CAAC,CAAC;QACpH,OAAO,YAAY,IAAI,YAAY,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;IAC9D,CAAC;IAHD,4DAGC;IAED;;;;OAIG;IACH,0BAA0B,OAAsC;QAC9D,OAAO,OAAO,IAAI,CAAC,CAAmB,OAAQ,CAAC,QAAQ,CAAC;IAC1D,CAAC","sourcesContent":["import { IRectangle } from './IRectangle';\r\n\r\n/**\r\n * Attached interface for elements which support virtual references.\r\n * Used internally by the virtual hierarchy methods.\r\n */\r\ninterface IVirtualElement extends HTMLElement {\r\n  _virtual: {\r\n    parent?: IVirtualElement;\r\n    children: IVirtualElement[];\r\n  };\r\n}\r\n\r\n/**\r\n * Sets the virtual parent of an element.\r\n * Pass `undefined` as the `parent` to clear the virtual parent.\r\n *\r\n * @public\r\n */\r\nexport function setVirtualParent(child: HTMLElement, parent: HTMLElement): void {\r\n  let virtualChild = <IVirtualElement>child;\r\n  let virtualParent = <IVirtualElement>parent;\r\n\r\n  if (!virtualChild._virtual) {\r\n    virtualChild._virtual = {\r\n      children: []\r\n    };\r\n  }\r\n\r\n  let oldParent = virtualChild._virtual.parent;\r\n\r\n  if (oldParent && oldParent !== parent) {\r\n    // Remove the child from its old parent.\r\n    let index = oldParent._virtual.children.indexOf(virtualChild);\r\n\r\n    if (index > -1) {\r\n      oldParent._virtual.children.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  virtualChild._virtual.parent = virtualParent || undefined;\r\n\r\n  if (virtualParent) {\r\n    if (!virtualParent._virtual) {\r\n      virtualParent._virtual = {\r\n        children: []\r\n      };\r\n    }\r\n\r\n    virtualParent._virtual.children.push(virtualChild);\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the virtual parent given the child element, if it exists.\r\n *\r\n * @public\r\n */\r\nexport function getVirtualParent(child: HTMLElement): HTMLElement | undefined {\r\n  let parent: HTMLElement | undefined;\r\n\r\n  if (child && isVirtualElement(child)) {\r\n    parent = child._virtual.parent;\r\n  }\r\n\r\n  return parent;\r\n}\r\n\r\n/**\r\n * Gets the element which is the parent of a given element.\r\n * If `allowVirtuaParents` is `true`, this method prefers the virtual parent over\r\n * real DOM parent when present.\r\n *\r\n * @public\r\n */\r\nexport function getParent(child: HTMLElement, allowVirtualParents: boolean = true): HTMLElement | null {\r\n  return child && (\r\n    allowVirtualParents && getVirtualParent(child) ||\r\n    child.parentNode && child.parentNode as HTMLElement\r\n  );\r\n}\r\n\r\n/**\r\n * Gets the elements which are child elements of the given element.\r\n * If `allowVirtualChildren` is `true`, this method enumerates virtual child elements\r\n * after the original children.\r\n * @param parent\r\n * @param allowVirtualChildren\r\n */\r\nexport function getChildren(parent: HTMLElement, allowVirtualChildren: boolean = true): HTMLElement[] {\r\n  const children: HTMLElement[] = [];\r\n\r\n  if (parent) {\r\n    for (let i = 0; i < parent.children.length; i++) {\r\n      children.push(parent.children.item(i) as HTMLElement);\r\n    }\r\n\r\n    if (allowVirtualChildren && isVirtualElement(parent)) {\r\n      children.push(...parent._virtual.children);\r\n    }\r\n  }\r\n\r\n  return children;\r\n}\r\n\r\n/**\r\n * Determines whether or not a parent element contains a given child element.\r\n * If `allowVirtualParents` is true, this method may return `true` if the child\r\n * has the parent in its virtual element hierarchy.\r\n *\r\n * @public\r\n */\r\nexport function elementContains(parent: HTMLElement | null, child: HTMLElement | null, allowVirtualParents: boolean = true): boolean {\r\n  let isContained = false;\r\n\r\n  if (parent && child) {\r\n    if (allowVirtualParents) {\r\n      isContained = false;\r\n\r\n      while (child) {\r\n        let nextParent: HTMLElement | null = getParent(child);\r\n\r\n        if (nextParent === parent) {\r\n          isContained = true;\r\n          break;\r\n        }\r\n\r\n        child = nextParent;\r\n      }\r\n    } else if (parent.contains) {\r\n      isContained = parent.contains(child);\r\n    }\r\n  }\r\n\r\n  return isContained;\r\n}\r\n\r\nlet _isSSR = false;\r\n\r\n/**\r\n * Helper to set ssr mode to simulate no window object returned from getWindow helper.\r\n *\r\n * @public\r\n */\r\nexport function setSSR(isEnabled: boolean): void {\r\n  _isSSR = isEnabled;\r\n}\r\n\r\n/**\r\n * Helper to get the window object.\r\n *\r\n * @public\r\n */\r\nexport function getWindow(rootElement?: Element | null): Window | undefined {\r\n  if (_isSSR || typeof window === 'undefined') {\r\n    return undefined;\r\n  } else {\r\n    return (\r\n      rootElement &&\r\n        rootElement.ownerDocument &&\r\n        rootElement.ownerDocument.defaultView ?\r\n        rootElement.ownerDocument.defaultView :\r\n        window\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Helper to get the document object.\r\n *\r\n * @public\r\n */\r\nexport function getDocument(rootElement?: HTMLElement | null): Document | undefined {\r\n  if (_isSSR || typeof document === 'undefined') {\r\n    return undefined;\r\n  } else {\r\n    return rootElement && rootElement.ownerDocument ? rootElement.ownerDocument : document;\r\n  }\r\n}\r\n\r\n/**\r\n * Helper to get bounding client rect, works with window.\r\n *\r\n * @public\r\n */\r\nexport function getRect(element: HTMLElement | Window | null): IRectangle | undefined {\r\n  let rect: IRectangle | undefined;\r\n\r\n  if (element) {\r\n    if (element === window) {\r\n      rect = {\r\n        left: 0,\r\n        top: 0,\r\n        width: window.innerWidth,\r\n        height: window.innerHeight,\r\n        right: window.innerWidth,\r\n        bottom: window.innerHeight\r\n      };\r\n    } else if ((element as HTMLElement).getBoundingClientRect) {\r\n      rect = (element as HTMLElement).getBoundingClientRect();\r\n    }\r\n  }\r\n\r\n  return rect;\r\n}\r\n\r\n/**\r\n * Finds the first parent element where the matchFunction returns true\r\n * @param element element to start searching at\r\n * @param matchFunction the function that determines if the element is a match\r\n * @returns the matched element or null no match was found\r\n */\r\nexport function findElementRecursive(element: HTMLElement | null, matchFunction: (element: HTMLElement) => boolean): HTMLElement | null {\r\n  if (!element || element === document.body) {\r\n    return null;\r\n  }\r\n\r\n  return matchFunction(element) ? element : findElementRecursive(getParent(element), matchFunction);\r\n}\r\n\r\n/**\r\n * Determines if an element, or any of its ancestors, contian the given attribute\r\n * @param element - element to start searching at\r\n * @param attribute - the attribute to search for\r\n * @returns the value of the first instance found\r\n */\r\nexport function elementContainsAttribute(element: HTMLElement, attribute: string): string | null {\r\n  let elementMatch = findElementRecursive(element, (testElement: HTMLElement) => testElement.hasAttribute(attribute));\r\n  return elementMatch && elementMatch.getAttribute(attribute);\r\n}\r\n\r\n/**\r\n * Determines whether or not an element has the virtual hierarchy extension.\r\n *\r\n * @public\r\n */\r\nfunction isVirtualElement(element: HTMLElement | IVirtualElement): element is IVirtualElement {\r\n  return element && !!(<IVirtualElement>element)._virtual;\r\n}\r\n"]}