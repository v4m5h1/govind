{"version":3,"file":"Router.js","sourceRoot":"../src/","sources":["utilities/router/Router.tsx"],"names":[],"mappings":";;;IAmBA;QAA4B,kCAA2C;QAGrE,gBAAY,KAAmB;YAA/B,YACE,kBAAM,KAAK,CAAC,SAMb;YALC,KAAI,CAAC,YAAY,GAAG,EAAE,CAAC;YACvB,kCAAsB,CAAC,KAAI,CAAC,CAAC;YAC7B,KAAI,CAAC,KAAK,GAAG;gBACX,IAAI,EAAE,KAAI,CAAC,QAAQ,EAAE;aACtB,CAAC;;QACJ,CAAC;QAEM,kCAAiB,GAAxB;YAAA,iBAUC;YATC,IAAI,CAAC,YAAY,CAAC,IAAI,CACpB,cAAE,CAAC,MAAM,EAAE,YAAY,EAAE;gBACvB,6EAA6E;gBAC7E,IAAM,IAAI,GAAG,KAAI,CAAC,QAAQ,EAAE,CAAC;gBAC7B,IAAI,IAAI,KAAK,KAAI,CAAC,KAAK,CAAC,IAAI,EAAE;oBAC5B,KAAI,CAAC,QAAQ,CAAC,EAAE,IAAI,MAAA,EAAE,CAAC,CAAC;iBACzB;YACH,CAAC,CAAC,CACH,CAAC;QACJ,CAAC;QAEM,qCAAoB,GAA3B;YACE,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAA,OAAO,IAAI,OAAA,OAAO,EAAE,EAAT,CAAS,CAAC,CAAC;QAClD,CAAC;QAEM,uBAAM,GAAb;YACE,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC;QAC9B,CAAC;QAEO,yBAAQ,GAAhB;YACE,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC;YACzB,IAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,EACrC,iBAAiB,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YAExC,gHAAgH;YAChH,IAAI,iBAAiB,GAAG,CAAC,CAAC,EAAE;gBAC1B,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,iBAAiB,CAAC,CAAC;aAC1C;YAED,6FAA6F;YAC7F,IAAI,SAAS,GAAG,CAAC,EAAE;gBACjB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;aAClC;YAED,OAAO,cAAc,CAAC,IAAI,CAAC,CAAC;QAC9B,CAAC;QAEO,8BAAa,GAArB,UAAsB,QAA0B;YAAhD,iBAsDC;YArDS,IAAA,sBAAI,CAAgB;YAC5B,QAAQ,GAAG,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;YAE3C,4EAA4E;YAC5E,IAAM,MAAM,GAAG,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAsC,CAAC;oCAE1E,KAAK;gBACd,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE;;iBAEjB;gBACD,4FAA4F;gBAC5F,IAAM,SAAS,GAAG,cAAc,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBACnD,IAAI,CAAC,SAAS,IAAI,SAAS,KAAK,IAAI,EAAE;oBAC9B,IAAA,mCAAS,CAAiB;oBAEhC,sFAAsF;oBACtF,IAAM,cAAY,GAAgF,KAAK,CAAC,KAAK,CAAC,YAAa,CAAC;oBAC5H,IAAI,cAAY,EAAE;wBAChB,IAAI,wBAAsB,GAAG,KAAK,CAAC;wBAEnC,IAAI,cAAY,CAAC,SAAS,EAAE;4BAC1B,WAAS,GAAG,cAAY,CAAC,SAAS,CAAC;yBACpC;6BAAM;4BACL,cAAY,CAAC,UAAC,QAA6B;gCACzC,IAAI,CAAC,QAAQ,EAAE;oCACb,MAAM,IAAI,KAAK,CACb,0DAAwD,KAAK,CAAC,KAAK,CAAC,IAAI,MAAG;yCACzE,cAAY,QAAQ,+DAA4D,CAAA;wCAChF,wEAAwE,CAC3E,CAAC;iCACH;gCACD,WAAS,GAAG,cAAY,CAAC,SAAS,GAAG,QAAQ,CAAC;gCAE9C,IAAI,wBAAsB,EAAE;oCAC1B,KAAI,CAAC,WAAW,EAAE,CAAC;iCACpB;4BACH,CAAC,CAAC,CAAC;yBACJ;wBACD,iDAAiD;wBACjD,wBAAsB,GAAG,IAAI,CAAC;qBAC/B;oBAED,IAAI,WAAS,EAAE;wBACb,IAAM,iBAAiB,GAAG,OAAK,aAAa,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,IAAI,EAAE,CAAC,CAAC;wCAClE,KAAK,CAAC,aAAa,CAAC,WAAS,EAAE,EAAE,GAAG,EAAE,KAAK,CAAC,GAAI,EAAE,EAAE,iBAAiB,CAAC;qBAC9E;yBAAM,IAAI,cAAY,EAAE;wCAEhB,IAAI;qBACZ;iBACF;YACH,CAAC;;YA5CD,KAAoB,UAAM,EAAN,iBAAM,EAAN,oBAAM,EAAN,IAAM;gBAArB,IAAM,KAAK,eAAA;sCAAL,KAAK;;;aA4Cf;YAED,OAAO,IAAI,CAAC;QACd,CAAC;QACH,aAAC;IAAD,CAAC,AAzGD,CAA4B,KAAK,CAAC,SAAS,GAyG1C;IAzGY,wBAAM;IA2GnB,uFAAuF;IACvF,wBAAwB,IAAa;QACnC,IAAI,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YAClC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;SAC1B;QACD,OAAO,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;IACpC,CAAC","sourcesContent":["import * as React from 'react';\nimport { initializeComponentRef, on } from '../../Utilities';\nimport { IRouteProps } from './Route';\n\nexport interface IRouterProps {\n  /**\n   * Gets the component ref.\n   */\n  componentRef?: () => void;\n\n  replaceState?: boolean;\n  children?: React.ReactNode;\n  onNewRouteLoaded?: () => void;\n}\n\nexport interface IRouterState {\n  path: string;\n}\n\nexport class Router extends React.Component<IRouterProps, IRouterState> {\n  private _disposables: Function[];\n\n  constructor(props: IRouterProps) {\n    super(props);\n    this._disposables = [];\n    initializeComponentRef(this);\n    this.state = {\n      path: this._getPath()\n    };\n  }\n\n  public componentDidMount(): void {\n    this._disposables.push(\n      on(window, 'hashchange', () => {\n        // Don't update unless the route itself (not an anchor link) actually changed\n        const path = this._getPath();\n        if (path !== this.state.path) {\n          this.setState({ path });\n        }\n      })\n    );\n  }\n\n  public componentWillUnmount(): void {\n    this._disposables.forEach(dispose => dispose());\n  }\n\n  public render() {\n    return this._resolveRoute();\n  }\n\n  private _getPath(): string {\n    let path = location.hash;\n    const hashIndex = path.lastIndexOf('#'),\n      questionMarkIndex = path.indexOf('?');\n\n    // Look for the start of a query in the currentPath, then strip out the query to find the correct page to render\n    if (questionMarkIndex > -1) {\n      path = path.substr(0, questionMarkIndex);\n    }\n\n    // If the hash has a second # (for an anchor), strip that out since it's not used for routing\n    if (hashIndex > 0) {\n      path = path.substr(0, hashIndex);\n    }\n\n    return _normalizePath(path);\n  }\n\n  private _resolveRoute(children?: React.ReactNode): React.ReactElement<any> | null {\n    const { path } = this.state;\n    children = children || this.props.children;\n\n    // The children are supposed to be Route elements, but we verify this below.\n    const routes = React.Children.toArray(children) as React.ReactElement<IRouteProps>[];\n\n    for (const route of routes) {\n      if (!route.props) {\n        continue; // probably some other child type, not a route\n      }\n      // Use this route if it has no path, or if the path matches the current path (from the hash)\n      const routePath = _normalizePath(route.props.path);\n      if (!routePath || routePath === path) {\n        let { component } = route.props;\n\n        // The loaded component is stored as a prop on the loader function...because obviously\n        const getComponent: Required<IRouteProps>['getComponent'] & { component?: React.ComponentType } = route.props.getComponent!;\n        if (getComponent) {\n          let asynchronouslyResolved = false;\n\n          if (getComponent.component) {\n            component = getComponent.component;\n          } else {\n            getComponent((resolved: React.ComponentType) => {\n              if (!resolved) {\n                throw new Error(\n                  `Router: Calling getComponent for the route with path ${route.props.path} ` +\n                    `returned ${resolved}, not a component. Check your getComponent implementation ` +\n                    `(including the name of the module member you're attempting to return).`\n                );\n              }\n              component = getComponent.component = resolved;\n\n              if (asynchronouslyResolved) {\n                this.forceUpdate();\n              }\n            });\n          }\n          // Note: in webpack 2, this ends up always async.\n          asynchronouslyResolved = true;\n        }\n\n        if (component) {\n          const componentChildren = this._resolveRoute(route.props.children || []);\n          return React.createElement(component, { key: route.key! }, componentChildren);\n        } else if (getComponent) {\n          // We are asynchronously fetching this component.\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\n/** Normalize path for comparison: strip any trailing slash and convert to lowercase */\nfunction _normalizePath(path?: string): string {\n  if (path && path.slice(-1) === '/') {\n    path = path.slice(0, -1);\n  }\n  return (path || '').toLowerCase();\n}\n"]}