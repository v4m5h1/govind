{"version":3,"file":"Router.js","sourceRoot":"../src/","sources":["utilities/router/Router.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { initializeComponentRef, on } from '../../Utilities';\nimport { IRouteProps } from './Route';\n\nexport interface IRouterProps {\n  /**\n   * Gets the component ref.\n   */\n  componentRef?: () => void;\n\n  replaceState?: boolean;\n  children?: React.ReactNode;\n  onNewRouteLoaded?: () => void;\n}\n\nexport interface IRouterState {\n  path: string;\n}\n\nexport class Router extends React.Component<IRouterProps, IRouterState> {\n  private _disposables: Function[];\n\n  constructor(props: IRouterProps) {\n    super(props);\n    this._disposables = [];\n    initializeComponentRef(this);\n    this.state = {\n      path: this._getPath()\n    };\n  }\n\n  public componentDidMount(): void {\n    this._disposables.push(\n      on(window, 'hashchange', () => {\n        // Don't update unless the route itself (not an anchor link) actually changed\n        const path = this._getPath();\n        if (path !== this.state.path) {\n          this.setState({ path });\n        }\n      })\n    );\n  }\n\n  public componentWillUnmount(): void {\n    this._disposables.forEach(dispose => dispose());\n  }\n\n  public render() {\n    return this._resolveRoute();\n  }\n\n  private _getPath(): string {\n    let path = location.hash;\n    const hashIndex = path.lastIndexOf('#'),\n      questionMarkIndex = path.indexOf('?');\n\n    // Look for the start of a query in the currentPath, then strip out the query to find the correct page to render\n    if (questionMarkIndex > -1) {\n      path = path.substr(0, questionMarkIndex);\n    }\n\n    // If the hash has a second # (for an anchor), strip that out since it's not used for routing\n    if (hashIndex > 0) {\n      path = path.substr(0, hashIndex);\n    }\n\n    return _normalizePath(path);\n  }\n\n  private _resolveRoute(children?: React.ReactNode): React.ReactElement<any> | null {\n    const { path } = this.state;\n    children = children || this.props.children;\n\n    // The children are supposed to be Route elements, but we verify this below.\n    const routes = React.Children.toArray(children) as React.ReactElement<IRouteProps>[];\n\n    for (const route of routes) {\n      if (!route.props) {\n        continue; // probably some other child type, not a route\n      }\n      // Use this route if it has no path, or if the path matches the current path (from the hash)\n      const routePath = _normalizePath(route.props.path);\n      if (!routePath || routePath === path) {\n        let { component } = route.props;\n\n        // The loaded component is stored as a prop on the loader function...because obviously\n        const getComponent: Required<IRouteProps>['getComponent'] & { component?: React.ComponentType } = route.props.getComponent!;\n        if (getComponent) {\n          let asynchronouslyResolved = false;\n\n          if (getComponent.component) {\n            component = getComponent.component;\n          } else {\n            getComponent((resolved: React.ComponentType) => {\n              if (!resolved) {\n                throw new Error(\n                  `Router: Calling getComponent for the route with path ${route.props.path} ` +\n                    `returned ${resolved}, not a component. Check your getComponent implementation ` +\n                    `(including the name of the module member you're attempting to return).`\n                );\n              }\n              component = getComponent.component = resolved;\n\n              if (asynchronouslyResolved) {\n                this.forceUpdate();\n              }\n            });\n          }\n          // Note: in webpack 2, this ends up always async.\n          asynchronouslyResolved = true;\n        }\n\n        if (component) {\n          const componentChildren = this._resolveRoute(route.props.children || []);\n          return React.createElement(component, { key: route.key! }, componentChildren);\n        } else if (getComponent) {\n          // We are asynchronously fetching this component.\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\n/** Normalize path for comparison: strip any trailing slash and convert to lowercase */\nfunction _normalizePath(path?: string): string {\n  if (path && path.slice(-1) === '/') {\n    path = path.slice(0, -1);\n  }\n  return (path || '').toLowerCase();\n}\n"]}