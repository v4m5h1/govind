define("4df9bb86-ab0a-4aab-ab5f-48bf167048fb_1.8.2", ["@microsoft/sp-core-library","@microsoft/sp-diagnostics","@microsoft/sp-loader","@microsoft/sp-http","@ms/sp-telemetry","@microsoft/decorators","@microsoft/sp-extension-base","@microsoft/sp-page-context","@microsoft/sp-lodash-subset","@microsoft/sp-component-base","@microsoft/load-themed-styles","resx-strings","@ms/sp-load-themed-styles"], function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_10__, __WEBPACK_EXTERNAL_MODULE_15__, __WEBPACK_EXTERNAL_MODULE_24__, __WEBPACK_EXTERNAL_MODULE_38__, __WEBPACK_EXTERNAL_MODULE_39__, __WEBPACK_EXTERNAL_MODULE_40__, __WEBPACK_EXTERNAL_MODULE_41__, __WEBPACK_EXTERNAL_MODULE_73__, __WEBPACK_EXTERNAL_MODULE_74__) { return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp4df9bb86_ab0a_4aab_ab5f_48bf167048fb_1_8_2"];
/******/ 	window["webpackJsonp4df9bb86_ab0a_4aab_ab5f_48bf167048fb_1_8_2"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		1: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + ({}[chunkId]||chunkId) + "_" + {"0":"218209f2a5141cafc60d"}[chunkId] + ".js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Set the webpack public path
/******/ 	(function () {
/******/ 	  var scripts = document.getElementsByTagName('script');
/******/ 	  var regex = (typeof spScriptNamePattern !== 'undefined') ? spScriptNamePattern : new RegExp('\\/sp-application-base(_[a-z0-9-]+)*\\.js', 'i');
/******/ 	  var publicPath;
/******/ 	
/******/ 	  if (scripts && scripts.length) {
/******/ 	    for (var i = 0; i < scripts.length; i++) {
/******/ 	      if (!scripts[i]) continue;
/******/ 	      var path = scripts[i].getAttribute('src');
/******/ 	      if (path && path.match(regex)) {
/******/ 	        publicPath = path.substring(0, path.lastIndexOf('/') + 1);
/******/ 	        break;
/******/ 	      }
/******/ 	    }
/******/ 	  }
/******/ 	
/******/ 	  if (!publicPath) {
/******/ 	    for (var global in window.__setWebpackPublicPathLoaderSrcRegistry__) {
/******/ 	      if (global && global.match(regex)) {
/******/ 	        publicPath = global.substring(0, global.lastIndexOf('/') + 1);
/******/ 	        break;
/******/ 	      }
/******/ 	    }
/******/ 	  }
/******/ 	  __webpack_require__.p = publicPath;
/******/ 	})();
/******/ 	
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 71);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["__extends"] = __extends;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (immutable) */ __webpack_exports__["__rest"] = __rest;
/* harmony export (immutable) */ __webpack_exports__["__decorate"] = __decorate;
/* harmony export (immutable) */ __webpack_exports__["__param"] = __param;
/* harmony export (immutable) */ __webpack_exports__["__metadata"] = __metadata;
/* harmony export (immutable) */ __webpack_exports__["__awaiter"] = __awaiter;
/* harmony export (immutable) */ __webpack_exports__["__generator"] = __generator;
/* harmony export (immutable) */ __webpack_exports__["__exportStar"] = __exportStar;
/* harmony export (immutable) */ __webpack_exports__["__values"] = __values;
/* harmony export (immutable) */ __webpack_exports__["__read"] = __read;
/* harmony export (immutable) */ __webpack_exports__["__spread"] = __spread;
/* harmony export (immutable) */ __webpack_exports__["__await"] = __await;
/* harmony export (immutable) */ __webpack_exports__["__asyncGenerator"] = __asyncGenerator;
/* harmony export (immutable) */ __webpack_exports__["__asyncDelegator"] = __asyncDelegator;
/* harmony export (immutable) */ __webpack_exports__["__asyncValues"] = __asyncValues;
/* harmony export (immutable) */ __webpack_exports__["__makeTemplateObject"] = __makeTemplateObject;
/* harmony export (immutable) */ __webpack_exports__["__importStar"] = __importStar;
/* harmony export (immutable) */ __webpack_exports__["__importDefault"] = __importDefault;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorHelper = __webpack_require__(20);
exports.default = ErrorHelper;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:CoverageThreshold(0)
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
tslib_1.__exportStar(__webpack_require__(8), exports);


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DataStoreCachingType;
(function (DataStoreCachingType) {
    DataStoreCachingType[DataStoreCachingType["none"] = 0] = "none";
    DataStoreCachingType[DataStoreCachingType["session"] = 1] = "session";
    DataStoreCachingType[DataStoreCachingType["local"] = 2] = "local";
    DataStoreCachingType[DataStoreCachingType["sharedMemory"] = 3] = "sharedMemory";
})(DataStoreCachingType || (DataStoreCachingType = {}));
exports.default = DataStoreCachingType;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:CoverageThreshold(0)
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var EventBase_1 = __webpack_require__(11);
function logData(data, parent) {
    return new this(data, EventBase_1.ClonedEventType.Single, parent);
}
function logEmptyData(parent) {
    return new this(null, EventBase_1.ClonedEventType.Single, parent);
}
function createSingleEvent(props, metadata, baseClass) {
    var SingleEvent = /** @class */ (function (_super) {
        tslib_1.__extends(SingleEvent, _super);
        function SingleEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // tslint:disable-next-line:typedef
        SingleEvent.logData = metadata ? logData : logEmptyData;
        return SingleEvent;
    }(EventBase_1.EventBase));
    EventBase_1.addEventProps(SingleEvent.prototype, props, metadata || {}, baseClass);
    return SingleEvent;
}
exports.createSingleEvent = createSingleEvent;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DataStoreCachingType_1 = __webpack_require__(7);
// DataStore class is used for transparent caching of data in memory and/or browser storage
// - Parameter defaultCachingType defines whether you want to use browser storage for all operations
// and which type of storage - session or local
// - Parameter dataStoreKey is used to prefix every key in browser storage. Actual key for browser storage
// will be dataStoreKey + key used in setValue method.
// - If DataStore is instantiated with some type of browser caching enabled - it will test if browser storage
// is available and use it. If it's not it will fall back to in-memory cache.
// - If DataStore is instantiated from two different places with same dataStoreKey and some type of
// browser storage caching, the memory storage will be shared as well as browser storage.
var DataStore = /** @class */ (function () {
    function DataStore(dataStoreKey, defaultCachingType) {
        if (defaultCachingType === void 0) { defaultCachingType = DataStoreCachingType_1.default.none; }
        DataStore.init();
        this.dataStoreKey = dataStoreKey;
        this.defaultCachingType = defaultCachingType;
        if (defaultCachingType === DataStoreCachingType_1.default.none) {
            this.dataStore = {};
        }
        else {
            var store = DataStore._dataStore[this.dataStoreKey];
            if (store === undefined) {
                DataStore._dataStore[this.dataStoreKey] = {};
            }
            this.dataStore = DataStore._dataStore[this.dataStoreKey];
        }
    }
    DataStore.hasStorageType = function (storageType) {
        DataStore.init();
        switch (storageType) {
            case DataStoreCachingType_1.default.none: return true;
            case DataStoreCachingType_1.default.sharedMemory: return true;
            case DataStoreCachingType_1.default.session: return !!DataStore._sessionStorage;
            case DataStoreCachingType_1.default.local: return !!DataStore._localStorage;
        }
        return false;
    };
    DataStore.init = function () {
        if (DataStore._initialized) {
            return;
        }
        // Need a try/catch since window.localStorage can throw.
        try {
            if ('localStorage' in window && window.localStorage && DataStore.testStorage(window.localStorage)) {
                DataStore._localStorage = window.localStorage;
            }
        }
        catch (exUsingLocalStorage) {
            // do nothing
        }
        try {
            if ('sessionStorage' in window && window.sessionStorage && DataStore.testStorage(window.sessionStorage)) {
                DataStore._sessionStorage = window.sessionStorage;
            }
        }
        catch (exUsingSessionStorage) {
            // do nothing
        }
        // Fallback logic
        if (DataStore._localStorage == null) {
            DataStore._localStorage = DataStore._sessionStorage;
        }
        DataStore._initialized = true;
    };
    /** Need to check whether the value in localStorage is of the correct type.
     * In Private Browsing in Safari, for example, localStorage is accessible,
     * but all of the non-built-in properties return undefined, and setting
     * such a property causes an exception.
     */
    DataStore.testStorage = function (storage) {
        var _testKey = "BrowserStorageTest";
        var _testValue = "1";
        var result = false;
        try {
            storage.setItem(_testKey, _testValue);
            if (storage.getItem(_testKey) === _testValue) {
                result = true;
            }
            storage.removeItem(_testKey);
        }
        catch (e) { /* no-op, return false */ }
        return result;
    };
    DataStore.prototype.setValue = function (key, value, cachingTypeOverride, normalizeKey) {
        if (normalizeKey === void 0) { normalizeKey = true; }
        key = normalizeKey ? this.normalizeKey(key) : key;
        this.dataStore[key] = value;
        var storage = this.getStorage(cachingTypeOverride);
        if (storage) {
            try {
                var objectsFound = [];
                var s = JSON.stringify(value, function (key, value) {
                    if (typeof value === 'object' && value !== null) {
                        if (objectsFound.indexOf(value) !== -1) {
                            // discard the key if circular dependency was found
                            return;
                        }
                        // Otherwise store value in the cache
                        objectsFound.push(value);
                    }
                    return value;
                });
                // empty cache
                objectsFound = null;
                storage.setItem(this.dataStoreKey + key, s);
            }
            catch (e) {
                // do nothing
            }
        }
    };
    DataStore.prototype.getValue = function (key, cachingTypeOverride, normalizeKey) {
        if (normalizeKey === void 0) { normalizeKey = true; }
        key = normalizeKey ? this.normalizeKey(key) : key;
        var value = this.dataStore[key];
        var storage = this.getStorage(cachingTypeOverride);
        if (value === undefined && storage) {
            var s = storage.getItem(this.dataStoreKey + key);
            if (s) {
                try {
                    value = JSON.parse(s);
                    this.dataStore[key] = value;
                }
                catch (e) {
                    value = undefined;
                }
            }
        }
        return value;
    };
    DataStore.prototype.remove = function (key, cachingTypeOverride, normalizeKey) {
        if (normalizeKey === void 0) { normalizeKey = true; }
        key = normalizeKey ? this.normalizeKey(key) : key;
        var storage = this.getStorage(cachingTypeOverride);
        if (storage) {
            storage.removeItem(this.dataStoreKey + key);
        }
        delete this.dataStore[key];
    };
    DataStore.prototype.getStorage = function (cachingTypeOverride) {
        var cachingType = cachingTypeOverride ? cachingTypeOverride : this.defaultCachingType;
        switch (cachingType) {
            case DataStoreCachingType_1.default.none:
                return null;
            case DataStoreCachingType_1.default.sharedMemory:
                return null;
            case DataStoreCachingType_1.default.session:
                return DataStore._sessionStorage;
            case DataStoreCachingType_1.default.local:
                return DataStore._localStorage;
        }
        return null;
    };
    DataStore.prototype.normalizeKey = function (key) {
        return key && key.toLowerCase() || '';
    };
    DataStore._sessionStorage = null;
    DataStore._localStorage = null;
    DataStore._dataStore = {};
    DataStore._initialized = false;
    return DataStore;
}());
exports.default = DataStore;


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_10__;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Manager_1 = __webpack_require__(16);
var CorrelationVector_1 = __webpack_require__(44);
var assign_1 = __webpack_require__(46);
// tslint:disable:no-bitwise
var _id = 0;
var ClonedEventType;
(function (ClonedEventType) {
    ClonedEventType[ClonedEventType["Single"] = 0] = "Single";
    ClonedEventType[ClonedEventType["Start"] = 1] = "Start";
    ClonedEventType[ClonedEventType["End"] = 2] = "End";
})(ClonedEventType = exports.ClonedEventType || (exports.ClonedEventType = {}));
var ValidationErrorType;
(function (ValidationErrorType) {
    ValidationErrorType[ValidationErrorType["NoParent"] = 1] = "NoParent";
})(ValidationErrorType = exports.ValidationErrorType || (exports.ValidationErrorType = {}));
var AccountType;
(function (AccountType) {
    AccountType[AccountType["Consumer"] = 0] = "Consumer";
    AccountType[AccountType["ConsumerAnonymous"] = 1] = "ConsumerAnonymous";
    AccountType[AccountType["Business"] = 2] = "Business";
    AccountType[AccountType["BusinessAnonymous"] = 3] = "BusinessAnonymous";
    AccountType[AccountType["Unknown"] = 4] = "Unknown";
})(AccountType = exports.AccountType || (exports.AccountType = {}));
function addEventProps(eventPrototype, props, metadata, baseClass) {
    assign_1.assign(eventPrototype, props);
    var resultMetadata = {};
    for (var key in metadata) {
        if (Object.prototype.hasOwnProperty.call(metadata, key)) {
            var item = metadata[key];
            var result = resultMetadata[key] = (typeof item === 'number' ? { type: item } : item);
            result.definedInName = props.shortEventName;
            if (result.type === 2 /* Number */) {
                result.isMetric = true;
            }
        }
    }
    eventPrototype.metadata = baseClass ? tslib_1.__assign({}, baseClass.prototype.metadata, resultMetadata) : resultMetadata;
}
exports.addEventProps = addEventProps;
var managerSpecificEventTypes = new WeakMap(); // tslint:disable-line:no-any
var EventBase = /** @class */ (function () {
    function EventBase(data, startType, parent) {
        this.context = {};
        this.validationErrors = 0;
        this.data = {};
        this.context = tslib_1.__assign({}, this.addContext({}));
        this.id = _id++;
        this.enabled = this._isEnabled();
        // Set the parent id if needed
        if (parent) {
            this.parentId = parent.id;
        }
        else if (this.requiresParent) {
            this._addValidationError(ValidationErrorType.NoParent);
        }
        // Set the start time
        this.startTime = (data && data.startTimeOverride) || Manager_1.Manager.getTime();
        this.vector = new CorrelationVector_1.CorrelationVector(parent ? parent.vector : CorrelationVector_1.CorrelationVector.RootVector);
        // Set the data if we have it
        if (data) {
            this._setData(data);
        }
        // Send the start event
        this._logEvent(startType);
    }
    /**
     * This will return true if the event is enabled
     */
    EventBase.enabled = function () {
        return this.prototype._isEnabled();
    };
    /**
     * This will return true if the event is of this type
     * @param event {IEvent} The event to compare
     */
    EventBase.isTypeOf = function (event) {
        return event.eventName.indexOf(this.prototype.shortEventName + ',') >= 0;
    };
    EventBase.withManager = function (manager) {
        if (!manager || manager === Manager_1.Manager) {
            return this;
        }
        var eventTypesForManager = managerSpecificEventTypes.get(manager);
        if (!eventTypesForManager) {
            eventTypesForManager = new WeakMap();
            managerSpecificEventTypes.set(manager, eventTypesForManager);
        }
        var eventType = eventTypesForManager.get(this);
        if (eventType) {
            return eventType;
        }
        // @ts-ignore
        var EventWithManager = /** @class */ (function (_super) {
            tslib_1.__extends(EventWithManager, _super);
            function EventWithManager() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return EventWithManager;
        }((this)));
        // @ts-ignore
        EventWithManager.prototype.manager = manager;
        eventType = EventWithManager;
        eventTypesForManager.set(this, eventType);
        return eventType;
    };
    EventBase.withData = function (modifier) {
        if (!modifier) {
            return this;
        }
        var addData = typeof modifier !== 'function' ? function (data) { return (tslib_1.__assign({}, modifier, data)); } : modifier;
        // @ts-ignore
        var EventWithData = /** @class */ (function (_super) {
            tslib_1.__extends(EventWithData, _super);
            function EventWithData() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            EventWithData.prototype.addData = function (data) {
                var localData = tslib_1.__assign({}, data, addData(data));
                return tslib_1.__assign({}, localData, _super.prototype.addData.call(this, localData));
            };
            return EventWithData;
        }((this)));
        return EventWithData;
    };
    EventBase.withContext = function (modifier) {
        if (!modifier) {
            return this;
        }
        var addContext = typeof modifier !== 'function' ? function (context) { return (tslib_1.__assign({}, modifier, context)); } : modifier;
        // @ts-ignore
        var EventWithContext = /** @class */ (function (_super) {
            tslib_1.__extends(EventWithContext, _super);
            function EventWithContext() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            EventWithContext.prototype.addContext = function (context) {
                var localContext = tslib_1.__assign({}, context, addContext(context));
                return tslib_1.__assign({}, localContext, _super.prototype.addContext.call(this, localContext));
            };
            return EventWithContext;
        }((this)));
        return EventWithContext;
    };
    EventBase.from = function (sourceEventType) {
        if (!sourceEventType) {
            return this;
        }
        return this
            .withManager(sourceEventType.prototype.manager)
            .withContext(function (context) { return sourceEventType.prototype.addContext(context); })
            .withData(function (data) { return sourceEventType.prototype.addData(data); }); // tslint:disable-line:no-any
    };
    EventBase.prototype.addContext = function (context) {
        return context;
    };
    EventBase.prototype.addData = function (data) {
        return data;
    };
    EventBase.prototype._isEnabled = function () {
        // All events are enabled by default
        return !this.samplingFeature || Manager_1.Manager.isFeatureEnabled(this.samplingFeature);
    };
    EventBase.prototype._setData = function (data) {
        var e_1, _a;
        var stored = this.data;
        try {
            for (var _b = tslib_1.__values(Object.keys(data)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (key in this.metadata) {
                    // @ts-ignore
                    var value = data[key];
                    switch (typeof value) {
                        case 'string':
                            // @ts-ignore
                            stored[key] = Manager_1.Manager.cleanString(value);
                            break;
                        case 'undefined':
                            break;
                        default:
                            // @ts-ignore
                            stored[key] = value;
                            break;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        assign_1.assign(this.data, this.addData(this.data));
    };
    EventBase.prototype._logEvent = function (eventType) {
        this.manager.logEvent(this, eventType);
    };
    EventBase.prototype._addValidationError = function (type) {
        this.validationErrors = this.validationErrors | type;
        this.manager.logValidationError(this, type);
    };
    return EventBase;
}());
exports.EventBase = EventBase;
var proto = EventBase.prototype;
proto.eventName = 'EventBase,';
proto.shortEventName = 'EventBase';
// All events are not critical by default
proto.critical = false;
// All events require parents by default
proto.requiresParent = true;
proto.manager = Manager_1.Manager;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * This file was originally ported from WinJS.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Events = __webpack_require__(57);
function doneHandler(value) {
    /* tslint:disable-next-line:ban-native-functions */
    window.setTimeout(function () {
        Events.raise(CancelablePromiseImplementation, errorET, { error: value });
    }, 0);
}
var errorET = "error";
var canceledName = "Canceled";
//
// Global error counter, for each error which enters the system we increment this once and then
// the error number travels with the error as it traverses the tree of potential handlers.
//
// When someone has registered to be told about error [using EventGroup.on(Promise, 'error')] promises
// which are in error will get tagged with a ._errorId field. This tagged field is the
// contract by which nested promises with errors will be identified as chaining for the
// purposes of the callonerror semantics. If a nested promise in error is encountered without
// a ._errorId it will be assumed to be foreign and treated as an interop boundary and
// a new error id will be minted.
//
var error_number = 1;
var state_created; // -> working
var state_working; // -> error | error_notify | success | success_notify | canceled | waiting
var state_waiting; // -> error | error_notify | success | success_notify | waiting_canceled
var state_waiting_canceled; // -> error | error_notify | success | success_notify | canceling
var state_canceled; // -> error | error_notify | success | success_notify | canceling
var state_canceling; // -> error_notify
var state_success_notify; // -> success
var state_success; // -> .
var state_error_notify; // -> error
var state_error; // -> .
// Noop function, used in the various states to indicate that they don't support a given
// message. Named with the somewhat cute name '_' because it reads really well in the states.
function _() { }
// Initial state
//
state_created = {
    name: "created",
    enter: function (promise) {
        promise._setState(state_working);
    },
    cancel: _,
    done: _,
    then: _,
    _completed: _,
    _error: _,
    _notify: _,
    _setCompleteValue: _,
    _setErrorValue: _
};
// Ready state, waiting for a message (completed/error), able to be canceled
//
state_working = {
    name: "working",
    enter: _,
    cancel: function (promise) {
        promise._setState(state_canceled);
    },
    done: done,
    then: then,
    _completed: completed,
    _error: error,
    _notify: _,
    _setCompleteValue: setCompleteValue,
    _setErrorValue: setErrorValue
};
// Waiting state, if a promise is completed with a value which is itself a promise
// (has a then() method) it signs up to be informed when that child promise is
// fulfilled at which point it will be fulfilled with that value.
//
state_waiting = {
    name: "waiting",
    enter: function (promise) {
        var waitedUpon = promise._value;
        // We can special case our own intermediate promises which are not in a
        //  terminal state by just pushing this promise as a listener without
        //  having to create new indirection functions
        if (waitedUpon instanceof ThenPromise &&
            waitedUpon._state !== state_error &&
            waitedUpon._state !== state_success) {
            pushListener(waitedUpon, { promise: promise });
        }
        else {
            var error_1 = function (value) {
                if (waitedUpon._errorId) {
                    promise._chainedError(value, waitedUpon);
                }
                else {
                    // Because this is an interop boundary we want to indicate that this
                    //  error has been handled by the promise infrastructure before we
                    //  begin a new handling chain.
                    //
                    callonerror(promise, value, detailsForHandledError, waitedUpon, error_1);
                    promise._error(value);
                }
            };
            error_1.handlesOnError = true;
            waitedUpon.then(promise._completed.bind(promise), error_1);
        }
    },
    cancel: function (promise) {
        promise._setState(state_waiting_canceled);
    },
    done: done,
    then: then,
    _completed: completed,
    _error: error,
    _notify: _,
    _setCompleteValue: setCompleteValue,
    _setErrorValue: setErrorValue
};
// Waiting canceled state, when a promise has been in a waiting state and receives a
// request to cancel its pending work it will forward that request to the child promise
// and then waits to be informed of the result. This promise moves itself into the
// canceling state but understands that the child promise may instead push it to a
// different state.
//
state_waiting_canceled = {
    name: "waiting_canceled",
    enter: function (promise) {
        // Initiate a transition to canceling. Triggering a cancel on the promise
        // that we are waiting upon may result in a different state transition
        // before the state machine pump runs again.
        promise._setState(state_canceling);
        var waitedUpon = promise._value;
        if (CancelablePromiseImplementation.is(waitedUpon)) {
            waitedUpon.cancel();
        }
    },
    cancel: _,
    done: done,
    then: then,
    _completed: completed,
    _error: error,
    _notify: _,
    _setCompleteValue: setCompleteValue,
    _setErrorValue: setErrorValue
};
// Canceled state, moves to the canceling state and then tells the promise to do
// whatever it might need to do on cancelation.
//
state_canceled = {
    name: "canceled",
    enter: function (promise) {
        // Initiate a transition to canceling. The _cancelAction may change the state
        // before the state machine pump runs again.
        promise._setState(state_canceling);
        promise._cancelAction();
    },
    cancel: _,
    done: done,
    then: then,
    _completed: completed,
    _error: error,
    _notify: _,
    _setCompleteValue: setCompleteValue,
    _setErrorValue: setErrorValue
};
// Canceling state, commits to the promise moving to an error state with an error
// object whose 'name' and 'message' properties contain the string "Canceled"
//
state_canceling = {
    name: "canceling",
    enter: function (promise) {
        var error = new Error(canceledName);
        error.name = error.message;
        error["_handled"] = true;
        promise._value = error;
        promise._setState(state_error_notify);
    },
    cancel: _,
    done: _,
    then: _,
    _completed: _,
    _error: _,
    _notify: _,
    _setCompleteValue: _,
    _setErrorValue: _
};
// Success notify state, moves a promise to the success state and notifies all children
//
state_success_notify = {
    name: "complete_notify",
    enter: function (promise) {
        if (promise._listeners) {
            var queue = [promise];
            var p = void 0;
            while (queue.length) {
                p = queue.shift();
                p._state._notify(p, queue);
            }
        }
        promise._setState(state_success);
    },
    cancel: _,
    done: function (promise, onComplete, onError) { return CompletePromise.prototype.done.call(promise, onComplete, onError); },
    then: function (promise, onComplete, onError) { return CompletePromise.prototype.then.call(promise, onComplete, onError); },
    _completed: _,
    _error: _,
    _notify: notifySuccess,
    _setCompleteValue: _,
    _setErrorValue: _
};
// Success state, moves a promise to the success state and does NOT notify any children.
// Some upstream promise is owning the notification pass.
//
state_success = {
    name: "success",
    enter: function (promise) {
        promise._cleanupAction();
    },
    cancel: _,
    done: function (promise, onComplete, onError) { return CompletePromise.prototype.done.call(promise, onComplete, onError); },
    then: function (promise, onComplete, onError) { return CompletePromise.prototype.then.call(promise, onComplete, onError); },
    _completed: _,
    _error: _,
    _notify: notifySuccess,
    _setCompleteValue: _,
    _setErrorValue: _
};
// Error notify state, moves a promise to the error state and notifies all children
//
state_error_notify = {
    name: "error_notify",
    enter: function (promise) {
        if (promise._listeners) {
            var queue = [promise];
            var p = void 0;
            while (queue.length) {
                p = queue.shift();
                p._state._notify(p, queue);
            }
        }
        promise._setState(state_error);
    },
    cancel: _,
    done: function (promise, onComplete, onError) { return ErrorPromise.prototype.done.call(promise, onComplete, onError); },
    then: function (promise, onComplete, onError) { return ErrorPromise.prototype.then.call(promise, onComplete, onError); },
    _completed: _,
    _error: _,
    _notify: notifyError,
    _setCompleteValue: _,
    _setErrorValue: _
};
// Error state, moves a promise to the error state and does NOT notify any children.
// Some upstream promise is owning the notification pass.
//
state_error = {
    name: "error",
    enter: function (promise) {
        promise._cleanupAction();
    },
    cancel: _,
    done: function (promise, onComplete, onError) { return ErrorPromise.prototype.done.call(promise, onComplete, onError); },
    then: function (promise, onComplete, onError) { return ErrorPromise.prototype.then.call(promise, onComplete, onError); },
    _completed: _,
    _error: _,
    _notify: notifyError,
    _setCompleteValue: _,
    _setErrorValue: _
};
//
// The statemachine implementation follows a very particular pattern, the states are specified
// as static stateless bags of functions which are then indirected through the state machine
// instance (a Promise). As such all of the functions on each state have the promise instance
// passed to them explicitly as a parameter and the Promise instance members do a little
// dance where they indirect through the state and insert themselves in the argument list.
//
// We could instead call directly through the promise states however then every caller
// would have to remember to do things like pumping the state machine to catch state transitions.
//
//
// Implementations of shared state machine code.
//
function completed(promise, value) {
    promise._value = value;
    promise._setState(CancelablePromiseImplementation.isPromise(value) ? state_waiting : state_success_notify);
}
function createErrorDetails(exception, error, promise, id, parent, handler) {
    return {
        exception: exception,
        error: error,
        promise: promise,
        handler: handler,
        id: id,
        parent: parent
    };
}
function detailsForHandledError(promise, errorValue, context, handler) {
    var exception = context._isException;
    var errorId = context._errorId;
    return createErrorDetails(exception ? errorValue : null, exception ? null : errorValue, promise, errorId, context, handler);
}
function detailsForChainedError(promise, errorValue, context) {
    var exception = context._isException;
    var errorId = context._errorId;
    setErrorInfo(promise, errorId, exception);
    return createErrorDetails(exception ? errorValue : null, exception ? null : errorValue, promise, errorId, context);
}
function detailsForError(promise, errorValue) {
    var errorId = ++error_number;
    setErrorInfo(promise, errorId);
    return createErrorDetails(null, errorValue, promise, errorId);
}
function detailsForException(promise, exceptionValue) {
    var errorId = ++error_number;
    setErrorInfo(promise, errorId, true);
    return createErrorDetails(exceptionValue, null, promise, errorId);
}
function done(promise, onComplete, onError) {
    pushListener(promise, { c: onComplete, e: onError });
}
function error(promise, value, onerrorDetails, context) {
    promise._value = value;
    callonerror(promise, value, onerrorDetails, context);
    promise._setState(state_error_notify);
}
function notifySuccess(promise, queue) {
    var value = promise._value;
    var listeners = promise._listeners;
    if (!listeners) {
        return;
    }
    promise._listeners = null;
    var i;
    var len;
    for (i = 0, len = listeners.length; i < len; i++) {
        var listener = listeners[i];
        var onComplete = listener.c;
        var target = listener.promise;
        if (target) {
            try {
                target._setCompleteValue(onComplete ? onComplete(value) : value);
            }
            catch (ex) {
                target._setExceptionValue(ex);
            }
            if (target._state !== state_waiting && target._listeners) {
                queue.push(target);
            }
        }
        else {
            CompletePromise.prototype.done.call(promise, onComplete);
        }
    }
}
function notifyError(promise, queue) {
    var value = promise._value;
    var listeners = promise._listeners;
    if (!listeners) {
        return;
    }
    promise._listeners = null;
    var i;
    var len;
    for (i = 0, len = listeners.length; i < len; i++) {
        var listener = listeners[i];
        var onError = listener.e;
        var target = listener.promise;
        if (target) {
            try {
                if (onError) {
                    if (!onError.handlesOnError) {
                        callonerror(target, value, detailsForHandledError, promise, onError);
                    }
                    target._setCompleteValue(onError(value));
                }
                else {
                    target._setChainedErrorValue(value, promise);
                }
            }
            catch (ex) {
                target._setExceptionValue(ex);
            }
            if (target._state !== state_waiting && target._listeners) {
                queue.push(target);
            }
        }
        else {
            ErrorPromise.prototype.done.call(promise, null, onError);
        }
    }
}
function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {
    if (value instanceof Error && value.message === canceledName) {
        return;
    }
    Events.raise(CancelablePromiseImplementation, errorET, onerrorDetailsGenerator(promise, value, context, handler));
}
function pushListener(promise, listener) {
    var listeners = promise._listeners;
    if (listeners) {
        listeners.push(listener);
    }
    else {
        listeners = [listener];
    }
    promise._listeners = listeners;
}
// The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves
// a promise directly to the success/error state without starting another notification pass (because one
// is already ongoing).
function setErrorInfo(promise, errorId, isException) {
    promise._isException = isException || false;
    promise._errorId = errorId;
}
function setErrorValue(promise, value, onerrorDetails, context) {
    promise._value = value;
    callonerror(promise, value, onerrorDetails, context);
    promise._setState(state_error);
}
function setCompleteValue(promise, value) {
    var targetState;
    if (CancelablePromiseImplementation.isPromise(value)) {
        targetState = state_waiting;
    }
    else {
        targetState = state_success;
    }
    promise._value = value;
    promise._setState(targetState);
}
function then(promise, onComplete, onError) {
    var result = new ThenPromise(promise);
    pushListener(promise, { promise: result, c: onComplete, e: onError });
    return result;
}
//
// Slim promise implementations for already completed promises, these are created
// under the hood on synchronous completion paths as well as by Promise.wrap
// and Promise.wrapError.
//
var ErrorPromise = /** @class */ (function () {
    function ErrorPromise(value, errorFunc) {
        if (errorFunc === void 0) { errorFunc = detailsForError; }
        this._value = value;
        callonerror(this, value, errorFunc);
    }
    ErrorPromise.prototype.cancel = function () {
        /* No-op */
    };
    ErrorPromise.prototype.done = function (unused, onError) {
        var value = this._value;
        if (onError) {
            try {
                if (!onError.handlesOnError) {
                    callonerror(null, value, detailsForHandledError, this, onError);
                }
                var result = onError(value);
                if (CancelablePromiseImplementation.is(result)) {
                    // If a promise is returned we need to wait on it.
                    result.done();
                }
                return;
            }
            catch (ex) {
                value = ex;
            }
        }
        if (value instanceof Error && value.message === canceledName) {
            // suppress cancel
            return;
        }
        // force the exception to be thrown asyncronously to avoid any try/catch blocks
        //
        doneHandler(value);
    };
    ErrorPromise.prototype.then = function (unused, onError) {
        // If the promise is already in a error state and no error handler is provided
        // we optimize by simply returning the promise instead of creating a new one.
        //
        if (!onError) {
            return this;
        }
        var result;
        var value = this._value;
        try {
            if (!onError.handlesOnError) {
                callonerror(null, value, detailsForHandledError, this, onError);
            }
            result = new CompletePromise(onError(value));
        }
        catch (ex) {
            // If the value throw from the error handler is the same as the value
            // provided to the error handler then there is no need for a new promise.
            //
            if (ex === value) {
                result = this;
            }
            else {
                result = new ExceptionPromise(ex);
            }
        }
        return result;
    };
    ErrorPromise.prototype.catch = function (onError) {
        return this.then(undefined, onError);
    };
    return ErrorPromise;
}());
var ExceptionPromise = /** @class */ (function (_super) {
    tslib_1.__extends(ExceptionPromise, _super);
    function ExceptionPromise(value) {
        return _super.call(this, value, detailsForException) || this;
    }
    return ExceptionPromise;
}(ErrorPromise));
var CompletePromise = /** @class */ (function () {
    function CompletePromise(value) {
        if (CancelablePromiseImplementation.isPromise(value)) {
            var result = new ThenPromise(undefined);
            result._setCompleteValue(value);
            return result;
        }
        this._value = value;
    }
    CompletePromise.prototype.cancel = function () {
        /* No-op */
    };
    CompletePromise.prototype.done = function (onComplete) {
        if (!onComplete) {
            return;
        }
        try {
            var result = onComplete(this._value);
            if (CancelablePromiseImplementation.is(result)) {
                result.done();
            }
        }
        catch (ex) {
            // force the exception to be thrown asynchronously to avoid any try/catch blocks
            doneHandler(ex);
        }
    };
    CompletePromise.prototype.then = function (onComplete) {
        var resultPromise;
        try {
            // If the value returned from the completion handler is the same as the value
            // provided to the completion handler then there is no need for a new promise.
            //
            var newValue = onComplete ? onComplete(this._value) : this._value;
            resultPromise = this._isSameValue(newValue) ? this : new CompletePromise(newValue);
        }
        catch (ex) {
            resultPromise = new ExceptionPromise(ex);
        }
        return resultPromise;
    };
    CompletePromise.prototype.catch = function (onError) {
        return this.then(undefined);
    };
    CompletePromise.prototype._isSameValue = function (value) {
        return value === this._value;
    };
    return CompletePromise;
}());
function timeout(timeoutMS) {
    var id;
    return new CancelablePromiseImplementation(function (c) {
        /* tslint:disable-next-line:ban-native-functions */
        id = window.setTimeout(c, timeoutMS);
    }, function () {
        if (id) {
            /* tslint:disable-next-line:ban-native-functions */
            window.clearTimeout(id);
        }
    });
}
function timeoutWithPromise(timeout, promise) {
    var cancelPromise = function () { promise.cancel(); };
    var cancelTimeout = function () { timeout.cancel(); };
    timeout.then(cancelPromise);
    promise.then(cancelTimeout, cancelTimeout);
    return promise;
}
function getCancelAll(values) {
    return function () {
        for (var _i = 0, _a = Object.keys(values); _i < _a.length; _i++) {
            var key = _a[_i];
            var promise = CancelablePromiseImplementation.as(values[key]);
            promise.cancel();
        }
    };
}
var staticCanceledPromise;
var CancelablePromiseImplementation = /** @class */ (function () {
    function CancelablePromiseImplementation(init, oncancel) {
        this._init(init, oncancel);
    }
    Object.defineProperty(CancelablePromiseImplementation, "cancel", {
        get: function () {
            return staticCanceledPromise || (staticCanceledPromise = new ErrorPromise(new Error(canceledName)));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a promise that is fulfilled when one of the input promises
     * has been fulfilled.
     */
    CancelablePromiseImplementation.any = function (values) {
        return new CancelablePromiseImplementation(function (complete, error) {
            var keys = Object.keys(values);
            var pending = keys.length;
            if (pending === 0) {
                complete();
            }
            var _loop_1 = function (key) {
                CancelablePromiseImplementation.as(values[key]).then(function () { complete({ key: key, value: values[key] }); }, function (e) {
                    if (e instanceof Error && e.name === canceledName) {
                        if (--pending === 0) {
                            complete(CancelablePromiseImplementation.cancel);
                        }
                        return;
                    }
                    error({ key: key, value: values[key] });
                });
            };
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                _loop_1(key);
            }
        }, getCancelAll(values));
    };
    CancelablePromiseImplementation.race = function (values) {
        return new CancelablePromiseImplementation(function (complete, error) {
            var keys = Object.keys(values);
            var pending = keys.length;
            if (pending === 0) {
                complete();
            }
            for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
                var key = keys_2[_i];
                CancelablePromiseImplementation.as(values[key]).then(complete, function (e) {
                    if (e instanceof Error && e.name === canceledName) {
                        if (--pending === 0) {
                            complete(CancelablePromiseImplementation.cancel);
                        }
                        return;
                    }
                    error(e);
                });
            }
        }, getCancelAll(values));
    };
    /**
     * Returns a promise. If the object is already a promise it is returned;
     * otherwise the object is wrapped in a promise.
     */
    CancelablePromiseImplementation.as = function (value) {
        return CancelablePromiseImplementation.is(value) ? value : new CompletePromise(value);
    };
    /**
     * Determines whether a value fulfills the promise contract.
     */
    CancelablePromiseImplementation.is = function (value) {
        return CancelablePromiseImplementation.isPromise(value) && typeof value.cancel === 'function';
    };
    CancelablePromiseImplementation.isPromise = function (value) {
        return value && typeof value === "object" && typeof value.then === "function";
    };
    /**
     * Determines whether an error value represents a promise cancellation.
     */
    CancelablePromiseImplementation.isCanceled = function (e) {
        return (e instanceof Error && e.name === canceledName);
    };
    CancelablePromiseImplementation.all = function (values) {
        return new CancelablePromiseImplementation(function (complete, error) {
            var keys = Object.keys(values);
            var errors = Array.isArray(values) ? [] : {};
            var results = Array.isArray(values) ? [] : {};
            var pending = keys.length;
            var argDone = function () {
                if ((--pending) === 0) {
                    var errorKeys = Object.keys(errors);
                    var errorCount = errorKeys.length;
                    if (errorCount === 0) {
                        complete(results);
                    }
                    else {
                        if (errorKeys.every(function (key) { return CancelablePromiseImplementation.isCanceled(errors[key]); })) {
                            complete(CancelablePromiseImplementation.cancel);
                        }
                        else {
                            error(errors);
                        }
                    }
                }
            };
            var _loop_2 = function (key) {
                var value = values[key];
                if (value === undefined) {
                    pending--;
                }
                else {
                    CancelablePromiseImplementation.then(value, function (result) { results[key] = result; argDone(); }, function (error) { errors[key] = error; argDone(); });
                }
            };
            for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {
                var key = keys_3[_i];
                _loop_2(key);
            }
            if (pending === 0) {
                complete(results);
            }
        }, getCancelAll(values));
    };
    CancelablePromiseImplementation.then = function (value, onComplete, onError) {
        return CancelablePromiseImplementation.as(value).then(onComplete, onError);
    };
    CancelablePromiseImplementation.thenEach = function (values, onComplete, onError) {
        var result = Array.isArray(values) ? [] : {};
        for (var _i = 0, _a = Object.keys(values); _i < _a.length; _i++) {
            var key = _a[_i];
            result[key] = CancelablePromiseImplementation.then(values[key], onComplete, onError);
        }
        return CancelablePromiseImplementation.all(result);
    };
    CancelablePromiseImplementation.serial = function (tasks) {
        return tasks.reduce(function (previous, task) {
            return previous.then(task);
        }, CancelablePromiseImplementation.wrap());
    };
    CancelablePromiseImplementation.timeout = function (time, promise) {
        var to = timeout(time);
        return promise ? timeoutWithPromise(to, promise) : to;
    };
    /**
     * Wraps a non-promise value in a promise. You can use this function if you need
     * to pass a value to a function that requires a promise.
     */
    CancelablePromiseImplementation.wrap = function (value) {
        return new CompletePromise(value);
    };
    CancelablePromiseImplementation.resolve = function (value) {
        return CancelablePromiseImplementation.wrap(value);
    };
    /**
     * Wraps a non-promise error value in a promise. You can use this function if you need
     * to pass an error to a function that requires a promise.
     */
    CancelablePromiseImplementation.wrapError = function (error) {
        return new ErrorPromise(error);
    };
    CancelablePromiseImplementation.reject = function (error) {
        return CancelablePromiseImplementation.wrapError(error);
    };
    /**
     * Attempts to cancel the fulfillment of a promised value. If the promise hasn't
     * already been fulfilled and cancellation is supported, the promise enters
     * the error state with a value of Error("Canceled").
     */
    CancelablePromiseImplementation.prototype.cancel = function () {
        this._state.cancel(this);
        this._run();
    };
    /**
     * Allows you to specify the work to be done on the fulfillment of the promised value,
     * the error handling to be performed if the promise fails to fulfill
     * a value.
     *
     * After the handlers have finished executing, this function throws any error that would have been returned
     * from then() as a promise in the error state.
     *
     * @param onComplete The function to be called if the promise is fulfilled successfully with a value. The fulfilled value is passed as the single argument. If the value is null, the fulfilled value is returned. The value returned from the function becomes the fulfilled value of the promise returned by then. If an exception is thrown while executing the function, the promise returned by then moves into the error state.
     * @param onError The function to be called if the promise is fulfilled with an error. The error is passed as the single argument. If it is null, the error is forwarded. The value returned from the function is the fulfilled value of the promise returned by then.
     */
    CancelablePromiseImplementation.prototype.done = function (onComplete, onError) {
        this._state.done(this, onComplete, onError);
    };
    CancelablePromiseImplementation.prototype.then = function (onComplete, onError) {
        return this._state.then(this, onComplete, onError);
    };
    CancelablePromiseImplementation.prototype.catch = function (onError) {
        return this.then(undefined, onError);
    };
    CancelablePromiseImplementation.prototype._init = function (init, oncancel) {
        this._oncancel = oncancel;
        this._setState(state_created);
        this._run();
        try {
            init(this._completed.bind(this), this._error.bind(this));
        }
        catch (ex) {
            this._setExceptionValue(ex);
        }
    };
    CancelablePromiseImplementation.prototype._cancelAction = function () {
        if (this._oncancel) {
            try {
                this._oncancel();
            }
            catch (ex) { /* ignore */ }
        }
    };
    CancelablePromiseImplementation.prototype._cleanupAction = function () {
        this._oncancel = null;
    };
    CancelablePromiseImplementation.prototype._chainedError = function (value, context) {
        var result = this._state._error(this, value, detailsForChainedError, context);
        this._run();
        return result;
    };
    CancelablePromiseImplementation.prototype._completed = function (value) {
        var result = this._state._completed(this, value);
        this._run();
        return result;
    };
    CancelablePromiseImplementation.prototype._error = function (value) {
        var result = this._state._error(this, value, detailsForError);
        this._run();
        return result;
    };
    CancelablePromiseImplementation.prototype._setState = function (state) {
        this._nextState = state;
    };
    CancelablePromiseImplementation.prototype._setCompleteValue = function (value) {
        this._state._setCompleteValue(this, value);
        this._run();
    };
    CancelablePromiseImplementation.prototype._setChainedErrorValue = function (value, context) {
        var result = this._state._setErrorValue(this, value, detailsForChainedError, context);
        this._run();
        return result;
    };
    CancelablePromiseImplementation.prototype._setExceptionValue = function (value) {
        var result = this._state._setErrorValue(this, value, detailsForException);
        this._run();
        return result;
    };
    CancelablePromiseImplementation.prototype._run = function () {
        while (this._nextState) {
            this._state = this._nextState;
            this._nextState = null;
            this._state.enter(this);
        }
    };
    CancelablePromiseImplementation.prototype._isSameValue = function (value) {
        return value === this._value;
    };
    return CancelablePromiseImplementation;
}());
Events.declare(CancelablePromiseImplementation, errorET);
//
// Internal implementation detail promise, ThenPromise is created when a promise needs
// to be returned from a then() method.
//
var ThenPromise = /** @class */ (function (_super) {
    tslib_1.__extends(ThenPromise, _super);
    function ThenPromise(creator) {
        var _this = _super.call(this) || this;
        _this._creator = creator;
        _this._initThen();
        return _this;
    }
    ThenPromise.prototype._init = function () {
        // Override to do nothing.
    };
    ThenPromise.prototype._cancelAction = function () {
        if (this._creator) {
            this._creator.cancel();
        }
    };
    ThenPromise.prototype._cleanupAction = function () {
        this._creator = null;
    };
    ThenPromise.prototype._initThen = function () {
        this._setState(state_created);
        this._run();
    };
    return ThenPromise;
}(CancelablePromiseImplementation));
var SignalPromiseImplementation = /** @class */ (function (_super) {
    tslib_1.__extends(SignalPromiseImplementation, _super);
    function SignalPromiseImplementation(cancel) {
        var _this = _super.call(this) || this;
        _this._oncancel = cancel;
        _this._initSignal();
        return _this;
    }
    SignalPromiseImplementation.prototype._init = function () {
        // Override to do nothing.
    };
    SignalPromiseImplementation.prototype._cancelAction = function () {
        if (this._oncancel) {
            this._oncancel();
        }
    };
    SignalPromiseImplementation.prototype._cleanupAction = function () {
        this._oncancel = null;
    };
    SignalPromiseImplementation.prototype._initSignal = function () {
        this._setState(state_created);
        this._run();
    };
    return SignalPromiseImplementation;
}(CancelablePromiseImplementation));
/**
 * Represents a singal promise type and constructor.
 * This type is for legacy use only, and should not be used outside this source package.
 */
exports.SignalPromise = SignalPromiseImplementation;
/**
 * Represents a cancelable promise type and constructor.
 * This type is intended to be assignable to the ES6 `Promise` type for compatibility,
 * so that `CancelablePromise` may be a used as a polyfill for `Promise`.
 */
exports.CancelablePromise = CancelablePromiseImplementation;
exports.default = exports.CancelablePromise;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Guid_1 = __webpack_require__(91);
var Killswitch = /** @class */ (function () {
    function Killswitch() {
    }
    /**
     * Performs the static initialization of the kill switches map.
     * @param {{[key: string]: boolean}} killSwitches - The map of all active killswitches.
     */
    Killswitch.initKillSwitches = function (killSwitches) {
        Killswitch._killSwitches = killSwitches || {};
    };
    /**
     * Returns true if the given SPO killswitch is found in the static map
     * of active killswitches.
     * @requires - The application should initialize the static map
     * of active killswitches using initKillSwitches before invoking this method.
     * @param killSwitch - The string representation of the guid identifying the
     * killswitch to check.
     * @param date - The date when the kill switch check has been added to the codebase.
     * @param message - A text message associated with the kill switch.
     * @returns True if the given kill switch is found active.
     */
    Killswitch.isActivated = function (killSwitch, date, message) {
        // use _spPageContextInfo for backward compatibility while still available
        var pageContext = window['_spPageContextInfo'];
        if (!Killswitch._killSwitches && pageContext && pageContext.killSwitches) {
            Killswitch.initKillSwitches(pageContext.killSwitches);
        }
        if (killSwitch && Killswitch._killSwitches) {
            return Killswitch._killSwitches[Guid_1.default.normalizeUpper(killSwitch, false /*includeBrackets*/)];
        }
        else {
            return false;
        }
    };
    return Killswitch;
}());
exports.Killswitch = Killswitch;
function getKillSwitch(pageContext) {
    var killSwitches = pageContext && pageContext.killSwitches;
    return {
        isActivated: function (killSwitch, date, message) {
            return !!killSwitches && !!killSwitches[Guid_1.default.normalizeUpper(killSwitch, false /*includeBrackets*/)];
        }
    };
}
exports.getKillSwitch = getKillSwitch;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A color represented by red, green, blue, and alpha (opacity) components.
 */
var RgbaColor = /** @class */ (function () {
    /** Constructs a default RgbaColor. Use RgbaColor.fromRgba to specify components. */
    function RgbaColor() {
        this.R = 0;
        this.G = 0;
        this.B = 0;
        this.A = RgbaColor.maxComponent; // Default to fully opaque.
    }
    /**
     * Creates a copy of the given color.
     * @param {RgbaColor} c The color to clone.
     */
    RgbaColor.clone = function (c) {
        return RgbaColor.fromRgba(c.R, c.G, c.B, c.A);
    };
    /**
     * Returns true if the colors have identical component values of R, G, B, and A.
     * @param {RgbaColor} c1 The first color to compare.
     * @param {RgbaColor} c2 The second color to compare.
     */
    RgbaColor.equals = function (c1, c2) {
        var c1IsNull = !c1;
        var c2IsNull = !c2;
        if (c1IsNull || c2IsNull) {
            return c1IsNull && c2IsNull;
        }
        else {
            return c1.R === c2.R && c1.G === c2.G && c1.B === c2.B && c1.A === c2.A;
        }
    };
    /**
     * Creates an RgbaColor from red, green, blue, and alpha component values.
     * @param {number} r The red component value (between 0 and 255).
     * @param {number} g The green component value (between 0 and 255).
     * @param {number} b The blue component value (between 0 and 255).
     * @param {number} a The alpha component value (between 0 and 255).
     */
    RgbaColor.fromRgba = function (r, g, b, a) {
        var colorObj = new RgbaColor;
        colorObj.R = Math.round(r);
        colorObj.G = Math.round(g);
        colorObj.B = Math.round(b);
        colorObj.A = a != null ? Math.round(a) : RgbaColor.maxComponent;
        return colorObj;
    };
    /**
     * Converts an rgba string of type "rgba(number(0-255), number(0-255), number(0-255), number?(0-1))"
     * to an RgbaColor
     * @param rbga the string to be converted
     */
    RgbaColor.fromRgbaString = function (rbga) {
        var rgbaColor = new RgbaColor();
        if (/^rgb.+/.test(rbga)) {
            // Match all of the numbers that are contained within the string.
            var colorNumbers = rbga.match(/[\d.]+/g);
            rgbaColor = RgbaColor.fromRgba(Number(colorNumbers[0]), Number(colorNumbers[1]), Number(colorNumbers[2]), colorNumbers.length === 4 ? Number(colorNumbers[3]) * RgbaColor.maxComponent : null);
        }
        return rgbaColor;
    };
    /**
     * Parses an HTML color string in the formats #AARRGGBB, #RRGGBB, or #RGB.
     * @param {string} htmlColor The HTML color string to parse.
     */
    RgbaColor.fromHtmlColor = function (htmlColor) {
        function TwoHexCharsToNumber(str, index1, index2) {
            return parseInt(str.charAt(index1) + str.charAt(index2), 16);
        }
        var resultColor = new RgbaColor;
        if (typeof htmlColor === "string" && htmlColor.charAt(0) === "#") {
            switch (htmlColor.length) {
                case 9: // #AARRGGBB
                    resultColor.A = TwoHexCharsToNumber(htmlColor, 1, 2);
                    resultColor.R = TwoHexCharsToNumber(htmlColor, 3, 4);
                    resultColor.G = TwoHexCharsToNumber(htmlColor, 5, 6);
                    resultColor.B = TwoHexCharsToNumber(htmlColor, 7, 8);
                    break;
                case 7: // #RRGGBB
                    resultColor.R = TwoHexCharsToNumber(htmlColor, 1, 2);
                    resultColor.G = TwoHexCharsToNumber(htmlColor, 3, 4);
                    resultColor.B = TwoHexCharsToNumber(htmlColor, 5, 6);
                    break;
                case 4: // #RGB
                    resultColor.R = TwoHexCharsToNumber(htmlColor, 1, 1);
                    resultColor.G = TwoHexCharsToNumber(htmlColor, 2, 2);
                    resultColor.B = TwoHexCharsToNumber(htmlColor, 3, 3);
                    break;
            }
        }
        else if (/^rgb.+/.test(htmlColor)) {
            resultColor = RgbaColor.fromRgbaString(htmlColor);
        }
        return resultColor;
    };
    /**
     * Converts an RgbaColor into an HTML string suitable for use as a CSS color value.
     * @param {RgbaColor} c The color to convert.
     * @param {boolean} bFilterValue If true, this produces a string to in the #AARRGGBB format.
     */
    RgbaColor.toHtmlString = function (c, bFilterValue) {
        function ByteToHexString(b) {
            var byte = Number(b);
            if (!(byte >= 0 && byte <= RgbaColor.maxComponent)) {
                throw new Error("Argument must be a Number in [0, 255]");
            }
            var hex = byte.toString(16);
            if (byte < 16) {
                hex = "0" + hex;
            }
            return hex;
        }
        if (c.A < RgbaColor.maxComponent && !bFilterValue) {
            return "rgba(" +
                c.R.toString(10) + ", " +
                c.G.toString(10) + ", " +
                c.B.toString(10) + ", " +
                (c.A / RgbaColor.maxComponent).toFixed(2) + ")";
        }
        else {
            return "#" +
                (bFilterValue ? ByteToHexString(c.A) : "") +
                ByteToHexString(c.R) +
                ByteToHexString(c.G) +
                ByteToHexString(c.B);
        }
    };
    /**
     * The maximum value of an R, G, B, or A component in an RgbaColor.
     */
    RgbaColor.maxComponent = 255;
    return RgbaColor;
}());
exports.default = RgbaColor;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_15__;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var deepCopy_1 = __webpack_require__(43);
var maxBufferSize = 100;
function getStartDate() {
    if (window.performance && window.performance.timing && window.performance.timing.navigationStart) {
        return new Date(window.performance.timing.navigationStart);
    }
    else {
        return new Date();
    }
}
var PrivateManager = /** @class */ (function () {
    function PrivateManager() {
        this._handlers = [];
        this._buffer = [];
        this._validationLoggers = [];
        this._featureEnablers = [];
    }
    Object.defineProperty(PrivateManager.prototype, "startDate", {
        get: function () {
            return getStartDate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivateManager.prototype, "startTime", {
        get: function () {
            var startDate = this.startDate;
            return startDate.getTime();
        },
        enumerable: true,
        configurable: true
    });
    PrivateManager.prototype.getTime = function () {
        return (new Date()).getTime();
    };
    /** This is the overrideable clean string function */
    PrivateManager.prototype.cleanString = function (str) {
        return str;
    };
    PrivateManager.prototype.addLogHandler = function (handler) {
        var handlers = this._handlers;
        var buffer = this._buffer;
        handlers.push(handler);
        // Return the buffer so the handler can get missed events
        return buffer.slice();
    };
    PrivateManager.prototype.removeLogHandler = function (handler) {
        var handlers = this._handlers;
        for (var x = 0; x < handlers.length; x++) {
            if (handlers[x] === handler) {
                // Remove the handler
                handlers.splice(x, 1);
                break;
            }
        }
    };
    PrivateManager.prototype.logEvent = function (event, eventType) {
        var buffer = this._buffer;
        var handlers = this._handlers;
        // Clone the object (do it natively because the browser can mark it as a type)
        var clonedEvent = Object.freeze({
            data: deepCopy_1.deepCopy(event.data),
            context: tslib_1.__assign({}, event.context),
            id: event.id,
            enabled: event.enabled,
            critical: event.critical,
            endTime: event.endTime,
            eventName: event.eventName,
            shortEventName: event.shortEventName,
            parentId: event.parentId,
            startTime: event.startTime,
            eventType: eventType,
            metadata: event.metadata,
            vector: event.vector,
            validationErrors: event.validationErrors,
            isEventTypePrefixingDisabled: event.isEventTypePrefixingDisabled
        });
        // Add to the buffer
        buffer.push(clonedEvent);
        if (buffer.length > maxBufferSize) {
            buffer.splice(1, Infinity);
            // Make sure we have a handler before the buffer is overrun
            if (handlers.length === 0) {
                _handleBaseLoggingError(new Error('Logging buffer overflow hit before any logging handler was registered'));
            }
        }
        // Let handlers know the log event has completed
        for (var x = 0; x < handlers.length; x++) {
            try {
                handlers[x](clonedEvent);
            }
            catch (e) {
                _handleBaseLoggingError(e);
            }
        }
    };
    PrivateManager.prototype.addValidationErrorLogger = function (validationLogger) {
        var validationLoggers = this._validationLoggers;
        validationLoggers.push(validationLogger);
    };
    PrivateManager.prototype.removeValidationErrorLogger = function (validationLogger) {
        var validationLoggers = this._validationLoggers;
        var index = validationLoggers.indexOf(validationLogger);
        if (index > -1) {
            validationLoggers.splice(index, 1);
        }
    };
    PrivateManager.prototype.logValidationError = function (event, type) {
        var e_1, _a;
        var validationLoggers = this._validationLoggers;
        try {
            for (var validationLoggers_1 = tslib_1.__values(validationLoggers), validationLoggers_1_1 = validationLoggers_1.next(); !validationLoggers_1_1.done; validationLoggers_1_1 = validationLoggers_1.next()) {
                var validationLogger = validationLoggers_1_1.value;
                try {
                    validationLogger(event, type);
                }
                catch (e) {
                    _handleBaseLoggingError(e);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (validationLoggers_1_1 && !validationLoggers_1_1.done && (_a = validationLoggers_1.return)) _a.call(validationLoggers_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    PrivateManager.prototype.isFeatureEnabled = function (feature) {
        var e_2, _a;
        var featureEnablers = this._featureEnablers;
        try {
            for (var featureEnablers_1 = tslib_1.__values(featureEnablers), featureEnablers_1_1 = featureEnablers_1.next(); !featureEnablers_1_1.done; featureEnablers_1_1 = featureEnablers_1.next()) {
                var featureEnabler = featureEnablers_1_1.value;
                if (featureEnabler(feature)) {
                    return true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (featureEnablers_1_1 && !featureEnablers_1_1.done && (_a = featureEnablers_1.return)) _a.call(featureEnablers_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return false;
    };
    PrivateManager.prototype.addFeatureEnabler = function (featureEnabler) {
        var featureEnablers = this._featureEnablers;
        featureEnablers.push(featureEnabler);
    };
    PrivateManager.prototype.removeFeatureEnabler = function (featureEnabler) {
        var featureEnablers = this._featureEnablers;
        var index = featureEnablers.indexOf(featureEnabler);
        if (index > -1) {
            featureEnablers.splice(index, 1);
        }
    };
    PrivateManager.prototype.getStack = function () {
        var error;
        try {
            var w = window;
            w.______ExpectedError______();
        }
        catch (e) {
            error = e;
        }
        return error.stack;
    };
    return PrivateManager;
}());
/**
 * Creates a new, private manager with its own event queue and handlers.
 */
function createManager() {
    return new PrivateManager();
}
exports.createManager = createManager;
function createDefaultGlobalManager() {
    var globalManager;
    if (typeof window !== 'undefined') {
        globalManager = window.ODSP_TELEMETRY_MANAGER = window.ODSP_TELEMETRY_MANAGER || createManager();
    }
    else if (typeof self !== 'undefined') {
        globalManager = self.ODSP_TELEMETRY_MANAGER = self.ODSP_TELEMETRY_MANAGER || createManager();
    }
    else {
        globalManager = createManager();
    }
    return globalManager;
}
/**
 * Gets the default/fallback telemetry manager for the running application.
 */
exports.Manager = createDefaultGlobalManager();
function _handleBaseLoggingError(error) {
    // TODO: Log somewhere
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
tslib_1.__exportStar(__webpack_require__(47), exports);
var Engagement_event_1 = __webpack_require__(47);
exports.default = Engagement_event_1.Engagement;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
tslib_1.__exportStar(__webpack_require__(48), exports);
var Qos_event_1 = __webpack_require__(48);
exports.default = Qos_event_1.Qos;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ResultTypeEnum;
(function (ResultTypeEnum) {
    ResultTypeEnum[ResultTypeEnum["Success"] = 0] = "Success";
    ResultTypeEnum[ResultTypeEnum["Failure"] = 1] = "Failure";
    ResultTypeEnum[ResultTypeEnum["ExpectedFailure"] = 2] = "ExpectedFailure";
})(ResultTypeEnum = exports.ResultTypeEnum || (exports.ResultTypeEnum = {}));


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CaughtError_event_1 = __webpack_require__(21);
var QosError_event_1 = __webpack_require__(26);
var Verbose_event_1 = __webpack_require__(27);
var CircularBuffer_1 = __webpack_require__(78);
var safeSerialize_1 = __webpack_require__(28);
var MAX_VERBOSE_LOGS = 50;
var CANCELED = 'Canceled';
var _verboseLogs = new CircularBuffer_1.CircularBuffer(MAX_VERBOSE_LOGS);
function verbose(message, eventName) {
    _verboseLogs.push({
        name: eventName,
        message: message
    });
}
exports.verbose = verbose;
function logError(error, extraData, qosData) {
    if (!error || _isCanceled(error)) {
        return;
    }
    var message = getErrorMessage(error);
    var stack = error && typeof error === 'object' && ('stack' in error) && error.stack ? error.stack : '';
    var schema;
    while (schema = _verboseLogs.popOldest()) {
        Verbose_event_1.Verbose.logData(schema);
    }
    if (qosData && qosData.eventName) {
        QosError_event_1.QosError.logData({
            name: qosData.eventName,
            resultCode: qosData.resultCode,
            resultType: qosData.resultType,
            extraData: extraData || {},
            message: message,
            stack: stack
        });
    }
    else {
        CaughtError_event_1.CaughtError.logData({
            extraData: extraData || {},
            message: message,
            stack: stack
        });
    }
}
exports.logError = logError;
function log(error, eventName, resultCode, resultType) {
    logError(error, undefined, { eventName: eventName, resultCode: resultCode, resultType: resultType });
}
exports.log = log;
/**
 * Extract the error message from the error
 */
function getErrorMessage(error) {
    var message = '';
    if (error) {
        if (typeof (error) === 'object' && 'message' in error) {
            message = error.message;
        }
        else if (typeof (error) === 'object' && 'description' in error) {
            message = error.description;
        }
        else if (typeof (error) === 'object') {
            message = safeSerialize_1.safeSerialize(error);
        }
        else if (error.toString) {
            message = error.toString();
        }
    }
    return message;
}
exports.getErrorMessage = getErrorMessage;
function _isCanceled(error) {
    return error === CANCELED ||
        (!!error && typeof error === 'object' && ('name' in error) && error.name === CANCELED) ||
        (!!error && typeof error === 'object' && ('message' in error) && error.message === CANCELED);
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventBase_1 = __webpack_require__(8);
var Trace_event_1 = __webpack_require__(50);
exports.CaughtError = SingleEventBase_1.createSingleEvent({
    eventName: 'CaughtError,Trace,',
    shortEventName: 'CaughtError',
    critical: true,
    requiresParent: false
}, {
    stack: 1 /* String */,
    extraData: 4 /* Object */
}, Trace_event_1.Trace);


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var PairedEventBase_1 = __webpack_require__(83);
exports.Beacon = PairedEventBase_1.createPairedEvent({
    eventName: 'Beacon,',
    shortEventName: 'Beacon',
    requiresParent: false
}, {
    name: 1 /* String */,
    status: 1 /* String */,
    success: 3 /* Boolean */,
    retryCount: 2 /* Number */,
    totalRetries: 2 /* Number */,
    eventCount: 2 /* Number */
});
exports.default = exports.Beacon;


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Killswitches; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__microsoft_sp_core_library__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__microsoft_sp_core_library___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__microsoft_sp_core_library__);

var Killswitches =  (function () {
    function Killswitches() {
    }
    Killswitches.usePrefetchHeader = function () {
        return !__WEBPACK_IMPORTED_MODULE_0__microsoft_sp_core_library__["_SPKillSwitch"].isActivated(__WEBPACK_IMPORTED_MODULE_0__microsoft_sp_core_library__["Guid"].parse('63c0659f-f24b-49cf-9a0f-289bc19a3837'), '2019/01/09', 'Add x-requestprefetchlink header');
    };
    Killswitches.themeProviderOverrideKSActive = function () {
        return __WEBPACK_IMPORTED_MODULE_0__microsoft_sp_core_library__["_SPKillSwitch"].isActivated(__WEBPACK_IMPORTED_MODULE_0__microsoft_sp_core_library__["Guid"].parse('1099d005-c357-4c99-a36f-ab53ef6fcddf'), '01/18/2019', 'Allow apps to override the default theme provider');
    };
    Killswitches.themeProviderChromelessKSActive = function () {
        return __WEBPACK_IMPORTED_MODULE_0__microsoft_sp_core_library__["_SPKillSwitch"].isActivated(__WEBPACK_IMPORTED_MODULE_0__microsoft_sp_core_library__["Guid"].parse('9866f5a3-af0a-4285-af01-dbecba48cddb'), '01/18/2019', 'Do not load themes in a chromeless application');
    };
    Killswitches.appCustomizersLoadSequenceKSActive = function () {
        return __WEBPACK_IMPORTED_MODULE_0__microsoft_sp_core_library__["_SPKillSwitch"].isActivated(__WEBPACK_IMPORTED_MODULE_0__microsoft_sp_core_library__["Guid"].parse('99d59913-bc06-4d55-99fe-b3a96e562dbc'), '02/27/2019', 'Fix the application customizers load sequence');
    };
    return Killswitches;
}());



/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_24__;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:CoverageThreshold(92)
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
tslib_1.__exportStar(__webpack_require__(11), exports);


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventBase_1 = __webpack_require__(8);
var CaughtError_event_1 = __webpack_require__(21);
var ResultTypeEnum_1 = __webpack_require__(19);
exports.ResultTypeEnum = ResultTypeEnum_1.ResultTypeEnum;
exports.QosError = SingleEventBase_1.createSingleEvent({
    eventName: 'QosError,CaughtError,Trace,',
    shortEventName: 'QosError',
    critical: true
}, {
    name: {
        isKey: true,
        type: 1 /* String */
    },
    resultCode: 1 /* String */,
    resultType: {
        typeRef: ResultTypeEnum_1.ResultTypeEnum,
        type: 6 /* Enum */
    }
}, CaughtError_event_1.CaughtError);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventBase_1 = __webpack_require__(8);
var Trace_event_1 = __webpack_require__(50);
exports.Verbose = SingleEventBase_1.createSingleEvent({
    eventName: 'Verbose,Trace,',
    shortEventName: 'Verbose',
    requiresParent: false
}, {
    name: {
        isKey: true,
        type: 1 /* String */
    }
}, Trace_event_1.Trace);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This is a function you can call to safely serialize anything to JSON.
 * The built-in JSON.stringify() throws an exception for circular references and can't handle
 * many built-ins such as HTMLElements and the global window object.
 */
function safeSerialize(obj) {
    var str;
    try {
        var seenObjects_1 = [];
        str = JSON.stringify(obj, function (key, value) {
            if (value === window) {
                return '[window]';
            }
            else if (value instanceof HTMLElement) {
                return '[HTMLElement]';
            }
            else if (typeof value === 'function') {
                return '[function]';
            }
            else if (typeof value === 'object') {
                if (value === null) {
                    return value;
                }
                else if (seenObjects_1.indexOf(value) === -1) {
                    seenObjects_1.push(value);
                    return value;
                }
                else {
                    return '[circular]';
                }
            }
            else {
                return value;
            }
        });
    }
    catch (err) {
        // Note: we make this be a JSON string, so that consumers
        // can always call JSON.parse.
        str = JSON.stringify('[object]');
    }
    return str;
}
exports.safeSerialize = safeSerialize;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// OneDrive:IgnoreCodeCoverage
var Async_1 = __webpack_require__(51);
var PageTransitionType_1 = __webpack_require__(52);
var RUMOneDataUpload_event_1 = __webpack_require__(53);
var PlatformDetection_1 = __webpack_require__(30);
var PerformanceMarker_1 = __webpack_require__(82);
var PerformanceDataState;
(function (PerformanceDataState) {
    /**
     * Not enought data collected to upload
     * At this state logger isRunning is true
     */
    PerformanceDataState[PerformanceDataState["Incomplete"] = 1] = "Incomplete";
    /**
     * Required data collected and can be uploaded.
     * Practically all expected controls has rendered by this time
     * and EUPL has been set.
     * At this state logger isRunning is true but sooner to change to false.
     */
    PerformanceDataState[PerformanceDataState["ReadyToUpload"] = 2] = "ReadyToUpload";
    /**
     * Incomplete -> ReadyToUpload |  ERROR_TIMEOUT time elapsed -> Uploaded
     * Performance data has been uploaded for the current page.
     * Until reset, no more data will be uploaded.
     */
    PerformanceDataState[PerformanceDataState["Uploaded"] = 3] = "Uploaded";
    /**
     * Incomplete -> ERROR_TIMEOUT time elapsed -> TimeOut -> Uploaded
     * Timeout occured before expected controls could finish rendering
     * Data will be uploaded as it is but without EUPL.
     * Consumer should consider EUPL="" as > 30 sec for performance analysis
     */
    PerformanceDataState[PerformanceDataState["TimeOut"] = 4] = "TimeOut";
    /**
     * Incomplete -> (ERROR_TIMEOUT time elapsed && TimeOut) | ReadyToUpload -> Skipped
     * This is a state where data has been collected or timeout but uploading the data was skipped
     * This happens when consumer has asked to do so based on the page's debug environment
     */
    PerformanceDataState[PerformanceDataState["Skipped"] = 5] = "Skipped";
})(PerformanceDataState || (PerformanceDataState = {}));
var APICallPerformanceData = /** @class */ (function () {
    function APICallPerformanceData(url, duration, correlationid, status, startTime, endTime, name) {
        this.url = url;
        this.duration = duration;
        this.correlationId = correlationid;
        this.status = status;
        this.startTime = startTime;
        this.endTime = endTime;
        this.name = name;
    }
    return APICallPerformanceData;
}());
exports.APICallPerformanceData = APICallPerformanceData;
// Default key metrics which are always required before perf perf data is uploaded.
// For any additional key metric call addExpectedKeyMetric API
var DEFAULT_KEY_METRICS = ['EUPL', 'ScenarioId'];
// Each property column should confirm to this regex to align with Aria column name restriction.
var PROPERTY_NAME_REGEX = /^[a-zA-Z0-9](([a-zA-Z0-9|_|\.]){0,98}[a-zA-Z0-9])?$/;
var ControlPerformanceData = /** @class */ (function () {
    function ControlPerformanceData(controlId, startTime, endTime, renderTimeCalculator, renderTimeRequiredDataChecker, ignoreForEUPL, needFlatten) {
        this.controlId = controlId;
        this.startTime = startTime;
        this.endTime = endTime;
        this.renderTimeCalculator = renderTimeCalculator;
        this.renderTimeRequiredDataChecker = renderTimeRequiredDataChecker;
        this.ignoreForEUPL = ignoreForEUPL === undefined ? true : ignoreForEUPL;
        this.needFlatten = needFlatten === undefined ? false : needFlatten;
    }
    return ControlPerformanceData;
}());
exports.ControlPerformanceData = ControlPerformanceData;
function isNullOrUndefined(item) {
    'use strict';
    return item === null || typeof item === 'undefined';
}
var DEFAULT_LOGGER_NAME = '__default_rumone__';
var DEFAULT_CONFIG = {
    checkInterval: 100,
    error_timeout: 30000,
    max_markers: 100 // suppport maximum 100 perf markers
};
/**
 * It is a new client side perf instrumentation, it logs more metrics, like scenario, api data, server request id, duration, etc in 1 single schema.
 * It has server side usage DB and cosmos supports.
 */
var RUMOneLogger = /** @class */ (function () {
    function RUMOneLogger(name, logFunc, rumOneconfig) {
        if (rumOneconfig === void 0) { rumOneconfig = DEFAULT_CONFIG; }
        this._keyMetrics = DEFAULT_KEY_METRICS;
        this.async = new Async_1.default(this);
        this.dataStartTime = Number((new Date()).getTime());
        this._rumoneData = {};
        this.dataState = PerformanceDataState.Incomplete;
        this.controls = [];
        this.apis = [];
        this.euplBreakDown = {};
        this.serverMetrics = {};
        this.isW3cTimingCollected = false;
        this.isW3cResourceTimingCollected = false;
        this.tempData = {};
        this._emergencyUpdateFunc = this._emergencyUpload.bind(this);
        this._name = name;
        this.loggingFunc = logFunc;
        this._config = rumOneconfig;
        this.setPerfDataTimer();
        this._platformDetection = new PlatformDetection_1.default();
        this._hookUnloadEvent();
    }
    /**
     * * RUMOneLogger.getRUMOneLogger: Use this method to get an intance of RUMOneLogger
     * with default parameters.
     * @param name: name of the instance of RUMOneLogger.
     * If not provided, the default singleton RUMOneLogger instance will be returned
     * @param logFunc: method of uploading collected RUMOne data to telemetry data storage
     * @param rumOneConfig: configuration of RUMOneLogger, do not pass in and use default if you
     * are not sure
     */
    RUMOneLogger.getRUMOneLogger = function (name, logFunc, rumOneConfig) {
        if (name === void 0) { name = DEFAULT_LOGGER_NAME; }
        if (rumOneConfig === void 0) { rumOneConfig = DEFAULT_CONFIG; }
        var loggingFunc = logFunc || (function (streamName, dictProperties) {
            RUMOneDataUpload_event_1.RUMOneDataUpload.logData({ streamName: streamName, dictionary: dictProperties });
        });
        if (!RUMOneLogger.Loggers[name]) {
            try {
                var logger = new RUMOneLogger(name, loggingFunc, rumOneConfig);
                if (name === DEFAULT_LOGGER_NAME) {
                    RUMOneLogger.rumOneLogger = logger;
                }
                RUMOneLogger.Loggers[name] = logger;
            }
            catch (e) {
                // If RUMOneLogger fails, don't block UX
            }
        }
        return RUMOneLogger.Loggers[name];
    };
    Object.defineProperty(RUMOneLogger.prototype, "KeyMetrics", {
        // For backward compatibility, will be removed once addExpectedKeyMetric API is adopted
        get: function () {
            return this._keyMetrics;
        },
        enumerable: true,
        configurable: true
    });
    RUMOneLogger.prototype.getPerformanceData = function () {
        return this._rumoneData;
    };
    RUMOneLogger.prototype.resetLogger = function () {
        this._emergencyUpload(); // upload ready key metrics if we have not. this should rarely happen
        this.dataStartTime = (new Date()).getTime();
        this.dataState = PerformanceDataState.Incomplete;
        this.isW3cTimingCollected = false;
        this.isW3cResourceTimingCollected = false;
        this.controls = [];
        this.apis = [];
        this.tempData = {};
        this._rumoneData = {};
        this._excludePageData = false;
        this._waitOnAddingExpectedControl = false;
        this._keyMetrics = DEFAULT_KEY_METRICS;
        this.clearPerfDataTimer();
        this.setPerfDataTimer();
        this.euplBreakDown = {};
        this.serverMetrics = {};
        this.clearResourceTimings();
        PerformanceMarker_1.clearMarks(this._getOwnMakers().map(function (marker) { return marker.name; }));
        RUMOneLogger._markers[this._name] = [];
        this._unhookUnloadEvent();
        this._hookUnloadEvent();
        this.logMessageInConsole("Reset performance Logger Done");
    };
    /**
     * Consumer should own logic to determine whether to ignore the  page for perf data collection
     * when Called this API, RUMOneLogger will not upload data but display in the console for debug purpose
     * E.g. Hidden Preload.aspx page for sharepoint or a debug page with #debugManifest or ?moduleLoader= in the url
     *
     */
    RUMOneLogger.prototype.excludePageForPerfData = function () {
        this._excludePageData = true;
    };
    RUMOneLogger.prototype.getPerformanceDataPropertyValue = function (key) {
        return key && this._rumoneData[key];
    };
    /**
     * Use this API carefully to add extra dynamic columns to Performance data.
     * addEUPLBreakdown with needFlatter can do same thing, but add duplicate data into two columns
     * CAUTION: Do not use this API for random name as it can explode number of columns
     * Use column names which are going to be consistent and don't explode in count over time.
     * Like name based on guid, timestamp or counters are bad examples to use as key.
     *
     * @param key Name of the dynamic coulmn confirming to Regex /^[a-zA-Z0-9](([a-zA-Z0-9|_|\.]){0,98}[a-zA-Z0-9])?$/
     * @param value Corresponding value
     *
     * Throws Error when key does not confirm to the Supported Regex
     */
    RUMOneLogger.prototype.setPerformanceDataPropertyValue = function (key, value) {
        if (key && PROPERTY_NAME_REGEX.test(key)) {
            this._rumoneData[key] = value;
            return true;
        }
        else {
            console.error("key " + key + " does not confrim to the Regex " + PROPERTY_NAME_REGEX);
            return false;
        }
    };
    RUMOneLogger.prototype.addExpectedControl = function (control) {
        var normalizedControl = this._normalizeControl(control);
        if (!this.expectingControl(control)) {
            this.controls.push(normalizedControl);
        }
        else {
            // Ensure expected controls are not ignored from EUPL
            this.controls.filter(function (expected) { return expected.controlId === normalizedControl.controlId; })[0].ignoreForEUPL = normalizedControl.ignoreForEUPL;
        }
    };
    RUMOneLogger.prototype.expectingControl = function (control) {
        var normalizedControl = this._normalizeControl(control);
        return this.controls.filter(function (expected) { return expected.controlId === normalizedControl.controlId; }).length > 0;
    };
    RUMOneLogger.prototype.writeServerCorrelationId = function (correlationId) {
        this._rumoneData.ServerCorrelationId = this._rumoneData.ServerCorrelationId || correlationId;
    };
    RUMOneLogger.prototype.writeServerUrl = function (url) {
        if (!this._rumoneData.ServerUrl) {
            this._rumoneData.ServerUrl = url || window.location.href;
        }
    };
    RUMOneLogger.prototype.writeServerSideLatency = function (duration, iisLatency) {
        if (!this.isCollected('ServerRequestDuration')) {
            this._rumoneData.ServerRequestDuration = duration;
            this._rumoneData.IISLatency = iisLatency;
        }
    };
    RUMOneLogger.prototype.writeControlPerformanceData = function (controlData) {
        if (controlData) {
            var foundControl = this.controls.filter(function (control) { return control.controlId === controlData.controlId; })[0];
            if (foundControl) {
                if (!foundControl.data) {
                    foundControl.data = controlData;
                }
            }
            else {
                var control = {
                    controlId: controlData.controlId,
                    data: controlData,
                    ignoreForEUPL: controlData.ignoreForEUPL
                };
                this.controls.push(control);
            }
        }
    };
    RUMOneLogger.prototype.writeAPICallPerformanceData = function (apiData) {
        if (apiData) {
            this.apis.push(apiData);
        }
    };
    RUMOneLogger.prototype.readAPICallPerformanceData = function () {
        return this.apis;
    };
    RUMOneLogger.prototype.writeAppCache = function (appCache) {
        if (!this.isCollected('AppCache')) {
            this._rumoneData.AppCache = appCache;
        }
    };
    RUMOneLogger.prototype.writePageTransitionType = function (pageTransitionType, overwrite) {
        if ((!this.isCollected('PageTransitionType') || overwrite) &&
            (pageTransitionType === PageTransitionType_1.default.fullPageLoad || pageTransitionType === PageTransitionType_1.default.none || pageTransitionType === PageTransitionType_1.default.onePageAppNavigation)) {
            this._rumoneData.PageTransitionType = pageTransitionType;
        }
    };
    RUMOneLogger.prototype.writeScenarioId = function (scenarioId, overwrite) {
        if (!this.isCollected('ScenarioId') || overwrite) {
            this._rumoneData.ScenarioId = scenarioId;
        }
    };
    RUMOneLogger.prototype.collectW3CPerfTimings = function () {
        if (!this.isW3cTimingCollected) {
            var w3cTimeStampNames = ['navigationStart', 'unloadEventStart', 'unloadEventEnd', 'fetchStart', 'redirectStart', 'redirectEnd', 'domainLookupStart', 'domainLookupEnd', 'connectStart', 'secureConnectionStart', 'connectEnd', 'requestStart', 'responseStart', 'responseEnd', 'domLoading', 'domComplete', 'loadEventStart', 'loadEventEnd'];
            var perfTimingObject = performance && performance.timing;
            if (perfTimingObject) {
                for (var index = 0; index < w3cTimeStampNames.length; index++) {
                    var w3cObject = perfTimingObject[w3cTimeStampNames[index]];
                    if (w3cObject) {
                        this._logRUMOneData(this.getW3cTimingName(w3cTimeStampNames[index]), Number(w3cObject));
                    }
                }
                this.isW3cTimingCollected = true;
            }
        }
    };
    RUMOneLogger.prototype.collectW3cResourceTimings = function () {
        if (window.document && !this.isW3cResourceTimingCollected && performance && performance.getEntriesByType) {
            var allRequests = performance.getEntriesByType("resource");
            var iFrames = document.getElementsByTagName("iframe");
            for (var index = 0; index < iFrames.length; index++) {
                var iFramePerformance = null;
                try {
                    iFramePerformance = iFrames[index].contentWindow.performance;
                }
                catch (e) {
                    // sometimes we can't access iFrame.
                }
                if (iFramePerformance && iFramePerformance.getEntriesByType) {
                    allRequests.concat(iFramePerformance.getEntriesByType("resource"));
                }
            }
            var fromSources = {};
            fromSources["SharePoint"] = function (element) { return /\.sharepoint\.com|\.spoppe\.com/i.test(element.name); }; //matching sharepoint.com or spoppe.com
            fromSources["CDN"] = function (element) { return /(cdn(ppe)?|static(ppe)?)\.sharepointonline\.com|\.akamaihd\.net/i.test(element.name); }; //matching cdn(ppe)sharepointonline.com or adamaihd.net
            fromSources["ThirdParty"] = function (element) { return !fromSources["SharePoint"](element) && !fromSources["CDN"](element); }; // all requests other than sharepoint requests or cdn requests
            var types = {};
            types["ASPX"] = function (element) { return /\.aspx/i.test(element.name); };
            types["JS"] = function (element) { return /script/i.test(element.initiatorType); };
            types["CSS"] = function (element) { return /link|css/i.test(element.initiatorType); };
            types["IMG"] = function (element) { return /img/i.test(element.initiatorType); };
            var sources = Object.keys(fromSources);
            for (var index = 0; index < sources.length; index++) {
                var source = sources[index];
                var requests = this.categorizeResourceRequests(allRequests, {
                    from: fromSources[source],
                    requestType: null //match any type to get total request count for this source
                });
                this._logRUMOneData(source + "RequestCountTotal", requests.length); //SharePoint|CDN|ThirdParty resource request count
                var typeKeys = Object.keys(types);
                for (var typeIndex = 0; typeIndex < typeKeys.length; typeIndex++) {
                    var type = typeKeys[typeIndex];
                    this._logRUMOneData(source + "RequestCount" + type, this.categorizeResourceRequests(requests, {
                        from: null,
                        requestType: types[type]
                    }).length); //SharePoint|CDN|ThirdParty ASPX resource request count
                }
                if (requests.length > 0) {
                    this._logRUMOneData(source + "RequestDownloadTime", Math.round(requests.reduce(function (sum, currentVal) {
                        return sum + currentVal.duration;
                    }, 0) / requests.length)); //SharePoint|CDN|ThirdParty resource request average duration
                    // log the file names of all resource requests in a JSON string. The output after processing will looks like:
                    // [{name: "require-db6c47e2.js", startTime: 500, duration: 100},{name: "RenderListDataAsStream", startTime: 200, duration: 10}]
                    // The raw resource name before this processing is "https://msft.spoppe.com/teams/SPGroups/_api/web/GetList(@listUrl)/RenderListDataAsStream?Paged=TRUE&p_FileLeafRef=test%2eurl&p_ID=213&PageFirstRow=121&View=6eab4254-2f2f-4086-91c0-549ae900cc93&@listUrl=%27%2Fteams%2FSPGroups%2FVNextDocLib%27"
                    var files = JSON.stringify(requests.map(function (timing) {
                        return {
                            name: timing.name.split("/").map(function (urlToken) {
                                return urlToken.split("?")[0];
                            }).filter(function (urlToken) {
                                return urlToken && urlToken.length > 0;
                            }).slice(-1)[0].replace(/\(.*?\)/g, '()'),
                            startTime: Math.round(timing.startTime),
                            duration: Math.round(timing.duration),
                            transferSize: timing['transferSize'] || 0
                        };
                    }));
                    this._logRUMOneData(source + "RequestNames", files);
                }
            }
            this.isW3cResourceTimingCollected = true;
        }
    };
    RUMOneLogger.prototype.saveTempData = function (key, value) {
        this.tempData[key] = value;
    };
    RUMOneLogger.prototype.readTempData = function (key) {
        return this.tempData[key];
    };
    RUMOneLogger.prototype.writeRenderTime = function (renderTime, overwrite) {
        if (!this.isCollected('RenderTime') || overwrite) {
            this._rumoneData.RenderTime = renderTime;
        }
    };
    RUMOneLogger.prototype.writePreRenderTime = function (preRender) {
        if (!this.isCollected('PreRender')) {
            this._rumoneData.PreRender = preRender;
        }
    };
    RUMOneLogger.prototype.writePostRenderTime = function (postRender) {
        if (!this.isCollected('PostRender')) {
            this._rumoneData.PostRender = postRender;
        }
    };
    RUMOneLogger.prototype.writeDataFetchTime = function (dataFetch, overwrite) {
        if (!this.isCollected('DataFetch') || overwrite) {
            this._rumoneData.DataFetch = dataFetch;
        }
    };
    RUMOneLogger.prototype.isRunning = function () {
        return !(this.dataState === PerformanceDataState.Uploaded ||
            this.dataState === PerformanceDataState.TimeOut ||
            this.dataState === PerformanceDataState.Skipped);
    };
    RUMOneLogger.prototype.writeEUPLBreakdown = function (euplBreakdown, overwrite) {
        if (euplBreakdown) {
            try {
                var breakdown = JSON.parse(euplBreakdown);
                for (var key in breakdown) {
                    if (!breakdown.hasOwnProperty(key)) {
                        continue;
                    }
                    this.addEUPLBreakdown(key, breakdown[key], overwrite);
                }
            }
            catch (e) {
                // in case the euplBreakdown is invalid JSON
                this.logMessageInConsole("Failed to write EUPL breakdown data:" + e.toString());
            }
        }
    };
    RUMOneLogger.prototype.addEUPLBreakdown = function (name, value, overwrite) {
        if (name && !isNullOrUndefined(value)) {
            if (isNullOrUndefined(this.euplBreakDown[name]) || overwrite) {
                var data = this._isBreakdownValue(value) ? value.data : value;
                this.euplBreakDown[name] = data;
            }
            //  kusto job to parse EUPLBreakdown property bag is expensive and cause a lot kusto/MDM perf issues.
            //  to workaround it, we flatten EUPLBreakdown properties that are marked with needFlatten===true to send
            //  them to aria as individual columns. After this change, kusto query does not need to parse json any more.
            if (this._isBreakdownValue(value) && value.needFlatten) {
                this._logRUMOneData(name, value.data);
            }
        }
    };
    RUMOneLogger.prototype.readEUPLBreakdown = function (name) {
        return !!name ? this.euplBreakDown[name] : this.euplBreakDown;
    };
    /**
     * Add list of flights enabled for this page.
     */
    RUMOneLogger.prototype.addFlights = function (flights) {
        if (flights && flights.length > 0) {
            var _flights = JSON.parse(this.getPerformanceDataPropertyValue('Flights') || '[]');
            for (var index = 0; index < flights.length; index++) {
                var flight = flights[index];
                if (flight && _flights.indexOf(flight) === -1) {
                    _flights.push(flight);
                }
            }
            this._rumoneData.Flights = JSON.stringify(_flights);
        }
    };
    RUMOneLogger.prototype.addServerMetrics = function (metric, overwrite) {
        if (metric) {
            for (var key in metric) {
                if (key && !isNullOrUndefined(metric[key]) &&
                    (isNullOrUndefined(this.serverMetrics[key]) || overwrite)) {
                    this.serverMetrics[key] = metric[key];
                }
            }
        }
    };
    /**
     * Write version of the Sharepoint server served the request
     */
    RUMOneLogger.prototype.writeServerVersion = function (version) {
        this._rumoneData.SharePointServerVersion = version;
    };
    RUMOneLogger.prototype.readControlPerformanceData = function () {
        return this.controls.filter(function (control) { return !!control.data; }).map(function (control) { return control.data; });
    };
    RUMOneLogger.prototype.mark = function (name) {
        var marks = RUMOneLogger._markers[this._name] = RUMOneLogger._markers[this._name] || [];
        marks.push(name);
        PerformanceMarker_1.mark(name);
    };
    RUMOneLogger.prototype.now = function () {
        return performance && performance.now ? Math.round(performance.now()) : NaN;
    };
    /**
     * Register handler function that will be called back when EUPL is computed successfully.
     * @param handler function that app register, wiill be called back when EUPL is computed.
     */
    RUMOneLogger.prototype.registerEUPLComputedHandler = function (handler) {
        this._EUPLComputedHandler = handler;
    };
    /**
     * Register handler function that will be called back when timeout happens.
     * @param handler function that app register, will be called back when timeout happens
     */
    RUMOneLogger.prototype.registerErrorHandler = function (handler) {
        /* no-op */
    };
    RUMOneLogger.prototype.getMarkerTime = function (name) {
        return PerformanceMarker_1.getMarkerTime(name);
    };
    /**
     * Add key expected metric. RUMONeLogger will wait upon these key metrics to be collected
     * before uploading performance data.
     * @param keyMetric
     */
    RUMOneLogger.prototype.addExpectedKeyMetric = function (keyMetric) {
        if (this._keyMetrics && this._keyMetrics.indexOf(keyMetric) <= -1) {
            this._keyMetrics.push(keyMetric);
        }
    };
    Object.defineProperty(RUMOneLogger.prototype, "waitOnAddingExpectedControl", {
        /**
         * If set to true, RUMOnelogger will wait until this is not set false again before concluding all expected controls are added
         * Set it to true if not all expected controls are added
         * Set it to false once all expected controls has been added
         */
        set: function (wait) {
            this._waitOnAddingExpectedControl = wait;
        },
        enumerable: true,
        configurable: true
    });
    RUMOneLogger.prototype._logRUMOneData = function (key, value) {
        if (key) {
            this._rumoneData[key] = value;
        }
    };
    RUMOneLogger.prototype.clearResourceTimings = function () {
        if (performance && performance.clearResourceTimings) {
            performance.clearResourceTimings();
        }
    };
    RUMOneLogger.prototype._isBreakdownValue = function (data) {
        return data.needFlatten !== undefined;
    };
    RUMOneLogger.prototype.collectMarks = function () {
        var _this = this;
        var marks = {};
        var markerIndex = 0;
        this._getOwnMakers().forEach(function (mark) {
            if (markerIndex < _this._config.max_markers) {
                var markName = mark.name.substr(PerformanceMarker_1.MARKER_PREFIX.length) + (".mark" + markerIndex++);
                marks[markName] = Math.round(mark.startTime); // covert to rumone collected marks to object and merge to EUPL Breakdown
            }
        });
        this.writeEUPLBreakdown(JSON.stringify(marks));
    };
    RUMOneLogger.prototype._getOwnMakers = function () {
        var _this = this;
        var markers = RUMOneLogger._markers;
        var markersFromOtherInstances = [].concat.apply([], Object.keys(markers).filter(function (name) {
            return markers.hasOwnProperty(name) && name !== _this._name;
        }).map(function (name) { return markers[name]; }));
        // include markers generated by current rumone instance and all externally created perf markers
        var results = PerformanceMarker_1.getAllMarks().filter(function (mark) { return markersFromOtherInstances.indexOf(mark.name) === -1; });
        return results;
    };
    RUMOneLogger.prototype.logMessageInConsole = function (message) {
        if (this.isRUMOneDebuggingEnabled) {
            console.log(message);
        }
    };
    Object.defineProperty(RUMOneLogger.prototype, "isRUMOneDebuggingEnabled", {
        get: function () {
            try {
                if ('sessionStorage' in window && window.sessionStorage) {
                    var debugStr = window.sessionStorage["enableRUMOneDebugging"];
                    var debug = debugStr && debugStr.toLowerCase() === "true";
                    return debug && typeof console !== "undefined" && !!console;
                }
            }
            catch (e) {
                // sessionStorage errors
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    RUMOneLogger.prototype.logObjectForDebugging = function (propertyName, dictProperties) {
        if (this.isRUMOneDebuggingEnabled) {
            var logMessageText = this._name + " " + propertyName + " : " + JSON.stringify(dictProperties);
            console.log(logMessageText);
        }
    };
    RUMOneLogger.prototype.isCollected = function (name) {
        return !isNullOrUndefined(this.getPerformanceDataPropertyValue(name));
    };
    RUMOneLogger.prototype._normalizeControl = function (control) {
        return typeof control === 'string' ? {
            controlId: control,
            ignoreForEUPL: false
        } : control;
    };
    RUMOneLogger.prototype.setPerfDataTimer = function () {
        this.perfDataTimer = this.async.setTimeout(this.loopForDataCompleteness, this._config.checkInterval);
    };
    RUMOneLogger.prototype.clearPerfDataTimer = function () {
        if (!isNullOrUndefined(this.perfDataTimer)) {
            this.async.clearTimeout(this.perfDataTimer);
            this.perfDataTimer = null;
        }
    };
    RUMOneLogger.prototype._hookUnloadEvent = function () {
        /* tslint:disable:ban-native-functions */
        if (window.addEventListener) {
            window.addEventListener('beforeunload', this._emergencyUpdateFunc);
        }
        /* tslint:enable:ban-native-functions */
    };
    RUMOneLogger.prototype._unhookUnloadEvent = function () {
        /* tslint:disable:ban-native-functions */
        if (window.removeEventListener) {
            window.removeEventListener('beforeunload', this._emergencyUpdateFunc);
        }
        /* tslint:enable:ban-native-functions */
    };
    RUMOneLogger.prototype.categorizeResourceRequests = function (requests, categorizer) {
        var ret = [];
        for (var index = 0; index < requests.length; index++) {
            var request = requests[index];
            if ((!categorizer.from || categorizer.from(request)) && (!categorizer.requestType || categorizer.requestType(request))) {
                ret.push(request);
            }
        }
        return ret;
    };
    RUMOneLogger.prototype.collectSupplementaryData = function () {
        this.setAPIDataToRUMOne();
        this.collectMarks();
        this.writeServerUrl(null);
        this.setBrowseInfo();
        this.setReferrer();
        this._collectMemoryData();
        this._rumoneData.ServerMetrics = JSON.stringify(this.serverMetrics);
        this._rumoneData.EUPLBreakdown = JSON.stringify(this.euplBreakDown);
    };
    RUMOneLogger.prototype.loopForDataCompleteness = function () {
        this.clearPerfDataTimer();
        if (!this._waitOnAddingExpectedControl) {
            if (this.isRUMOneDebuggingEnabled) {
                this.logMessageInConsole("====================================================================");
                this.logObjectForDebugging("RUMONE: ", this._rumoneData);
                this.logObjectForDebugging("RUMOne DataState: ", String(this.getReadableDataState(this.dataState)));
                this.logObjectForDebugging("Controls: ", this.controls);
                this.logObjectForDebugging("API Performance Data: ", this.apis);
                this.logObjectForDebugging("Temp Data: ", this.tempData);
                this.logObjectForDebugging("EUPLBreakdown: ", this.euplBreakDown);
                this.logObjectForDebugging("ServerMetrics: ", this.serverMetrics);
                this.logMessageInConsole("====================================================================\n\n");
            }
            if (!this.isRunning()) {
                return;
            }
            this._updateState();
            if (this.dataState === PerformanceDataState.ReadyToUpload) {
                this.finishPerfDataUpload();
                return;
            }
            this.processControlRenderTime();
            if (this.readyToComputeEUPL()) { // if all expected control data is available, compute EUPL
                this.setEUPL();
                this._updateState();
            }
        }
        // Check timeout
        this._checkTimeout();
        if (this.isRunning()) {
            this.setPerfDataTimer();
        }
    };
    /**
     * Check if we reached ERROR_TIMEOUT without being ready to upload and timeout if so
     */
    RUMOneLogger.prototype._checkTimeout = function () {
        if (!this.isRunning() || this.dataState === PerformanceDataState.ReadyToUpload) {
            return;
        }
        if (Number((new Date()).getTime()) - Number(this.dataStartTime) <= this._config.error_timeout) {
            return; // Nope, we still have time
        }
        // Upload whatever data we have without all key metrics
        this.dataState = PerformanceDataState.TimeOut;
        var error = {
            reason: 'TimeOut',
            details: {
                'MissingMetrics': this._getMissedKeyMetrics(),
                'MissingControls': this._getMissedControls()
            }
        };
        this._rumoneData.RUMOneError = JSON.stringify(error);
        this.finishPerfDataUpload();
    };
    RUMOneLogger.prototype._updateState = function () {
        this.dataState =
            (this._getMissedKeyMetrics().length === 0 && this._getMissedControls().length === 0)
                ? PerformanceDataState.ReadyToUpload
                : PerformanceDataState.Incomplete;
    };
    /**
     * Get array of missing key metrices
     */
    RUMOneLogger.prototype._getMissedKeyMetrics = function () {
        var missedKeyMetrics = [];
        for (var i = 0; i < this._keyMetrics.length; i++) { // check if key metrics are collected
            var keyMetricValue = this.getPerformanceDataPropertyValue(this._keyMetrics[i]);
            if (isNullOrUndefined(keyMetricValue)) {
                missedKeyMetrics.push(this._keyMetrics[i]);
            }
        }
        return missedKeyMetrics;
    };
    /**
     * Get array of controls missing data
     */
    RUMOneLogger.prototype._getMissedControls = function () {
        return this.controls.filter(function (control) { return !control.data || !control.data.renderTime; });
    };
    // since we allow secondary controls reported but not be used to calculate EUPL,
    // these controls might be very slow and we are in higher risky that end user navigates
    // away from this page before we upload our data although EUPL might be available already.
    // This should be hooked with onunload event and resetlogger method
    RUMOneLogger.prototype._emergencyUpload = function () {
        if (this.isRunning() && this._getMissedKeyMetrics().length === 0) {
            this.finishPerfDataUpload(true);
        }
    };
    // if emergency set to true, we will not validate data state in uploadPerfData call
    // since current page is navigating away, mostly likely we already collected key metrics
    // only waiting for secondary controls, we should upload data collected so far
    RUMOneLogger.prototype.finishPerfDataUpload = function (emergency) {
        this.writeControlDataToRUMOne();
        this.collectSupplementaryData();
        try {
            this.uploadPerfData(emergency);
            if (this.isRUMOneDebuggingEnabled) {
                this.logMessageInConsole('Final Data uploaded');
                this.logObjectForDebugging("RUMONE: ", this._rumoneData);
                this.logObjectForDebugging("RUMOne DataState: ", this.getReadableDataState(this.dataState));
            }
        }
        catch (e) {
            (function (errorText) {
                if (typeof console !== "undefined" && Boolean(console)) {
                    console.error(errorText);
                }
            })("PerformanceLogger error writing RUMOne data: " + e);
        }
        finally {
            this._unhookUnloadEvent();
        }
    };
    RUMOneLogger.prototype.getReadableDataState = function (_dataState) {
        for (var key in PerformanceDataState) {
            if (_dataState === Number(PerformanceDataState[key])) {
                return key;
            }
        }
        return 'NaN';
    };
    /**
     * Write Control and corresponding render time for top 10 renderTime controls.
     */
    RUMOneLogger.prototype.writeControlDataToRUMOne = function () {
        if (this.controls && this.controls.length) {
            var byRenderTime = this.controls.slice(0).filter(function (control) { return !!control.data && !!control.data.renderTime && !control.ignoreForEUPL; });
            byRenderTime.sort(function (control1, control2) {
                return control2.data.renderTime - control1.data.renderTime;
            });
            // We have maximum 10 slots for the Control render data collection
            for (var index = 0; index < 10 && index < byRenderTime.length; index++) {
                this._logRUMOneData("Control" + (index + 1) + "Id", byRenderTime[index].controlId);
                this._logRUMOneData("Control" + (index + 1) + "RenderTime", byRenderTime[index].data.renderTime);
            }
            // for secondary controls, we wrote data into EUPL breakdown
            var secondaryControls_1 = {};
            this.controls.slice(0).filter(function (control) { return !!control.data && !!control.data.renderTime && !!control.ignoreForEUPL; }).forEach(function (control) {
                secondaryControls_1[control.controlId] = {
                    data: control.data.renderTime,
                    needFlatten: control.data.needFlatten
                };
            });
            if (Object.keys(secondaryControls_1).length > 0) {
                this.writeEUPLBreakdown(JSON.stringify(secondaryControls_1), true);
            }
        }
    };
    /**
     * Calculate renderTime for the controls ready for it.
     */
    RUMOneLogger.prototype.processControlRenderTime = function () {
        for (var _i = 0, _a = this.controls; _i < _a.length; _i++) {
            var control = _a[_i];
            // if this control is not processed yet and ready to be processed
            if (control.data && !control.data.renderTime && control.data.renderTimeRequiredDataChecker(this, control.data)) {
                control.data.renderTime = control.data.renderTimeCalculator(this, control.data);
            }
        }
    };
    RUMOneLogger.prototype.readyToComputeEUPL = function () {
        var keyControls = this.controls.filter(function (control) { return !control.ignoreForEUPL; });
        var ready = keyControls.length > 0;
        for (var _i = 0, keyControls_1 = keyControls; _i < keyControls_1.length; _i++) {
            var control = keyControls_1[_i];
            if (!control.data || !control.data.renderTime) {
                ready = false;
                break;
            }
        }
        return ready;
    };
    RUMOneLogger.prototype.setEUPL = function () {
        if (!this.isCollected('EUPL')) {
            var eupl = 0;
            for (var _i = 0, _a = this.controls; _i < _a.length; _i++) {
                var control = _a[_i];
                if (!control.ignoreForEUPL && control.data && control.data.renderTime && eupl < control.data.renderTime) {
                    eupl = control.data.renderTime;
                }
            }
            this._rumoneData.EUPL = eupl;
            if (typeof this._EUPLComputedHandler === 'function') {
                this._EUPLComputedHandler(eupl);
            }
        }
    };
    RUMOneLogger.prototype.setBrowseInfo = function () {
        this._rumoneData.Browser = this._platformDetection.browserName + this._platformDetection.browserMajor;
        this._rumoneData.BrowserIsMobile = this._platformDetection.isMobile;
    };
    RUMOneLogger.prototype._collectMemoryData = function () {
        if (!this.isCollected('UsedJSHeapSize') &&
            performance && performance.memory) {
            this._rumoneData.UsedJSHeapSize = performance.memory.usedJSHeapSize;
            this._rumoneData.TotalJSHeapSize = performance.memory.totalJSHeapSize;
        }
    };
    RUMOneLogger.prototype.setAPIDataToRUMOne = function () {
        var calls = 0;
        var durationSum = 0;
        for (var index = 0; index < this.apis.length; index++) {
            var apiData = this.apis[index];
            if (apiData) {
                calls++;
                durationSum += apiData.duration;
                // only take the function part of the API url to avoid cosmos data scrubber
                // url before processing: /teams/SPGroups/_api/web/GetList(@listUrl)/RenderListDataAsStream?Paged=TRUE&p_FileLeafRef=test%2eurl&p_ID=213&PageFirstRow=121&View=6eab4254-2f2f-4086-91c0-549ae900cc93&@listUrl=%27%2Fteams%2FSPGroups%2FVNextDocLib%27"
                // url after processing: RenderListDataAsStream
                apiData.url = apiData.url.split("/").map(function (s) { return s.split("?")[0]; }).slice(-1)[0].replace(/\(.*?\)/g, '()');
            }
        }
        this._rumoneData.APICallCount = calls;
        this._rumoneData.APICallDurationSum = durationSum;
        this._rumoneData.APICalls = JSON.stringify(this.apis);
    };
    RUMOneLogger.prototype.setReferrer = function () {
        this._rumoneData.Referrer = window.document && document.referrer;
    };
    RUMOneLogger.prototype.getW3cTimingName = function (timingName) {
        if (timingName !== 'secureConnectionStart') {
            return 'W3c' + timingName.charAt(0).toUpperCase() + timingName.slice(1);
        }
        else {
            return 'W3cSecureConnectStart'; // to workaround a RUMOne schema issue W3cSecureConnectStart should be W3cSecureConnectionStart
        }
    };
    RUMOneLogger.prototype.uploadPerfData = function (emergency) {
        if (this._excludePageData) {
            this.dataState = PerformanceDataState.Skipped;
            this.logMessageInConsole('Uploading perf data skipped as requested by the consumer');
        }
        else if (!emergency && this.dataState !== PerformanceDataState.ReadyToUpload &&
            this.dataState !== PerformanceDataState.TimeOut) {
            console.error("Error: Uploading perf data called with wrong data state " + this.dataState);
        }
        else if (!this.loggingFunc) {
            console.error('Uploading perf data skipped as loggingFunc is not defined');
        }
        else if (!this._rumoneData) {
            console.error('Error: Uploading perf data called but perf data is not available');
        }
        else {
            this.loggingFunc("RUMOne", this.getPerformanceData());
            this.dataState = PerformanceDataState.Uploaded;
        }
    };
    RUMOneLogger.rumOneLogger = undefined;
    RUMOneLogger.Loggers = {};
    RUMOneLogger._markers = {};
    return RUMOneLogger;
}());
exports.default = RUMOneLogger;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var PlatformDetection_1 = __webpack_require__(81);
exports.default = PlatformDetection_1.PlatformDetection;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:CoverageThreshold(75)
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
tslib_1.__exportStar(__webpack_require__(16), exports);
var Manager_1 = __webpack_require__(16);
exports.default = Manager_1.Manager;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var UriEncoding = /** @class */ (function () {
    function UriEncoding() {
    }
    /////////////////////////////
    // This file is more clean of all unneeded pollutants. It only contains the minimum amount of code required for someone to use the URI class.
    // You should think twice before adding anything else into this file because you will be causing unneeded bloat from someone else.
    /////////////////////////////
    /**
     * This function performs an aggressive unicode URL-encoding.
     * Convert non alphanum character into UTF-8 code string in format %XX%XX%XX.
     *
     * Escape unsafe characters
     *   CTL | SP | <"> | "#" | "%" | "<" | ">" | "'" | "&"
     * in the URL path (before "?", "#")
     * No encoding on query string.
     *
     * @param {string} str - String to encode
     * @param {boolean} bAsUrl - Encode in the same way as the code in unmanaged (Url::UrlEncode) code and
     *                           SP OM (SPHttpUtility.UrlKeyValueEncode and SPHttpUtility.UrlPathEncode).
     * @param {boolean} bForFilterQuery
     * @param {boolean} bForCallback - Only escape the characters after 0x7F to workaround bug O12: 452191
     */
    UriEncoding.encodeURIComponent = function (str, bAsUrl, bForFilterQuery, bForCallback) {
        var strOut = "";
        var strByte;
        var ix = 0;
        var strEscaped = " \"%<>\'&";
        if (!str) { // making this more robust
            return "";
        }
        var len = str.length;
        for (ix = 0; ix < len; ix++) {
            var charCode = str.charCodeAt(ix);
            var curChar = str.charAt(ix);
            if (bAsUrl && (curChar === '#' || curChar === '?')) {
                strOut += str.substr(ix);
                break;
            }
            if (bForFilterQuery && curChar === '&') {
                strOut += curChar;
                continue;
            }
            if (charCode <= 0x7f) {
                if (bForCallback) {
                    strOut += curChar;
                }
                else {
                    if ((charCode >= 97 && charCode <= 122) ||
                        (charCode >= 65 && charCode <= 90) ||
                        (charCode >= 48 && charCode <= 57) ||
                        (bAsUrl && (charCode >= 32 && charCode <= 95) && strEscaped.indexOf(curChar) < 0)) {
                        strOut += curChar;
                    }
                    else if (charCode <= 0x0f) {
                        strOut += "%0" + charCode.toString(16).toUpperCase();
                    }
                    else if (charCode <= 0x7f) {
                        strOut += "%" + charCode.toString(16).toUpperCase();
                    }
                }
            }
            else if (charCode <= 0x07ff) {
                strByte = 0xc0 | (charCode >> 6);
                strOut += "%" + strByte.toString(16).toUpperCase();
                strByte = 0x80 | (charCode & 0x003f);
                strOut += "%" + strByte.toString(16).toUpperCase();
            }
            else if ((charCode & 0xFC00) !== 0xD800) {
                strByte = 0xe0 | (charCode >> 12);
                strOut += "%" + strByte.toString(16).toUpperCase();
                strByte = 0x80 | ((charCode & 0x0fc0) >> 6); // middle 6 bits
                strOut += "%" + strByte.toString(16).toUpperCase();
                strByte = 0x80 | (charCode & 0x003f); // lower 6 bits
                strOut += "%" + strByte.toString(16).toUpperCase();
            }
            else if (ix < str.length - 1) {
                charCode = (charCode & 0x03FF) << 10; // lower 10 bits of first char
                ix++;
                var nextCharCode = str.charCodeAt(ix);
                charCode |= nextCharCode & 0x03FF; // lower 10 bits of second char
                charCode += 0x10000;
                strByte = 0xf0 | (charCode >> 18);
                strOut += "%" + strByte.toString(16).toUpperCase();
                strByte = 0x80 | ((charCode & 0x3f000) >> 12); // upper 6 bits
                strOut += "%" + strByte.toString(16).toUpperCase();
                strByte = 0x80 | ((charCode & 0x0fc0) >> 6); // middle 6 bits
                strOut += "%" + strByte.toString(16).toUpperCase();
                strByte = 0x80 | (charCode & 0x003f); // lower 6 bits
                strOut += "%" + strByte.toString(16).toUpperCase();
            }
        }
        return strOut;
    };
    /**
     * Callbacks do not work if a #bookmark is in the URL. If there is a bookmark then we need to remove it. We also need to
     * deal with the scenario where there is not a bookmark but there is an unencoded # as a part of a name/value after the '?'.
     * This is how things should work here:
     * .../foo.aspx -> .../foo.aspx (unchanged)
     * .../foo.aspx#bookmark -> .../foo.aspx (bookmark is removed)
     * .../foo.aspx#bookmark?name=value -> .../foo.aspx?name=value (bookmark is removed)
     * .../foo.aspx#bookmark?name1=value#extra1&name2=value2 -> .../foo.aspx?name1=value#extra1&name2=value2 (only the bookmark # is removed)
     * .../foo.aspx?name1=value#extra1&name2=value2 -> .../foo.aspx?name1=value#extra1&name2=value2 (unchanged)
     */
    UriEncoding.escapeUrlForCallback = function (str) {
        var iPound = str.indexOf("#");
        var iQues = str.indexOf("?");
        if ((iPound > 0) && ((iQues === -1) || (iPound < iQues))) {
            var strNew = str.substr(0, iPound);
            if (iQues > 0) {
                strNew += str.substr(iQues); // Need to include the '?' along with the "name=value" pairs.
            }
            str = strNew;
        }
        return UriEncoding.encodeURIComponent(str, true, false, true);
    };
    /**
     * SharePoint REST processor expect single quote ' to be escaped to '' in tokens (this applies to %27 too).
     * See example for usage.
     * @example
     * "getFolderByServerRelativeUrl('"+encodeRestUriStringToken("don't know.txt")+"')" should became "getFolderByServerRelativeUrl('don''t know.txt')""
     */
    UriEncoding.encodeRestUriStringToken = function (stringToken) {
        if (stringToken) {
            stringToken = stringToken.replace(/'/g, "''");
            stringToken = stringToken.replace(/%27/g, "%27%27");
            stringToken = UriEncoding.encodeURIComponent(stringToken);
        }
        return stringToken;
    };
    return UriEncoding;
}());
exports.default = UriEncoding;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
// Regex that finds {#} so it can be replaced by the arguments in string format
var FORMAT_REGEX = /\{(\d+)\}/g;
/**
 * String Format is like C# string format. Use template strings instead unless the string is dynamic.
 * Calling format on a string with less arguments than specified in the format will substitute "undefined"
 *
 * @example
 * ```
 * expect("hello {0}!".format("mike")).toEqual("hello mike!")
 * ```
 *
 * @public
 */
function format(template) {
    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
    }
    return template.replace(FORMAT_REGEX, function (match, valueIndex) {
        var value = values[Number(valueIndex)];
        // Checking null for consistency with old behavior, all other values pass through.
        return value === null ? '' : "" + value;
    });
}
exports.format = format;
/**
 * Returns an array made of replacemant values and string literal values, in order.
 * @param template - Base string with replacement tokens.
 * @param values - Array of values to insert into corresponding replacement token.
 *
 * @public
 */
function formatToArray(template) {
    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
    }
    var parts = [];
    var regexResult;
    var lastIndex = 0;
    while ((regexResult = FORMAT_REGEX.exec(template))) {
        // The full string of characters matched.
        var match = regexResult[0];
        // Get replacement value.
        var valueIndex = parseInt(match.replace(/\{|\}+/g, ''), 10);
        var replacementValue = values[valueIndex];
        // Get text between tokens and add to our array.
        if (regexResult.index > lastIndex) {
            parts.push(template.substring(lastIndex, regexResult.index));
        }
        // Save last index.
        lastIndex = FORMAT_REGEX.lastIndex;
        // Add replacement value to our array.
        parts.push(replacementValue);
    }
    // Grab any remaining text after the last match.
    if (lastIndex !== template.length) {
        parts.push(template.substring(lastIndex, template.length));
    }
    return parts;
}
exports.formatToArray = formatToArray;
/**
 * Returns true if s ends with suffix.
 *
 * @public
 */
function doesStringEndWith(s, suffix) {
    return s.substr(s.length - suffix.length) === suffix;
}
exports.doesStringEndWith = doesStringEndWith;
/**
 * Returns true if s starts with prefix.
 *
 * @public
 */
function doesStringStartWith(s, prefix) {
    return s.substr(0, prefix.length) === prefix;
}
exports.doesStringStartWith = doesStringStartWith;
/**
 * Return a string of the given length, using 0s to pad in from the right.
 *
 * @public
 */
function rightPad(data, length) {
    var result = data.toString();
    while (result.length < length) {
        result = result + "0";
    }
    return result;
}
exports.rightPad = rightPad;
/**
 * Return a string of the given length, using 0s to pad in from the left.
 *
 * @public
 */
function leftPad(data, length) {
    var result = data.toString();
    while (result.length < length) {
        result = "0" + result;
    }
    return result;
}
exports.leftPad = leftPad;
/**
 * Look for any of the chars in searchValues in str.
 * Returns the index of the char found or -1 if nothing is found.
 *
 * @public
 */
function findOneOf(str, searchValues) {
    for (var idx = 0; idx < str.length; idx++) {
        if (searchValues.indexOf(str[idx]) >= 0) {
            return idx;
        }
    }
    return -1; // none of the searchValues exist in string
}
exports.findOneOf = findOneOf;
/**
 * Determines if two strings are equal when both converted to uppercase.
 *
 * @public
 */
function equalsCaseInsensitive(a, b) {
    if (a && b) {
        return a.toUpperCase() === b.toUpperCase();
    }
    return a === b;
}
exports.equalsCaseInsensitive = equalsCaseInsensitive;
/**
 * Capitalizes the first letter of str.
 *
 * @public
 */
function capitalize(str) {
    if (str) {
        return str[0].toUpperCase() + str.substr(1);
    }
    return str;
}
exports.capitalize = capitalize;
/**
 * De-capitalizes the first letter of str.
 *
 * @public
 */
function decapitalize(str) {
    if (str) {
        return str[0].toLowerCase() + str.substr(1);
    }
    return str;
}
exports.decapitalize = decapitalize;
/**
 * Selects a string based on plurality.
 *
 * @param count - The value to base selection on
 * @param single - The string to select when it's a singular value
 * @param multiple - The string to select when it's a plural value
 *
 * @deprecated This method does NOT give accurate results for many languages!!
 *             Use getLocalizedCountValue instead.
 *
 * @public
 */
function pluralSelect(count, single, plural) {
    return count === 1 ? single : plural;
}
exports.pluralSelect = pluralSelect;
/**
 * Given a specially formatted localized text, a set of intervals, and a count,
 * return the localized text which corresponds to the first interval the
 * count falls into.
 *
 * Please see https://microsoft.sharepoint.com/teams/OISGPortal/LocKits/Lockit%20Instructions/SharePoint%20Core%20Localization.aspx
 * for more details.
 *
 * @param locText - || deliminated blocks of localized texts, representing
 *  the various singular and plural forms of the string  being localized
 * @param intervals - || deliminated blocks of numeric intervals, defining the ranges
 *  of that interval. Has special support for , * and -.
 * @param count - The count used to determine which interval to return.
 *
 * @returns The localized block which corresponds to the first interval the count falls into.
 *
 * @example
 * StringHelper.getLocalizedCountValue('items||item||items', '0||1||2-', 0)
 *   returns items
 * StringHelper.getLocalizedCountValue('items||item||items', '0||1||2-', 1)
 *   returns item
 * StringHelper.getLocalizedCountValue('items||item||items', '0||1||2-', 2)
 *   returns items
 *
 * @public
 */
function getLocalizedCountValue(locText, intervals, count) {
    var e_1, _a;
    count = Number(count); // defensively make sure count is a number
    // !!!IMPORTANT!!! changes in this function need to be in sync with
    // the methods with the same name located at:
    // otools/inc/sts/stsom/utilities/SPLocUtility.cs
    // sts/Client/Script/Init/LocUtility.cs
    if (locText === undefined || intervals === undefined || count === undefined) {
        return '';
    }
    var ret = '';
    var locIndex = -1;
    var intervalsArray = intervals.split('||');
    for (var i = 0, length_1 = intervalsArray.length; i < length_1; i++) {
        var interval = intervalsArray[i];
        if (!interval) {
            continue;
        }
        var subIntervalsArray = interval.split(',');
        try {
            for (var subIntervalsArray_1 = tslib_1.__values(subIntervalsArray), subIntervalsArray_1_1 = subIntervalsArray_1.next(); !subIntervalsArray_1_1.done; subIntervalsArray_1_1 = subIntervalsArray_1.next()) {
                var subInterval = subIntervalsArray_1_1.value;
                if (!subInterval) {
                    continue;
                }
                // there are three possiblities, wildcard, interval, or number
                if (isNaN(Number(subInterval))) {
                    if (subInterval.indexOf('-') !== -1) {
                        // if it's an interval the format is Number-Number
                        var range = subInterval.split('-');
                        if (range.length !== 2) {
                            continue;
                        }
                        var min = void 0;
                        var max = void 0;
                        if (range[0] === '') {
                            min = 0;
                        }
                        else {
                            if (isNaN(Number(range[0]))) {
                                continue;
                            }
                            else {
                                min = parseInt(range[0], 10);
                            }
                        }
                        if (count >= min) {
                            if (range[1] === '') {
                                locIndex = i;
                                break;
                            }
                            else {
                                if (isNaN(Number(range[1]))) {
                                    continue;
                                }
                                else {
                                    max = parseInt(range[1], 10);
                                }
                            }
                            if (count <= max) {
                                locIndex = i;
                                break;
                            }
                        }
                    }
                    else if (subInterval.indexOf('*') !== -1) {
                        // Wildcard
                        var regexExpr = subInterval.trim().replace(/\*/g, '[0-9]*');
                        var regex = new RegExp("^" + regexExpr + "$");
                        if (regex.test(count.toString())) {
                            locIndex = i;
                            break;
                        }
                    }
                }
                else {
                    var exactNumber = parseInt(subInterval, 10);
                    if (count === exactNumber) {
                        locIndex = i;
                        break;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (subIntervalsArray_1_1 && !subIntervalsArray_1_1.done && (_a = subIntervalsArray_1.return)) _a.call(subIntervalsArray_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (locIndex !== -1) {
            break;
        }
    }
    if (locIndex !== -1) {
        var locValues = locText.split('||');
        if (locValues[locIndex]) {
            ret = locValues[locIndex];
        }
    }
    return ret;
}
exports.getLocalizedCountValue = getLocalizedCountValue;
/**
 * Format the locText with the localized count value.
 *
 * @public
 */
function formatWithLocalizedCountValue(locText, intervals, count) {
    var template = getLocalizedCountValue(locText, intervals, count);
    var result = format(template || '', count.toString());
    return result;
}
exports.formatWithLocalizedCountValue = formatWithLocalizedCountValue;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var FeaturesBasic_1 = __webpack_require__(35);
/**
 * This file contains the known list of features (a.k.a. flights or ramps).
 * The signature of one entry is:
 *  static FeatureName: IFlight = { ODB: 100, ODC: "foo", Fallback: true };
 * ODB            Is the numerical value of the flight from the ExpFeature enumeration.
 *                Omit if the flight does not have a correspondent in ODB.
 * ODC            Is the string identifier in ODC.
 *                Omit if the flight does not have a correspondent ramp in ODC.
 * OneDrive       Is the value of the flight in OneDrive.
 *                Omit if the flight does not have a correspondent ramp in OneDrive.
 * Fallback       The state of the flight, true = on false = off.
 *                The fallback is used only when the ODB or ODC flight is not applicable.
 *                For example: The Flight is an ODB flight with no ODC counterpart and the app runs in ODC mode.
 *                The fallback also allows declaring app only switches that are not known to the backend.
 *                Omit if false.
 */
var Features = /** @class */ (function () {
    function Features() {
    }
    /**
     * Performs the initialization of the client side features for
     * SP and ODB in scenarios where the window['_spPageContextInfo']
     * is not available.
     *
     * @param {number[]} expFeatures - The bit map of the client side features
     * usually provided by the ISPPageContext.
     *
     * @example initSPExpFeatures(pageContextInfo.ExpFeatures)
     */
    Features.initSPExpFeatures = function (expFeatures) {
        Features._expFeatures = expFeatures;
    };
    /**
     * This function will return true when the feature is enabled and
     * will check the proper config for SP,ODB and/or ODC to determine.
     *
     * @requires In scenarios where the window['_spPagecontextInfo'] might not exist
     * this function requires initSPExpFeatures before checing the state of ODB features.
     *
     * @param {IFeature} feature - the feature to be checked if enabled.
     * @return {boolean} - True if the feature is found active.
     */
    Features.isFeatureEnabled = function (feature) {
        var result = !!feature.Fallback;
        // OneDriveWeb initialization
        var oneDrivePageContext = window['PageContext'];
        // ODC initialization
        var _odcFlightInfo = window['Flight'];
        var _odcConfig = window['FilesConfig'];
        // SP/ODB: for backward compatibility,
        // if _spPageContextInfo is still available
        // this performs the initialization of the _expFeatures.
        var _flighting = window['Flighting']; // Old SharePoint pages use this.
        var _spPageContextInfo = window['_spPageContextInfo'];
        if (!Features._expFeatures && _spPageContextInfo) {
            if (!_spPageContextInfo.ExpFeatures &&
                _flighting && _flighting.ExpFeatures) {
                _spPageContextInfo.ExpFeatures = _flighting.ExpFeatures;
            }
            Features.initSPExpFeatures(_spPageContextInfo.ExpFeatures);
        }
        var odb = feature.ODB;
        if (odb && Features._expFeatures) {
            result = FeaturesBasic_1.isSPFeatureEnabled(feature, Features._expFeatures);
        }
        if (feature.ODC && !!_odcConfig) {
            if (typeof feature.ODC === 'boolean') {
                result = feature.ODC;
            }
            else if (_odcFlightInfo && _odcFlightInfo.Ramps && _odcFlightInfo.Ramps[feature.ODC]) {
                result = true;
            }
            else if (_odcConfig && _odcConfig[feature.ODC]) {
                result = true;
            }
        }
        if (feature.OneDrive && !!oneDrivePageContext) {
            result = feature.OneDrive;
        }
        return result;
    };
    /* This feature is always on */
    Features.On = { Fallback: true };
    /* This feature is always off */
    Features.Off = {};
    //You should not add features here but in your own file
    Features._expFeatures = null;
    return Features;
}());
exports.default = Features;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isSPFeatureEnabled(feature, expFeatures) {
    var result = !!feature.Fallback;
    var odb = feature.ODB;
    if (typeof odb === 'boolean') {
        result = odb;
    }
    else if (odb > 0) {
        var elem = Math.floor(odb / 32);
        var mask = 1 << (odb % 32);
        result = (elem < expFeatures.length) &&
            (expFeatures[elem] & mask) !== 0;
    }
    return result;
}
exports.isSPFeatureEnabled = isSPFeatureEnabled;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Disposable_1 = __webpack_require__(37);
/**
 * Lifetime manager for scoping components.
 *
 * @export
 * @class Scope
 * @implements {IDisposable}
 *
 * @example
 *  const scope = new Scope();
 *
 *  let instance = new (scope.attached(MyComponent))();
 *
 *  scope.dispose();
 */
var Scope = /** @class */ (function () {
    /**
     * Creates an instance of Scope.
     */
    function Scope() {
        this._disposables = {};
        this._lastDisposableId = 0;
    }
    /**
     * Produces a constructor for instances of a type which will be bound to the lifetime
     * of this scope.
     *
     * @template T the type of object to be created.
     * @param {T} the original constructor for the type.
     * @returns {T} a new constructor to invoke to create the object.
     */
    Scope.prototype.attached = function (type) {
        var scope = this;
        var Attached = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return scope.attach(type.apply(this, args) || this);
        };
        if (true) {
            // This pattern results in the correct type being displayed in the debugger
            var wrappedConstructor_1 = Attached;
            Attached = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return wrappedConstructor_1.apply(Object.create(type.prototype), args);
            };
        }
        Attached.prototype = type.prototype;
        return Attached;
    };
    Scope.prototype.attach = function (instance) {
        var _this = this;
        var id = "" + ++this._lastDisposableId;
        var disposable = Disposable_1.hook(instance, function () {
            delete _this._disposables[id];
        });
        this._disposables[id] = disposable;
        return disposable;
    };
    /**
     * Disposes this scope and any attached objects.
     */
    Scope.prototype.dispose = function () {
        if (!this.isDisposed) {
            this.isDisposed = true;
        }
        var disposables = this._disposables;
        for (var _i = 0, _a = Object.keys(disposables); _i < _a.length; _i++) {
            var id = _a[_i];
            var disposable = disposables[id];
            if (disposable && Disposable_1.isDisposable(disposable)) {
                disposable.dispose();
            }
            delete disposables[id];
        }
    };
    return Scope;
}());
exports.default = Scope;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DisposalChain = /** @class */ (function () {
    function DisposalChain(owner) {
        this._callbacks = [];
        this._owner = owner;
    }
    DisposalChain.prototype.addCallback = function (callback) {
        this._callbacks.push(callback);
    };
    DisposalChain.prototype.dispose = function () {
        // Handle dispose callbacks is the reverse order from when they were attached.
        while (this._callbacks.length) {
            var callback = this._callbacks.pop();
            callback.call(this._owner);
        }
    };
    return DisposalChain;
}());
/**
 * Determines whether not an object requires is disposable.
 *
 * @export
 * @template T
 * @param {(T | IDisposable)} object
 * @returns {object is IDisposable}
 */
function isDisposable(object) {
    return typeof object.dispose === 'function';
}
exports.isDisposable = isDisposable;
function hook(instance, onDispose) {
    var disposable = instance;
    var dispose = disposable.dispose;
    var disposalChain = typeof dispose === 'function' && dispose.disposalChain;
    if (!disposalChain) {
        disposalChain = new DisposalChain(disposable);
        var disposeHook = (function () {
            disposalChain.dispose();
            if (dispose) {
                // Restore the old dispose method and clean up modifications.
                disposable.dispose = dispose;
                disposable.dispose();
            }
        });
        disposable.dispose = disposeHook;
        disposeHook.disposalChain = disposalChain;
    }
    disposalChain.addCallback(onDispose);
    return disposable;
}
exports.hook = hook;


/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_38__;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_39__;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_40__;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_41__;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(75));
__export(__webpack_require__(105));


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns a copy of the specified object by deeply cloning all of its properties.
 */
function deepCopy(object) {
    var refsCopied = [];
    function copyRecurse(obj) {
        var result = null;
        if (obj) {
            if (Array.isArray(obj)) {
                // @ts-ignore
                result = [];
            }
            else {
                // create clone of the object with same prototype chain
                result = Object.create(Object.getPrototypeOf(obj));
            }
            // iterate over all the properties in the object
            Object.keys(obj).forEach(function (key) {
                // recursively copy the object's properties if the property is an object
                var value = obj[key];
                if (typeof value === 'object') {
                    // @ts-ignore
                    if (refsCopied.indexOf(value) !== -1) {
                        throw new Error("Cannot perform DeepCopy() because a circular reference was encountered, object: " + obj + ", property: " + key);
                    }
                    // @ts-ignore
                    refsCopied.push(value);
                    // @ts-ignore
                    result[key] = copyRecurse(value);
                    refsCopied.pop();
                }
                else {
                    // @ts-ignore
                    result[key] = value;
                }
            });
        }
        return result;
    }
    return copyRecurse(object);
}
exports.deepCopy = deepCopy;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Guid = __webpack_require__(45);
var CorrelationVector = /** @class */ (function () {
    function CorrelationVector(parent, current) {
        if (parent) {
            this.root = parent.root;
            this.parent = parent.current;
        }
        else {
            this.root = this.parent = Guid.Empty;
        }
        if (current) {
            this.current = current;
        }
        else {
            this.current = Guid.generate();
        }
    }
    CorrelationVector._getCorrelationVector = function () {
        var rootVector;
        if (typeof window !== 'undefined') {
            rootVector = window.rootVector;
        }
        else if (typeof self !== 'undefined') {
            rootVector = self.rootVector;
        }
        return rootVector || new CorrelationVector();
    };
    CorrelationVector.prototype.toString = function () {
        return this.root + "#" + this.parent + "#" + this.current;
    };
    CorrelationVector.RootVector = CorrelationVector._getCorrelationVector();
    return CorrelationVector;
}());
exports.CorrelationVector = CorrelationVector;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable:no-bitwise
Object.defineProperty(exports, "__esModule", { value: true });
function generateUuidPart(length) {
    var str = '';
    while (str.length < length) {
        var num = Math.random() * 16;
        num = num | 0; // clear decimal
        str += num.toString(16);
    }
    return str;
}
exports.Empty = '00000000-0000-0000-0000-000000000000';
/**
 * Return a v4 UUID as specified by RFC 4122 http://tools.ietf.org/html/rfc4122
 *
 * @public
 */
function generate() {
    var parts = [];
    parts.push(generateUuidPart(8));
    parts.push(generateUuidPart(4));
    // first digit must be 4 since we are using pseudorandom numbers
    var timeHighAndVersion = '4' + generateUuidPart(3);
    parts.push(timeHighAndVersion);
    // first digit must have first two bits set to 10
    var clockSeqHiAndReserved = generateUuidPart(4);
    // ClockSeqHiAndReserved is a base-16 string.
    var intVal = parseInt(clockSeqHiAndReserved[0], 16);
    intVal = intVal & 3; // clear out first two bits
    intVal = intVal | 8; // set first bit to 1
    clockSeqHiAndReserved = intVal.toString(16) + clockSeqHiAndReserved.substr(1);
    parts.push(clockSeqHiAndReserved);
    parts.push(generateUuidPart(12));
    return parts.join('-');
}
exports.generate = generate;
/**
 * Normalizes a GUID to lowercase. Returns '' if guid is not given.
 * @param includeBrackets - if true, add or keep brackets; if false, strip brackets
 *
 * @public
 */
function normalizeLower(guid, includeBrackets) {
    if (includeBrackets === void 0) { includeBrackets = false; }
    return guid ? _normalizeBrackets(guid.toLowerCase(), includeBrackets) : '';
}
exports.normalizeLower = normalizeLower;
/**
 * Normalizes a GUID to uppercase. Returns '' if guid is not given.
 * @param includeBrackets - if true, add or keep brackets; if false, strip brackets
 *
 * @public
 */
function normalizeUpper(guid, includeBrackets) {
    if (includeBrackets === void 0) { includeBrackets = false; }
    return guid ? _normalizeBrackets(guid.toUpperCase(), includeBrackets) : '';
}
exports.normalizeUpper = normalizeUpper;
/**
 * Normalizes the dashes in a GUID. Returns '' if the input is null, undefined, or does not contain
 * 32 hexadecimal characters.
 * @param guid - The GUID
 * @param includeBrackets - if true, output will contain brackets; if false, output will not
 *
 * @public
 */
function normalizeDashes(guid, includeBrackets) {
    if (includeBrackets === void 0) { includeBrackets = false; }
    if (guid) {
        var parsed = guid.replace(/[^A-Fa-f0-9]/g, '');
        if (parsed.length === 32) {
            return _normalizeBrackets(parsed.slice(0, 8) + "-" + parsed.slice(8, 12) + "-" + parsed.slice(12, 16) + "-" + parsed.slice(16, 20) + "-" + parsed.slice(20), includeBrackets);
        }
    }
    return '';
}
exports.normalizeDashes = normalizeDashes;
function _normalizeBrackets(guid, includeBrackets) {
    var match = guid.match(/^\{(.*)\}$/);
    if (match) {
        return includeBrackets ? match[0] : match[1];
    }
    return includeBrackets ? '{' + guid + '}' : guid;
}


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/**
 * @public
 */
function assign(base, extension) {
    return tslib_1.__assign(base, extension);
}
exports.assign = assign;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventBase_1 = __webpack_require__(8);
/**
 * @public
 */
exports.Engagement = SingleEventBase_1.createSingleEvent({
    eventName: 'Engagement,',
    shortEventName: 'Engagement'
}, {
    name: {
        isKey: true,
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    isIntentional: {
        isPrefixingDisabled: true,
        type: 3 /* Boolean */
    },
    scenario: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    location: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    usageType: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    currentPage: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    previousPage: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    experiment: {
        isPrefixingDisabled: true,
        type: 4 /* Object */
    },
    siteId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    webId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    listId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    groupId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    docId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    webTemplateId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    listTemplateId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    siteType: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    feature: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    component: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    extraData: 4 /* Object */,
    objectType: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    datasource: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    action: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    }
});


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var PairedEventBase_1 = __webpack_require__(49);
var ResultTypeEnum_1 = __webpack_require__(19);
exports.ResultTypeEnum = ResultTypeEnum_1.ResultTypeEnum;
/**
 * @public
 */
exports.Qos = PairedEventBase_1.createPairedEvent({
    eventName: 'Qos,',
    shortEventName: 'Qos'
}, {
    name: {
        isKey: true,
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    startTimeOverride: {
        isPrefixingDisabled: true,
        type: 2 /* Number */
    },
    resultCode: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    resultType: {
        typeRef: ResultTypeEnum_1.ResultTypeEnum,
        isPrefixingDisabled: true,
        type: 6 /* Enum */
    },
    error: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    extraData: 4 /* Object */,
    extraMetrics: {
        isPrefixingDisabled: true,
        type: 4 /* Object */
    }
});


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:CoverageThreshold(75)
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var EventBase_1 = __webpack_require__(11);
var Manager_1 = __webpack_require__(16);
var ResultTypeEnum_1 = __webpack_require__(19);
var ErrorHelper = __webpack_require__(20);
var safeSerialize_1 = __webpack_require__(28);
var schemaExceptionErrorCode = 'GetSchemaException';
var promiseCreationFailureErrorCode = 'PromiseCreationFailed';
var timeoutErrorCode = 'Timeout';
function generateQosResult(resultType, resultCode, error) {
    var schema = {
        resultType: resultType
    };
    if (resultCode) {
        schema.resultCode = resultCode;
    }
    if (error) {
        schema.error = error;
    }
    return schema;
}
var PairedEventBase = /** @class */ (function (_super) {
    tslib_1.__extends(PairedEventBase, _super);
    function PairedEventBase(data, parent) {
        return _super.call(this, data, EventBase_1.ClonedEventType.Start, parent) || this;
    }
    PairedEventBase.instrumentPromise = function (startSchema, createPromise, getCompleteSchema, getErrorSchema, // tslint:disable-line:no-any
    timeoutMs, timeoutSchema, parent) {
        var promise;
        var event = new this(startSchema, parent);
        if (timeoutMs) {
            event.setTimeout(timeoutMs, timeoutSchema);
        }
        var onComplete = function (result) {
            var schema;
            if (getCompleteSchema) {
                try {
                    schema = getCompleteSchema(result);
                }
                catch (e) {
                    schema = generateQosResult(ResultTypeEnum_1.ResultTypeEnum.Failure, schemaExceptionErrorCode, e.toString());
                }
            }
            else {
                schema = generateQosResult(ResultTypeEnum_1.ResultTypeEnum.Success);
            }
            event.end(schema);
        };
        var onError = function (errorArgs) {
            var schema;
            if (getErrorSchema) {
                try {
                    schema = getErrorSchema(errorArgs);
                }
                catch (e) {
                    schema = generateQosResult(ResultTypeEnum_1.ResultTypeEnum.Failure, schemaExceptionErrorCode, e.toString());
                }
            }
            else if (errorArgs) {
                var failureResultType = (errorArgs instanceof Error && errorArgs.name === 'Canceled') ?
                    ResultTypeEnum_1.ResultTypeEnum.ExpectedFailure : ResultTypeEnum_1.ResultTypeEnum.Failure;
                schema = generateQosResult(failureResultType, undefined, safeSerialize_1.safeSerialize(errorArgs));
            }
            else {
                schema = generateQosResult(ResultTypeEnum_1.ResultTypeEnum.Failure);
            }
            event.end(schema);
        };
        try {
            promise = createPromise();
        }
        catch (e) {
            event.end(generateQosResult(ResultTypeEnum_1.ResultTypeEnum.Failure, promiseCreationFailureErrorCode, e.toString()));
            throw e;
        }
        promise.then(onComplete, onError);
        return promise;
    };
    PairedEventBase.prototype.setTimeout = function (ms, data) {
        this._clearTimeout();
        if (!data) {
            data = generateQosResult(ResultTypeEnum_1.ResultTypeEnum.Failure, timeoutErrorCode);
        }
        /* tslint:disable-next-line:ban-native-functions */
        this.timeoutId = window.setTimeout(this.end.bind(this, data), ms);
    };
    PairedEventBase.prototype.verbose = function (message) {
        if (this.endTime) {
            // event already ended, no need to log anymore
            return;
        }
        if (this._isQosEvent()) {
            var qosSchema = this.data;
            ErrorHelper.verbose(message, qosSchema.name);
        }
    };
    PairedEventBase.prototype.end = function (data) {
        // Make sure end can only be called once
        if (!this.endTime) {
            if (data) {
                this._setData(data);
            }
            // Set the end time
            this.endTime = Manager_1.Manager.getTime();
            // Log the event end
            this._logEvent(EventBase_1.ClonedEventType.End);
            // If this is a QOS event log and contains an error message trigger the upload of logs by calling
            // the ErrorHelper
            if (this._isQosEvent()) {
                var qosSchema = this.data;
                if (qosSchema.error) {
                    ErrorHelper.log(qosSchema.error, qosSchema.name, qosSchema.resultCode, qosSchema.resultType);
                }
            }
            this._clearTimeout();
        }
    };
    PairedEventBase.prototype._clearTimeout = function () {
        if (this.timeoutId) {
            /* tslint:disable-next-line:ban-native-functions */
            window.clearTimeout(this.timeoutId);
            this.timeoutId = undefined;
        }
    };
    PairedEventBase.prototype._isQosEvent = function () {
        return this.eventName.indexOf('Qos,') >= 0;
    };
    return PairedEventBase;
}(EventBase_1.EventBase));
function createPairedEvent(props, metadata, baseClass) {
    var PairedEvent = /** @class */ (function (_super) {
        tslib_1.__extends(PairedEvent, _super);
        function PairedEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return PairedEvent;
    }(PairedEventBase));
    EventBase_1.addEventProps(PairedEvent.prototype, props, metadata, baseClass);
    return PairedEvent;
}
exports.createPairedEvent = createPairedEvent;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventBase_1 = __webpack_require__(8);
exports.Trace = SingleEventBase_1.createSingleEvent({
    eventName: 'Trace,',
    shortEventName: 'Trace',
    requiresParent: false
}, {
    message: 1 /* String */
});


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ErrorHelper_1 = __webpack_require__(4);
/**
 * Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled.
 * This Async helper class solves these issues by tying async code to the lifetime of a disposable object.
 *
 * Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a
 * new instance of the class and remember to call dispose() during your code's dispose handler.
 */
function noop() {
    // Do nothing.
}
function logToErrorHelper(error) {
    ErrorHelper_1.default.log(error);
}
var Async = /** @class */ (function () {
    function Async(parent, onError) {
        if (onError === void 0) { onError = logToErrorHelper; }
        this._isDisposed = false;
        this._parent = parent || null;
        this._onErrorHandler = onError;
        this._timeoutIds = null;
        this._immediateIds = null;
        this._animationFrameIds = null;
        this._intervalIds = null;
    }
    /**
     * Dispose function, clears all async operations.
     */
    Async.prototype.dispose = function () {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this._parent = null;
        // Clear timeouts.
        if (this._timeoutIds) {
            for (var _i = 0, _a = Object.keys(this._timeoutIds); _i < _a.length; _i++) {
                var id = _a[_i];
                this.clearTimeout(Number(id));
            }
            this._timeoutIds = null;
        }
        // Clear immediates.
        if (this._immediateIds) {
            for (var _b = 0, _c = Object.keys(this._immediateIds); _b < _c.length; _b++) {
                var id = _c[_b];
                this.clearImmediate(Number(id));
            }
            this._immediateIds = null;
        }
        // Clear intervals.
        if (this._intervalIds) {
            for (var _d = 0, _e = Object.keys(this._intervalIds); _d < _e.length; _d++) {
                var id = _e[_d];
                this.clearInterval(Number(id));
            }
            this._intervalIds = null;
        }
        // Clear animation frames.
        if (this._animationFrameIds) {
            for (var _f = 0, _g = Object.keys(this._animationFrameIds); _f < _g.length; _f++) {
                var id = _g[_f];
                this.cancelAnimationFrame(Number(id));
            }
            this._animationFrameIds = null;
        }
    };
    /**
     * SetTimeout override, which will auto cancel the timeout during dispose.
     * @param callback Callback to execute.
     * @param duration Duration in milliseconds.
     * @return The setTimeout id.
     */
    Async.prototype.setTimeout = function (callback, duration) {
        var _this = this;
        var timeoutId = 0;
        if (!this._isDisposed) {
            var timeoutIds_1 = this._timeoutIds || (this._timeoutIds = {});
            var parent_1 = this._parent;
            /* tslint:disable:ban-native-functions */
            timeoutId = setTimeout(function () {
                // Time to execute the timeout, enqueue it as a foreground task to be executed.
                try {
                    // Now delete the record and call the callback.
                    delete timeoutIds_1[timeoutId];
                    callback.apply(parent_1);
                }
                catch (e) {
                    _this._logError(e);
                }
            }, duration);
            /* tslint:enable:ban-native-functions */
            timeoutIds_1[timeoutId] = true;
        }
        return timeoutId;
    };
    /**
     * Clears the timeout.
     * @param id Id to cancel.
     */
    Async.prototype.clearTimeout = function (id) {
        var timeoutIds = this._timeoutIds;
        if (timeoutIds && timeoutIds[id]) {
            /* tslint:disable:ban-native-functions */
            clearTimeout(id);
            /* tslint:enable:ban-native-functions */
            delete timeoutIds[id];
        }
    };
    /**
     * SetImmediate override, which will auto cancel the immediate during dispose.
     * @param callback Callback to execute.
     * @return The setTimeout id.
     */
    Async.prototype.setImmediate = function (callback) {
        var _this = this;
        var immediateId = 0;
        if (!this._isDisposed) {
            var immediateIds_1 = this._immediateIds || (this._immediateIds = {});
            var parent_2 = this._parent;
            var setImmediateCallback = function () {
                // Time to execute the timeout, enqueue it as a foreground task to be executed.
                try {
                    // Now delete the record and call the callback.
                    delete immediateIds_1[immediateId];
                    callback.apply(parent_2);
                }
                catch (e) {
                    _this._logError(e);
                }
            };
            /* tslint:disable:ban-native-functions */
            immediateId = window.setImmediate ? window.setImmediate(setImmediateCallback) : window.setTimeout(setImmediateCallback, 0);
            /* tslint:enable:ban-native-functions */
            immediateIds_1[immediateId] = true;
        }
        return immediateId;
    };
    /**
     * Clears the immediate.
     * @param id Id to cancel.
     */
    Async.prototype.clearImmediate = function (id) {
        var immediateIds = this._immediateIds;
        if (immediateIds && immediateIds[id]) {
            /* tslint:disable:ban-native-functions */
            window.clearImmediate ? window.clearImmediate(id) : window.clearTimeout(id);
            delete immediateIds[id];
            /* tslint:enable:ban-native-functions */
        }
    };
    /**
     * SetInterval override, which will auto cancel the timeout during dispose.
     * @param callback Callback to execute.
     * @param duration Duration in milliseconds.
     * @return The setTimeout id.
     */
    Async.prototype.setInterval = function (callback, duration) {
        var _this = this;
        var intervalId = 0;
        if (!this._isDisposed) {
            if (!this._intervalIds) {
                this._intervalIds = {};
            }
            var parent_3 = this._parent;
            /* tslint:disable:ban-native-functions */
            intervalId = setInterval(function () {
                // Time to execute the interval callback, enqueue it as a foreground task to be executed.
                try {
                    callback.apply(parent_3);
                }
                catch (e) {
                    _this._logError(e);
                }
            }, duration);
            /* tslint:enable:ban-native-functions */
            this._intervalIds[intervalId] = true;
        }
        return intervalId;
    };
    /**
     * Clears the interval.
     * @param id Id to cancel.
     */
    Async.prototype.clearInterval = function (id) {
        if (this._intervalIds && this._intervalIds[id]) {
            /* tslint:disable:ban-native-functions */
            clearInterval(id);
            delete this._intervalIds[id];
            /* tslint:enable:ban-native-functions */
        }
    };
    /**
     * Creates a function that, when executed, will only call the func function at most once per
     * every wait milliseconds. Provide an options object to indicate that func should be invoked
     * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled
     * function will return the result of the last func call.
     *
     * Note: If leading and trailing options are true func will be called on the trailing edge of
     * the timeout only if the the throttled function is invoked more than once during the wait timeout.
     *
     * @param func The function to throttle.
     * @param wait The number of milliseconds to throttle executions to. Defaults to 0.
     * @param options The options object.
     * @param options.leading Specify execution on the leading edge of the timeout.
     * @param options.trailing Specify execution on the trailing edge of the timeout.
     * @return The new throttled function.
     */
    Async.prototype.throttle = function (func, wait, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this._isDisposed) {
            return noop;
        }
        var waitMS = wait || 0;
        var _a = options.leading, leading = _a === void 0 ? true : _a, _b = options.trailing, trailing = _b === void 0 ? true : _b;
        var lastExecuteTime = 0;
        var lastResult;
        var lastArgs;
        var timeoutId = null;
        var parent = this._parent;
        var callback = function (userCall) {
            var now = (new Date()).getTime();
            var delta = now - lastExecuteTime;
            var waitLength = leading ? waitMS - delta : waitMS;
            if (delta >= waitMS && (!userCall || leading)) {
                lastExecuteTime = now;
                if (timeoutId) {
                    _this.clearTimeout(timeoutId);
                    timeoutId = null;
                }
                lastResult = func.apply(parent, lastArgs);
            }
            else if (timeoutId === null && trailing) {
                timeoutId = _this.setTimeout(callback, waitLength);
            }
            return lastResult;
        };
        var resultFunction = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            lastArgs = args;
            return callback(true);
        };
        return resultFunction;
    };
    /**
     * Creates a function that will delay the execution of func until after wait milliseconds have
     * elapsed since the last time it was invoked. Provide an options object to indicate that func
     * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls
     * to the debounced function will return the result of the last func call.
     *
     * Note: If leading and trailing options are true func will be called on the trailing edge of
     * the timeout only if the the debounced function is invoked more than once during the wait
     * timeout.
     *
     * @param func The function to debounce.
     * @param wait The number of milliseconds to delay.
     * @param options The options object.
     * @param options.leading Specify execution on the leading edge of the timeout.
     * @param options.maxWait The maximum time func is allowed to be delayed before it's called.
     * @param options.trailing Specify execution on the trailing edge of the timeout.
     * @return The new debounced function.
     */
    Async.prototype.debounce = function (func, wait, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this._isDisposed) {
            return noop;
        }
        var waitMS = wait || 0;
        var _a = options.leading, leading = _a === void 0 ? false : _a, _b = options.trailing, trailing = _b === void 0 ? true : _b, _c = options.maxWait, maxWait = _c === void 0 ? NaN : _c;
        var lastCallTime = 0;
        var lastExecuteTime = (new Date()).getTime();
        var lastResult;
        var lastArgs;
        var timeoutId = null;
        var parent = this._parent;
        var callback = function (userCall) {
            var now = (new Date()).getTime();
            var executeImmediately = false;
            if (userCall) {
                if (leading && now - lastCallTime >= waitMS) {
                    executeImmediately = true;
                }
                lastCallTime = now;
            }
            var delta = now - lastCallTime;
            var waitLength = waitMS - delta;
            var maxWaitDelta = now - lastExecuteTime;
            var maxWaitExpired = false;
            if (!isNaN(maxWait)) {
                // maxWait only matters when there is a pending callback
                if (maxWaitDelta >= maxWait && timeoutId) {
                    maxWaitExpired = true;
                }
                else {
                    waitLength = Math.min(waitLength, maxWait - maxWaitDelta);
                }
            }
            if (delta >= waitMS || maxWaitExpired || executeImmediately) {
                if (timeoutId) {
                    _this.clearTimeout(timeoutId);
                    timeoutId = null;
                }
                lastExecuteTime = now;
                lastResult = func.apply(parent, lastArgs);
            }
            else if ((timeoutId === null || !userCall) && trailing) {
                timeoutId = _this.setTimeout(callback, waitLength);
            }
            return lastResult;
        };
        var resultFunction = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            lastArgs = args;
            return callback(true);
        };
        return resultFunction;
    };
    Async.prototype.requestAnimationFrame = function (callback) {
        var _this = this;
        var animationFrameId = 0;
        if (!this._isDisposed) {
            var animationFrameIds_1 = this._animationFrameIds || (this._animationFrameIds = {});
            var parent_4 = this._parent;
            var animationFrameCallback = function () {
                try {
                    // Now delete the record and call the callback.
                    delete animationFrameIds_1[animationFrameId];
                    callback.apply(parent_4);
                }
                catch (e) {
                    _this._logError(e);
                }
            };
            /* tslint:disable:ban-native-functions */
            animationFrameId = window.requestAnimationFrame ? window.requestAnimationFrame(animationFrameCallback) : window.setTimeout(animationFrameCallback, 0);
            /* tslint:enable:ban-native-functions */
            animationFrameIds_1[animationFrameId] = true;
        }
        return animationFrameId;
    };
    Async.prototype.cancelAnimationFrame = function (id) {
        var animationFrameIds = this._animationFrameIds;
        if (animationFrameIds && animationFrameIds[id]) {
            /* tslint:disable:ban-native-functions */
            window.cancelAnimationFrame ? window.cancelAnimationFrame(id) : window.clearTimeout(id);
            /* tslint:enable:ban-native-functions */
            delete animationFrameIds[id];
        }
    };
    Async.prototype._logError = function (e) {
        if (this._onErrorHandler) {
            this._onErrorHandler(e);
        }
    };
    return Async;
}());
exports.default = Async;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// OneDrive:IgnoreCodeCoverage
var PageTransitionType;
(function (PageTransitionType) {
    PageTransitionType[PageTransitionType["none"] = 0] = "none";
    PageTransitionType[PageTransitionType["fullPageLoad"] = 4] = "fullPageLoad";
    PageTransitionType[PageTransitionType["onePageAppNavigation"] = 5] = "onePageAppNavigation";
})(PageTransitionType || (PageTransitionType = {}));
exports.default = PageTransitionType;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventBase_1 = __webpack_require__(5);
exports.RUMOneDataUpload = SingleEventBase_1.createSingleEvent({
    eventName: 'RUMOneDataUpload,',
    shortEventName: 'RUMOneDataUpload'
}, {
    streamName: 1 /* String */,
    dictionary: 4 /* Object */
});
exports.default = exports.RUMOneDataUpload;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var EventBase_1 = __webpack_require__(25);
var Manager_1 = __webpack_require__(31);
var Beacon_event_1 = __webpack_require__(22);
var ErrorHelper_1 = __webpack_require__(4);
var PlatformDetection_1 = __webpack_require__(30);
var DataCompletenessInfo_1 = __webpack_require__(84);
var SimpleUri_1 = __webpack_require__(86);
var AriaTelemetryHandler_1 = __webpack_require__(89);
var Promise_1 = __webpack_require__(12);
var Features_1 = __webpack_require__(34);
var Killswitch_1 = __webpack_require__(13);
var ARIA_QOS_NAME = "AriaBeacon";
var ariaTelemetry;
var initialized = false;
var config = {
    logStartEvents: false,
    Init: init,
    isInitialized: isInitialized
};
var EnableAriaLocalStorage = { ODB: 1355 };
exports.default = config;
function isInitialized(aria) {
    return initialized;
}
function init(tenantToken, context, aria, dependencies) {
    if (dependencies === void 0) { dependencies = {}; }
    var _a = dependencies.platformDetection, platformDetection = _a === void 0 ? new PlatformDetection_1.default() : _a;
    try {
        ariaTelemetry = aria;
        config.logStartEvents = true;
        var loggerContext = {
            AccountType: EventBase_1.AccountType[context.accountType],
            BrowserIsMobile: platformDetection.isMobile,
            BrowserMajVer: platformDetection.browserMajor,
            BrowserMinVer: platformDetection.browserMinor,
            BrowserName: platformDetection.browserName,
            BrowserUserAgent: platformDetection.userAgent,
            Environment: context.environment,
            FarmLabel: context.farmLabel,
            IsAuthenticated: context.isAuthenticated ? 1 : 0,
            Market: context.market,
            Manifest: context.manifest,
            OSName: platformDetection.osName,
            OSVersion: platformDetection.osVersion,
            Session: context.session,
            SiteSubscriptionId: context.siteSubscriptionId || "",
            UserId: context.userId,
            Version: context.version,
            Workload: context.workload,
            SiteId: context.siteId,
            WebId: context.webId,
            WebTemplateId: context.webTemplateId
        };
        if (context.farmLabel) {
            loggerContext.FarmLabel = context.farmLabel;
        }
        var completenessUri_1 = new SimpleUri_1.SimpleUri(context.completenessCallbackEndpoint);
        var completenessContext_1 = {
            telemetryTenantToken: tenantToken,
            appVersion: context.version,
            environment: context.environment,
            workload: context.workload,
            farmLabel: context.farmLabel,
            callbackEndpoint: completenessUri_1
        };
        var enableAriaLocalStorage = platformDetection.isSharePointDesktopApp &&
            !Killswitch_1.Killswitch.isActivated('6B850B5CF-639F-4BFA-8923-2D8376B82197', '2/18/2019', 'Enable Aria Local Storage') &&
            Features_1.default.isFeatureEnabled(EnableAriaLocalStorage);
        var ariaLogConfiguration = {
            enableLocalStorage: enableAriaLocalStorage
        };
        var ariaTelemetryHandler = new AriaTelemetryHandler_1.AriaTelemetryHandler({
            ariaLoader: function () { return Promise_1.default.resolve(ariaTelemetry); },
            context: loggerContext,
            tenantToken: tenantToken,
            disableCookies: context.disableCookies,
            logStartEvents: config.logStartEvents,
            ariaQos: {
                isQosEvent: function (event) {
                    return Beacon_event_1.Beacon.isTypeOf(event) &&
                        !!event.data &&
                        event.data.name === ARIA_QOS_NAME;
                },
                reportQos: function (params) {
                    var isSuccess = params.result, statusCode = params.statusCode, events = params.events;
                    new Beacon_event_1.Beacon({
                        name: ARIA_QOS_NAME,
                        retryCount: 0,
                        totalRetries: 0,
                        eventCount: events ? events.length : 0
                    }).end({
                        success: isSuccess === 0,
                        status: statusCode + ''
                    });
                    if (true) {
                        // Display errors if the aria logger is failing to log
                        if (isSuccess !== 0) {
                            ErrorHelper_1.default.log(new Error("Aria logger failed with status code " + statusCode));
                        }
                    }
                    // If completeness Url is provided, send event to completeness endpoint
                    if (completenessUri_1.authority !== '') {
                        new DataCompletenessInfo_1.DataCompletenessInfo(completenessContext_1, isSuccess, statusCode, new Date().getTime(), events).send();
                    }
                }
            },
            ariaLogConfiguration: ariaLogConfiguration
        });
        ariaTelemetryHandler.attach(Manager_1.Manager);
        initialized = true;
    }
    catch (e) {
        if (e instanceof ariaTelemetry.Exception) {
            e = new Error("Aria error: " + e.toString());
        }
        ErrorHelper_1.default.log(e);
    }
}


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Async_1 = __webpack_require__(51);
var ErrorHelper_1 = __webpack_require__(4);
var ObjectUtil_1 = __webpack_require__(56);
/**
 * Special status values based on states of the XHR instance.
 */
var XHRStatus;
(function (XHRStatus) {
    XHRStatus[XHRStatus["blocked"] = 0] = "blocked";
    XHRStatus[XHRStatus["exception"] = -1] = "exception";
    XHRStatus[XHRStatus["timeout"] = -2] = "timeout";
    XHRStatus[XHRStatus["abort"] = -3] = "abort";
})(XHRStatus = exports.XHRStatus || (exports.XHRStatus = {}));
var XHR = /** @class */ (function () {
    function XHR(options) {
        this._async = new Async_1.default(this);
        var url = options.url, _a = options.requestTimeoutInMS, requestTimeoutInMS = _a === void 0 ? XHR.DEFAULT_TIMEOUT_MS : _a, postData = options.json, _b = options.responseType, responseType = _b === void 0 ? '' : _b, _c = options.headers, headers = _c === void 0 ? {} : _c, _d = options.withCredentials, withCredentials = _d === void 0 ? false : _d, _e = options.needsCors, needsCors = _e === void 0 ? false : _e, progressCallback = options.onProgress, uploadProgressCallback = options.onUploadProgress;
        var _f = options.method, method = _f === void 0 ? postData ? 'POST' : 'GET' : _f;
        this._url = url;
        this._requestTimeoutInMS = requestTimeoutInMS;
        this._postData = postData;
        this._headers = headers;
        this._method = method;
        this._withCredentials = withCredentials;
        this._needsCors = needsCors;
        this._responseType = responseType;
        this._progressCallback = progressCallback;
        this._uploadProgressCallback = uploadProgressCallback;
    }
    XHR.prototype.abort = function (isCancelled) {
        var aborted = this._abortRequest();
        if (aborted && !isCancelled) {
            this._callFailureCallback(this._request, -3 /* abort */, false);
        }
    };
    XHR.prototype.start = function (successCallback, failureCallback) {
        var _this = this;
        this._successCallback = successCallback;
        this._failureCallback = failureCallback;
        var _a = this, method = _a._method, headers = _a._headers;
        try {
            this._request = this._getRequest();
            var _b = this, progressCallback_1 = _b._progressCallback, uploadProgressCallback_1 = _b._uploadProgressCallback, request_1 = _b._request, responseType = _b._responseType;
            if (progressCallback_1) {
                request_1.onprogress = function (event) {
                    try {
                        progressCallback_1(event);
                    }
                    catch (error) {
                        ErrorHelper_1.default.logError(error);
                    }
                };
            }
            if (uploadProgressCallback_1) {
                request_1.upload.onprogress = function (event) {
                    try {
                        uploadProgressCallback_1(event);
                    }
                    catch (error) {
                        ErrorHelper_1.default.logError(error);
                    }
                };
            }
            this._async.setTimeout(function () {
                // Check if we havent logged this event already
                if (!_this._completed) {
                    _this._timeoutCallback();
                }
            }, this._requestTimeoutInMS);
            // Report Qos on the actual qos calls
            request_1.onreadystatechange = function () {
                // Check if we havent logged this event in a timeout
                if (!_this._completed) {
                    var DONE = 4; // Default done readystate
                    try {
                        DONE = request_1.DONE || 4;
                    }
                    catch (e) {
                        // IE 9 will throw here if the request was aborted just swallow this
                    }
                    if (request_1.readyState === DONE) {
                        _this._requestEndCallback();
                    }
                }
            };
            request_1.open(method, this._url, true);
            if ("withCredentials" in request_1) {
                request_1.withCredentials = this._withCredentials;
            }
            // In IE, responseType has to be set after open is called
            request_1.responseType = responseType;
            // Headers have to be set after open is called
            for (var x in headers) {
                request_1.setRequestHeader(x, headers[x]);
            }
            request_1.send(this._postData);
        }
        catch (error) {
            ErrorHelper_1.default.logError(error, {
                origin: location ? location.origin : 'unknown',
                withCredentials: this._withCredentials,
                requestUrl: this._url,
                headers: ObjectUtil_1.safeSerialize(headers),
                method: method
            });
            // abort the request and set the exception status code
            this._abortRequest();
            this._callFailureCallback(this._request, -1 /* exception */, false);
        }
    };
    XHR.prototype._getRequest = function () {
        var _this = this;
        if (!this._needsCors || !window['XDomainRequest']) {
            return new XMLHttpRequest();
        }
        // This is only needed for IE 9 to support CORS requests
        // Note: we can not set headers on XDomainRequest
        var request = new XDomainRequest();
        request.setRequestHeader = function () { };
        request.onprogress = function () { };
        request.ontimeout = function () { };
        request.onload = function () {
            _this._requestEndCallback();
        };
        return request;
    };
    XHR.prototype._abortRequest = function () {
        var actuallyAborted = false;
        if (!this._completed) {
            this._completed = true;
            // Clear the timeout for the request
            this._async.dispose();
            // Cancel the request
            try {
                if (this._request) {
                    this._request.abort();
                }
            }
            catch (error) {
                // IE 9 will throw here if the request was aborted just swallow this
            }
            actuallyAborted = true;
        }
        return actuallyAborted;
    };
    XHR.prototype._timeoutCallback = function () {
        if (!this._completed) {
            this._abortRequest();
            this._callFailureCallback(this._request, -2 /* timeout */, true);
        }
    };
    XHR.prototype._callSuccessCallback = function (xhr, statusCode) {
        try {
            if (this._successCallback) {
                this._successCallback(xhr, statusCode);
            }
        }
        catch (error) {
            ErrorHelper_1.default.log(error);
        }
    };
    XHR.prototype._callFailureCallback = function (xhr, statusCode, timeout) {
        try {
            if (this._failureCallback) {
                this._failureCallback(xhr, statusCode, timeout);
            }
        }
        catch (error) {
            ErrorHelper_1.default.log(error);
        }
    };
    XHR.prototype._requestEndCallback = function () {
        if (!this._completed) {
            this._completed = true;
            var status_1 = -1 /* exception */;
            try {
                // Clear the timeout for the request
                this._async.dispose();
                try {
                    status_1 = this._request.status;
                }
                catch (error) {
                    // IE 9 will throw here if the request was aborted just swallow this
                }
            }
            catch (error) {
                status_1 = -1 /* exception */;
                ErrorHelper_1.default.log(error);
            }
            if (status_1 < 400 && status_1 > 0) {
                this._callSuccessCallback(this._request, status_1);
            }
            else {
                this._callFailureCallback(this._request, status_1, false);
            }
        }
    };
    XHR.DEFAULT_TIMEOUT_MS = 30000;
    return XHR;
}());
exports.default = XHR;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var UriEncoding_1 = __webpack_require__(32);
var deepCopy_1 = __webpack_require__(43);
exports.deepCopy = deepCopy_1.deepCopy;
var deepCompare_1 = __webpack_require__(85);
exports.deepCompare = deepCompare_1.deepCompare;
var safeSerialize_1 = __webpack_require__(28);
exports.safeSerialize = safeSerialize_1.safeSerialize;
var assign_1 = __webpack_require__(46);
exports.extend = assign_1.assign;
exports.DEFAULT_DELIMITER = '&';
exports.KEYVALUE_DELIMITER = '=';
/**
 * Serializes the object Name Values Pairs (Depth of 1).
 * Used for Query Strings and Cookie Values
 * @param {any} obj Object with name value pairs
 * @param {string} delimeter  Delimiter seperates the pairs
 * @param {boolean} skipEncoding True to skip encoding
 */
function serialize(obj, delimiter, skipEncoding) {
    delimiter = delimiter || exports.DEFAULT_DELIMITER;
    var values = Object.keys(obj).map(function (name) {
        // Get the value and convert it to a string
        var value = obj[name];
        value = value ? value.toString() : "";
        if (!skipEncoding) {
            value = UriEncoding_1.default.encodeURIComponent(value);
        }
        // Add the encoded value to the array
        return name + exports.KEYVALUE_DELIMITER + value;
    });
    return values.join(delimiter);
}
exports.serialize = serialize;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// NOTE: This module should have no dependencies!
Object.defineProperty(exports, "__esModule", { value: true });
function isDOMEventTarget(target) {
    return !!target && typeof target.addEventListener === 'function';
}
exports.isDOMEventTarget = isDOMEventTarget;
function isEventTarget(target) {
    return !!target && !!target.__events__;
}
exports.isEventTarget = isEventTarget;
function declare(parent, event) {
    var host = parent;
    var declaredEvents = host.__declaredEvents = host.__declaredEvents || {};
    if (typeof event === 'string') {
        declaredEvents[event] = true;
    }
    else {
        for (var i = 0; i < event.length; i++) {
            declaredEvents[event[i]] = true;
        }
    }
}
exports.declare = declare;
function raise(target, eventName, eventArgs, bubbleEvent) {
    var retVal;
    if (isDOMEventTarget(target)) {
        if (document.createEvent) {
            var ev = document.createEvent('HTMLEvents');
            ev.initEvent(eventName, bubbleEvent, true);
            ev.args = eventArgs;
            retVal = target.dispatchEvent(ev);
        }
    }
    else {
        while (target && retVal !== false) {
            if (isEventTarget(target)) {
                var events = target.__events__;
                var eventRecords = events[eventName];
                for (var id in eventRecords) {
                    var eventRecordList = eventRecords[id];
                    for (var listIndex = 0; retVal !== false && listIndex < eventRecordList.length; listIndex++) {
                        var record = eventRecordList[listIndex];
                        if (record.objectCallback) {
                            retVal = record.objectCallback.call(record.parent, eventArgs);
                        }
                    }
                }
                // If the target has a parent, bubble the event up.
                target = bubbleEvent ? target.parent : null;
            }
            else {
                target = null;
            }
        }
    }
    return retVal;
}
exports.raise = raise;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDataStore_1 = __webpack_require__(9);
var DataStoreCachingType_1 = __webpack_require__(7);
var Manager_1 = __webpack_require__(31);
var LogProcessor_1 = __webpack_require__(59);
var BeaconCache;
(function (BeaconCache) {
    "use strict";
    var _store = new BaseDataStore_1.default(LogProcessor_1.default.STORE_KEY,  true ?
        DataStoreCachingType_1.default.sharedMemory :
        DataStoreCachingType_1.default.session);
    BeaconCache.eventNamePrefix = "";
    BeaconCache.instance = null;
    BeaconCache.handlers = null;
    if (true) {
        try {
            console.log('Beacon: To enable logging to the console for this session, run \'sessionStorage.setItem("enableBeaconLogToConsole", "1")\' in the debug window');
        }
        catch (error) {
            // Ignore errors here. This code path, console.log, is only called during debug and it can throw while
            // debugging or stepping through the code polluting the UI with unhandled errors.
        }
    }
    var OdbBeaconCache = /** @class */ (function () {
        function OdbBeaconCache(eventNamePrefix, handlers) {
            var _this = this;
            BeaconCache.eventNamePrefix = eventNamePrefix;
            BeaconCache.handlers = handlers;
            this._handler = function (event) {
                _this.addEvent(event);
            };
            var bufferedEvents = Manager_1.Manager.addLogHandler(this._handler);
            // Add bufferred events to local store
            for (var x = 0; x < bufferedEvents.length; x++) {
                this.addEvent(bufferedEvents[x]);
            }
        }
        OdbBeaconCache.prototype.dispose = function () {
            Manager_1.Manager.removeLogHandler(this._handler);
        };
        OdbBeaconCache.prototype.addEvent = function (event) {
            if (event.enabled) {
                // put every new event to the session storage so that Sharepoint can upload it for us
                // if user navigates away before Beacon event
                LogProcessor_1.default.processAndLogEvent({
                    event: event,
                    logFunc: function (streamName, dictProperties) {
                        var storeSize = _store.getValue(LogProcessor_1.default.STORE_SIZE_KEY);
                        if (!storeSize) {
                            storeSize = 0;
                        }
                        _store.setValue(storeSize.toString(), { name: streamName, props: dictProperties });
                        _store.setValue(LogProcessor_1.default.STORE_SIZE_KEY, ++storeSize);
                    },
                    eventNamePrefix: BeaconCache.eventNamePrefix,
                    handlers: BeaconCache.handlers
                });
            }
        };
        return OdbBeaconCache;
    }());
    function addToLoggingManager(eventNamePrefix, handlers) {
        if (!BeaconCache.instance) {
            BeaconCache.instance = new OdbBeaconCache(eventNamePrefix, handlers);
        }
        else {
            throw new Error("The beaconCache has already been added to the logging manager with event name prefix " + eventNamePrefix + ".");
        }
    }
    BeaconCache.addToLoggingManager = addToLoggingManager;
})(BeaconCache || (BeaconCache = {}));
exports.default = BeaconCache;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var Qos_event_1 = __webpack_require__(18);
var PLT_event_1 = __webpack_require__(95);
var Beacon_event_1 = __webpack_require__(22);
var UnhandledError_event_1 = __webpack_require__(96);
var RequireJSError_event_1 = __webpack_require__(97);
var CaughtError_event_1 = __webpack_require__(98);
var QosError_event_1 = __webpack_require__(99);
var Verbose_event_1 = __webpack_require__(100);
var Engagement_event_1 = __webpack_require__(17);
var EventBase_1 = __webpack_require__(25);
var RUMOneDataUpload_event_1 = __webpack_require__(53);
var PageInit_event_1 = __webpack_require__(101);
var DebugPriorityLevel_1 = __webpack_require__(102);
var LogProcessor;
(function (LogProcessor) {
    "use strict";
    var _a;
    LogProcessor.STORE_KEY = "SPCacheLogger";
    LogProcessor.STORE_SIZE_KEY = "Size";
    var SOURCE_V2_Engagement = "ClientV2Engagement";
    var DEBUG_LOG_STREAM = "ReliabilityLog";
    var USER_ENGAGEMENT_STREAM = "UserEngagement";
    var SOURCE_V2_Reliability = "ClientV2Reliability";
    // regex for SLAPI event names
    var SLAPI_EVENT_NAME_ALLOW = /[^a-z0-9\.\_\-\+]+/ig;
    var _spModuleLink = window['_spModuleLink'];
    var _appVersion = _spModuleLink ? _spModuleLink.buildNumber : "";
    // these are needed for Engagement and Qos logging
    var pageContext;
    var _siteId;
    var _webId;
    var _listId;
    var _groupId;
    var _isContextInfoInitialized = false;
    function processAndLogEvent(params) {
        var event = params.event, eventNamePrefix = params.eventNamePrefix, handlers = params.handlers, logFunc = params.logFunc;
        // Ignored events
        if (handlers.ignoredEventsHandler && handlers.ignoredEventsHandler(event)) {
            return;
        }
        // read these values from spPageContext and remove {}; in case values are not present set an empty string
        if (!_isContextInfoInitialized) {
            _isContextInfoInitialized = true;
            pageContext = window['_spPageContextInfo'];
            if (pageContext) {
                _siteId = pageContext.siteId ? pageContext.siteId.replace(SLAPI_EVENT_NAME_ALLOW, "") : "";
                _webId = pageContext.webId ? pageContext.webId.replace(SLAPI_EVENT_NAME_ALLOW, "") : "";
                _listId = pageContext.listId ? pageContext.listId.replace(SLAPI_EVENT_NAME_ALLOW, "") : "";
                _groupId = pageContext.groupId ? pageContext.groupId.replace(SLAPI_EVENT_NAME_ALLOW, "") : "";
            }
            else {
                _siteId = "";
                _webId = "";
                _listId = "";
                _groupId = "";
            }
        }
        // Get the data to log
        var logDataArray = Engagement_event_1.Engagement.isTypeOf(event) ? _processEngagementEvent(event) :
            Qos_event_1.Qos.isTypeOf(event) ? _processQosEvent(event, handlers.qosEventNameHandler || null, handlers.qosEventExtraDataHandler || null) :
                PLT_event_1.PLT.isTypeOf(event) ? _processPLTEvent(event) :
                    UnhandledError_event_1.UnhandledError.isTypeOf(event) ? _processUnhandledErrorEvent(event) :
                        RequireJSError_event_1.RequireJSError.isTypeOf(event) ? _processRequireJSErrorEvent(event) :
                            CaughtError_event_1.CaughtError.isTypeOf(event) ? _processCaughtErrorEvent(event) :
                                Verbose_event_1.Verbose.isTypeOf(event) ? _processVerboseEvent(event) :
                                    Beacon_event_1.Beacon.isTypeOf(event) ? _processBeaconEvent(event) :
                                        RUMOneDataUpload_event_1.RUMOneDataUpload.isTypeOf(event) ? _processRUMOneDataUploadEvent(event) :
                                            PageInit_event_1.PageInit.isTypeOf(event) ? _processPageInitEvent(event) :
                                                null;
        // If the log data array is not defined the event was unhandled, log
        // the event name so is easy to discover and fix
        if (!logDataArray) {
            logDataArray = [{
                    userEngagementData: {
                        EngagementName: "UnknownEvent",
                        Duration: 0,
                        LogType: 0,
                        Properties: JSON.stringify({ name: event.eventName }),
                        ClientTime: event.eventType === EventBase_1.ClonedEventType.End ? event.endTime : event.startTime,
                        Source: SOURCE_V2_Engagement
                    }
                }];
        }
        // Log all the data in the array adding the event prefix to the tag/name
        for (var _i = 0, logDataArray_1 = logDataArray; _i < logDataArray_1.length; _i++) {
            var logData = logDataArray_1[_i];
            if (logData.debugData) {
                logData.debugData.Tag = _addEventPrefix(logData.debugData.Tag, eventNamePrefix).replace(SLAPI_EVENT_NAME_ALLOW, "");
                logFunc(DEBUG_LOG_STREAM, logData.debugData);
            }
            if (logData.userEngagementData) {
                // SPList: special case for Engagement events
                // set prefix to the name of the list type
                // to be able to track usage/engagement by list type
                var prefix = eventNamePrefix;
                if (Engagement_event_1.Engagement.isTypeOf(event) && prefix === 'SPList') {
                    // prefix will be set to a list type based on list base template
                    // if list type not found, [refix will be set back to generic SPList
                    prefix = _getScenarioNameFromListType();
                }
                logData.userEngagementData.EngagementName = _addEventPrefix(logData.userEngagementData.EngagementName, prefix)
                    .replace(SLAPI_EVENT_NAME_ALLOW, "");
                // SPList: special case for Qos events; add listBaseTemplate ID to the property bag
                if (Qos_event_1.Qos.isTypeOf(event) && eventNamePrefix === 'SPList') {
                    event.data.extraData["ListBaseTemplate"] = _getListBaseTemplate();
                }
                logFunc(USER_ENGAGEMENT_STREAM, logData.userEngagementData);
            }
            if (logData.rumOneData) {
                logFunc(logData.rumOneData.streamName, logData.rumOneData.dictionary);
            }
        }
    }
    LogProcessor.processAndLogEvent = processAndLogEvent;
    // get the list base template id
    function _getListBaseTemplate() {
        return pageContext ? pageContext.listBaseTemplate : -1;
    }
    var scenarioNames = {
        '100': 'ListNext',
        '101': 'DocsNext',
        '102': 'SurveyNext',
        '103': 'LinksNext',
        '104': 'AnnouncementsNext',
        '107': 'TasksNext',
        '109': 'PicLibNext'
    };
    // get the name of the listType; it's SPList for the unrecognized
    // list templates; TODO: add all templates
    function _getScenarioNameFromListType() {
        var listTemplate = _getListBaseTemplate();
        return scenarioNames[listTemplate] || 'SPList';
    }
    // string examples: "{\"w3cResponseEnd\":2", "\"appStart\":750"
    function _cleanString(dataPLT) {
        var cleanString = dataPLT;
        cleanString = cleanString.replace("{", "");
        cleanString = cleanString.replace(/\"/gi, "");
        cleanString = cleanString.replace("}", "");
        return cleanString;
    }
    function _addEventPrefix(eventName, prefix) {
        if (!prefix) {
            return eventName;
        }
        return prefix + '.' + eventName;
    }
    var resultTypeSuffixes = (_a = {},
        _a[Qos_event_1.ResultTypeEnum.Success] = '.Success',
        _a[Qos_event_1.ResultTypeEnum.Failure] = '.Failure',
        _a[Qos_event_1.ResultTypeEnum.ExpectedFailure] = '.ExpectedFailure',
        _a);
    function _getResultTypeSuffix(resultType) {
        return resultTypeSuffixes[resultType] || '';
    }
    function _processRUMOneDataUploadEvent(event) {
        if (!event.data) {
            return [{
                    userEngagementData: {
                        EngagementName: "RUMOne.no_EventData",
                        Duration: 0,
                        LogType: 0,
                        ClientTime: event.startTime,
                        Source: SOURCE_V2_Engagement
                    }
                }];
        }
        var rumOneDataUpdateEventData = event.data;
        return [{
                rumOneData: {
                    streamName: rumOneDataUpdateEventData.streamName,
                    dictionary: rumOneDataUpdateEventData.dictionary
                }
            }];
    }
    function _processPageInitEvent(event) {
        return [{
                userEngagementData: {
                    EngagementName: "PageInit",
                    Properties: !!event.data ? JSON.stringify(event.data) : '',
                    Duration: 0,
                    LogType: 0,
                    ClientTime: event.startTime,
                    Source: SOURCE_V2_Engagement
                }
            }];
    }
    function _processEngagementEvent(event) {
        var logDataList = [];
        // if the event has not data we will get this in COSMOS
        // if it's a start we have only the name and append ".Start" to it
        // else we look for resultCode and append it to data.name with result type
        // if resultCode is not present than we append only the result type to the name
        // i.e. serverDataGetValue.Start OR serverDataGetValue.ResponseText.GetAuth.ExpectedFailure
        var name = "no_EngagementName";
        var properties = "";
        var siteId = _siteId;
        var webId = _webId;
        var listId = _listId;
        var groupId = _groupId;
        if (event.data) {
            var engagementData = event.data;
            siteId = engagementData.siteId || siteId;
            webId = engagementData.webId || webId;
            listId = engagementData.listId || listId;
            groupId = engagementData.groupId || groupId;
            name = engagementData.name || name;
            // if there is an experimentData object, it means there is an experiment so create and log a new tag for it
            // put all the experiment data in the properties bag;
            if (engagementData.experiment) {
                var abExperiment = engagementData.experiment;
                var experimentData = abExperiment.getExperimentData();
                logDataList.push({
                    userEngagementData: {
                        EngagementName: _getExperimentEventName(experimentData, abExperiment.IsExperimentOn()),
                        Properties: JSON.stringify(experimentData),
                        Duration: 0,
                        LogType: 0,
                        ClientTime: event.startTime,
                        Source: SOURCE_V2_Engagement,
                        SiteId: siteId,
                        WebId: webId,
                        ListId: listId,
                        GroupId: groupId
                    }
                });
            }
            // put the extraData in the properties bag
            properties = engagementData.extraData ? JSON.stringify(engagementData.extraData) : "";
        }
        logDataList.push({
            userEngagementData: {
                EngagementName: name,
                Properties: properties,
                Duration: 0,
                LogType: 0,
                ClientTime: event.startTime,
                Source: SOURCE_V2_Engagement,
                SiteId: siteId,
                WebId: webId,
                ListId: listId,
                GroupId: groupId
            }
        });
        return logDataList;
    }
    function _getExperimentEventName(experimentData, isOn) {
        return (experimentData.name || 'noExperimentData') + ".Experiment" + (isOn ? 'Treatment' : 'Control') + ")";
    }
    function _processQosEvent(event, qoSEventNameHandler, qosEventExtraDataHandler) {
        var logData = {};
        // if the event has not data we will get this in COSMOS
        // if it's a start we have only the name and append ".Start" to it
        // else we look for resultCode and append it to data.name with result type
        // if resultCode is not present than we append only the result type to the name
        // i.e. serverDataGetValue.ResponseText.Success OR serverDataGetValue.ResponseText.GetAuth.ExpectedFailure
        var name = "no_QosName";
        var qosData = event.data || null;
        if (qosData) {
            if (qosData.name) {
                name = qosData.name;
            }
            if (qoSEventNameHandler) {
                name = qoSEventNameHandler(event, name);
            }
            qosData.extraData = qosData.extraData || {};
            if (qosEventExtraDataHandler) {
                qosEventExtraDataHandler(event, qosData);
            }
            qosData.extraData["appver"] = _appVersion;
        }
        // Duration is calculated only when we have an END event
        var durationTime = 0;
        if (event.eventType === EventBase_1.ClonedEventType.End && event.startTime && event.endTime) {
            durationTime = event.endTime - event.startTime;
        }
        logData.userEngagementData = {
            EngagementName: name,
            Properties: qosData && qosData.extraData ? JSON.stringify(qosData.extraData) : "",
            Duration: durationTime,
            LogType: 0,
            ClientTime: event.eventType === EventBase_1.ClonedEventType.End ? event.endTime : event.startTime,
            Source: SOURCE_V2_Reliability
        };
        return [logData];
    }
    function _processBeaconEvent(event) {
        var logData = {};
        var durationTime = 0;
        if (event.eventType === EventBase_1.ClonedEventType.End && event.startTime && event.endTime) {
            durationTime = event.endTime - event.startTime;
        }
        logData.userEngagementData = {
            EngagementName: "Beacon",
            Properties: event.data ? JSON.stringify(event.data) : "no_EventData",
            Duration: durationTime,
            LogType: 0,
            ClientTime: event.eventType === EventBase_1.ClonedEventType.End ? event.endTime : event.startTime,
            Source: SOURCE_V2_Reliability
        };
        return [logData];
    }
    function _processPLTEvent(event) {
        if (!event.data) {
            return [{
                    userEngagementData: {
                        EngagementName: "PLT.no_EventData",
                        Duration: 0,
                        LogType: 0,
                        ClientTime: event.startTime,
                        Source: SOURCE_V2_Engagement
                    }
                }];
        }
        var logDataList = [];
        //get the data for this event
        var pltData = event.data;
        // this will be the prefix for the tags; i.e. PLT.SetView-Files.w3cResponseEnd
        var name = "PLT." + pltData.name.replace(" ", "");
        // break down the PLT data and log each one as a separate record in the stream
        //{"name":"SetView-Files","w3cResponseEnd":424,"appStart":254,"preRender":20,"dataFetch":310,"postRender":327,"render":347,"plt":1335}
        var dataPLT = JSON.stringify(pltData).split(',');
        var duration = 0;
        // iterate through data and extract each type
        // create tags like this: PLT.<pagename>.w3cResponseEnd; PLT.<pagename>.appStart
        for (var i = 0; i < dataPLT.length; i++) {
            var cleanedPLTString = _cleanString(dataPLT[i]);
            // split the string and get the name and duration
            // special case for duration when appCacheHit is a boolean
            var subDataPLTs = cleanedPLTString.split(':');
            // skip the 'name' key-value pair
            if (_cleanString(subDataPLTs[1]) !== pltData.name) {
                if (subDataPLTs[1] === 'true') {
                    duration = 1;
                }
                else if (subDataPLTs[1] === 'false' || subDataPLTs[1] === 'null') {
                    duration = 0;
                }
                else {
                    duration = parseInt(subDataPLTs[1], 10);
                }
                logDataList.push({
                    userEngagementData: {
                        EngagementName: name + "." + subDataPLTs[0],
                        Properties: (subDataPLTs[0] === 'appCacheHit') ? JSON.stringify(event.data) : "",
                        Duration: duration,
                        LogType: 0,
                        ClientTime: event.startTime,
                        Source: SOURCE_V2_Engagement
                    }
                });
            }
        }
        return logDataList;
    }
    function _processUnhandledErrorEvent(event) {
        return [{
                userEngagementData: {
                    EngagementName: "UnhandledError",
                    Duration: 0,
                    LogType: 0,
                    ClientTime: event.startTime,
                    Source: SOURCE_V2_Engagement
                },
                debugData: {
                    Tag: "UnhandledError",
                    Level: DebugPriorityLevel_1.default.Normal,
                    Message: event.data ? JSON.stringify(event.data) : "no_EventData",
                    Misc: "",
                    ClientTime: event.startTime
                }
            }];
    }
    function _processRequireJSErrorEvent(event) {
        var logData = {};
        var name = "RequireJSError";
        var errorData;
        var errorMessage;
        if (event.data) {
            // clone all properties so that we can omit 'message' in JSON
            errorData = {};
            for (var key in event.data) {
                if (key !== "message") {
                    errorData[key] = event.data[key];
                }
                else {
                    errorMessage = event.data[key];
                }
            }
        }
        logData.userEngagementData = {
            EngagementName: name,
            Duration: 0,
            LogType: 0,
            ClientTime: event.startTime,
            Source: SOURCE_V2_Engagement
        };
        logData.debugData = {
            Tag: name,
            Level: DebugPriorityLevel_1.default.Normal,
            Message: errorMessage || "no_ErrorMessage",
            Misc: errorData ? JSON.stringify(errorData) : "no_ErrorData",
            ClientTime: event.startTime
        };
        return [logData];
    }
    function _processCaughtErrorEvent(event) {
        var logData = {};
        var name = "CaughtError";
        if (QosError_event_1.QosError.isTypeOf(event)) {
            if (event.data) {
                var qosErrorData = event.data;
                name = qosErrorData.name;
                if (qosErrorData.resultCode) {
                    name += "." + qosErrorData.resultCode;
                }
                name += _getResultTypeSuffix(qosErrorData.resultType);
            }
            else {
                name = "QosErrorEvent.no_EventData";
            }
        }
        else {
            // log it once in the UserEngagement stream to count the hits
            logData.userEngagementData = {
                EngagementName: name,
                Duration: 0,
                LogType: 0,
                ClientTime: event.startTime,
                Source: SOURCE_V2_Engagement
            };
        }
        // log it again in ReliabilityLog stream with data for debugging
        var caughtErrorData = event.data || null;
        logData.debugData = {
            Tag: name,
            Level: DebugPriorityLevel_1.default.Normal,
            Message: caughtErrorData && caughtErrorData.message || "",
            Misc: caughtErrorData && caughtErrorData.stack ? JSON.stringify(caughtErrorData.stack) : "",
            ClientTime: event.startTime
        };
        return [logData];
    }
    function _processVerboseEvent(event) {
        var logData = {};
        var name = "Verbose";
        if (event.data) {
            var verboseData = event.data;
            if (verboseData.name) {
                name = verboseData.name + ".Verbose";
            }
        }
        else {
            name += ".no_EventData";
        }
        // log it in ReliabilityLog stream with data for debugging
        logData.debugData = {
            Tag: name,
            Level: DebugPriorityLevel_1.default.Low,
            Message: verboseData.message,
            Misc: "",
            ClientTime: event.startTime
        };
        return [logData];
    }
})(LogProcessor || (LogProcessor = {}));
exports.default = LogProcessor;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Locale_1 = __webpack_require__(61);
tslib_1.__exportStar(__webpack_require__(33), exports);
function getLocaleNumberString(number, options, defaultValue) {
    var result = defaultValue;
    var lang = Locale_1.default.language;
    if (number) {
        try {
            result = number.toLocaleString(lang, options);
        }
        catch (e) {
            // in case 'lang' is invalid for browser, fallback to let browser use own logic for determining language
            result = number.toLocaleString([], options);
        }
    }
    return result;
}
exports.getLocaleNumberString = getLocaleNumberString;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var Locale = /** @class */ (function () {
    function Locale() {
    }
    /**
     * Sets the locale to be used by the app.
     * @param {string} language - The language used to render the app.
     */
    Locale.invalidate = function (language) {
        if (typeof window === 'undefined') {
            return; // This check has been added if the code is being executed in service worker.
        }
        Locale.isRightToLeft = (window.document && document.documentElement.getAttribute('dir') === 'rtl');
        Locale.safeLeft = Locale.isRightToLeft ? 'right' : 'left';
        Locale.safeRight = Locale.isRightToLeft ? 'left' : 'right';
        /** Robert Chen has the detailed explanation here : The most magic thing here is that OneDrive page and teamsite page has exactly the same line of code with regard to html tag Lang attribute.
         * <SharePoint:SPHtmlTag lang="<%$Resources:wss,language_value%>" dir="<%$Resources:wss,multipages_direction_dir_value%>" ID="SPHtmlTag" runat="server">
         * And in teamsite doclib, this lang gets executed to the current user locale. And that is actually already a magic------What happens here is the in order to get the doclib page in ContentDB, we had a standard MondoSproc call which gets the page and the SPWeb. In constructing the web, SP *  * code has smart logic to set Thread.CurrentThread.CurrentUICulture to match the MUI language! And with that magic, ="<%$Resources:wss,language_value%> actually gets sets properly to the user language, not the pre-defined web language.
         * For OneDrive.aspx which lives inside _layouts folder, the order of code execution changes. We must have executed this line of ASPX code first ="<%$Resources:wss,language_value%> before SPWeb was opened and did the magic to set Thread.CurrentThread.CurrentUICulture.
         * So the Thread.CurrentThread.CurrentUICulture affecting ="<%$Resources:wss,language_value%> with SPWeb magic end up not working in Onedrive.aspx! And theres really nothing that we can do about it unless we rewrite the page!
         * So the conclusion is that the lang attribute is by design (of implementation) different from the regular team site pages which live inside content db.
         */
        language = language || window["_spPageContextInfo"] && window["_spPageContextInfo"].currentUICultureName;
        // fallback of xml:lang for IE9
        Locale.language = language || (window.document &&
            (document.documentElement.getAttribute('lang') ||
                document.documentElement.getAttribute('xml:lang'))) ||
            'en-us';
    };
    return Locale;
}());
Locale.invalidate();
exports.default = Locale;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ObjectUtil_1 = __webpack_require__(56);
var StringHelper_1 = __webpack_require__(60);
var UriPartial;
(function (UriPartial) {
    /** The scheme segment of the URI */
    UriPartial[UriPartial["scheme"] = 0] = "scheme";
    /** The scheme and authority segments of the URI */
    UriPartial[UriPartial["authority"] = 1] = "authority";
    /** The scheme, authority, and path segments of the URI */
    UriPartial[UriPartial["path"] = 2] = "path";
    /** The scheme, authority, path, and query segments of the URI */
    UriPartial[UriPartial["query"] = 3] = "query";
})(UriPartial = exports.UriPartial || (exports.UriPartial = {}));
var DELIMITERS = /[;\/?:@&=$,]/;
var AUTHORITY_TERMINATORS = /[\/?]/;
function queryToLower(queryObj) {
    var newQuery = {};
    for (var key in queryObj) {
        if (queryObj.hasOwnProperty(key)) {
            newQuery[key.toLowerCase()] = queryObj[key].toLowerCase();
        }
    }
    return newQuery;
}
/**
 * Partial port of groove\Misc\URI.cpp, which was based on RFC2396 and RFC3986 (http://www.ietf.org/rfc/rfc2396.txt).
 * There are a few differences between this implementation and the RFC:
 *  - Implementation does not support parameters (we don't use them, and partial implementation was incorrect)
 *  - Implementation supports some relative URIs at a glance but more investigation required
 *
 *   foo://example.com:8042/over/there?name=ferret#nose
 *   \_/   \______________/\_________/ \_________/ \__/
 *    |           |            |            |        |
 * scheme     authority       path        query   fragment
 *
 * Possible improvements:
 *  - Support path parameters
 *  - Fully support and test relative URLs based on RFC
 *  - Allow changing/removing remaining URI components (i.e. user, host, port, parameters)
 *  - URI.equals could allow ?foo=1&bar=2 equals ?bar=2&foo=1
 *  - URI.parseURI should have better error handling rather than just setting it as path
 *  - URI.getQueryAsObject should have better error handling for query of "a=1&a=2"
 */
var Uri = /** @class */ (function () {
    function Uri(uriString, options) {
        // All of these are decoded (if relevant) unless specified as encoded.
        this._scheme = "";
        this._user = "";
        this._host = "";
        this._port = "";
        this._path = "";
        this._pathSegments = [];
        this._pathEncoded = "";
        this._query = {};
        this._fragment = "";
        if (options) {
            this._queryCaseInsensitive = !!options.queryCaseInsensitive;
            this._pathCaseInsensitive = !!options.pathCaseInsensitive;
        }
        this._parseURI(uriString);
    }
    Uri.concatenate = function () {
        var uriParts = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            uriParts[_i] = arguments[_i];
        }
        var result = '';
        for (var i = 0; i < uriParts.length; i++) {
            var part = uriParts[i];
            if (i > 0) {
                part = Uri.ensureNoPrecedingSlash(part);
            }
            if (i < uriParts.length - 1) {
                part = Uri.ensureTrailingSlash(part);
            }
            result += part;
        }
        return result;
    };
    Uri.ensureNoPrecedingSlash = function (part) {
        return part[0] === "/" ? part.substr(1) : part;
    };
    Uri.ensureTrailingSlash = function (part) {
        return part[part.length - 1] !== "/" ? (part + "/") : part;
    };
    Uri.prototype.getScheme = function () {
        return this._scheme;
    };
    Uri.prototype.setScheme = function (scheme) {
        this._scheme = scheme;
    };
    Uri.prototype.getAuthority = function () {
        return this._getAuthority(false);
    };
    Uri.prototype.setAuthority = function (authority) {
        this._parseAuthority(authority);
    };
    Uri.prototype.getUser = function () {
        return this._user;
    };
    Uri.prototype.getHost = function () {
        return this._host;
    };
    Uri.prototype.getPort = function () {
        return this._port;
    };
    Uri.prototype.getPath = function (trimTrailingSlash) {
        var retPath = this._path;
        if (Boolean(trimTrailingSlash)) {
            // If the last character is a slash
            if (retPath !== null && retPath.lastIndexOf("/") === (retPath.length - 1)) {
                retPath = retPath.slice(0, -1); //trim last character
            }
        }
        return retPath;
    };
    /**
     * Returns a string containing the leftmost portion of the URI string, ending with the portion specified by part
     */
    Uri.prototype.getLeftPart = function (part) {
        var ret = this._scheme + "://"; // default value is UriPartial.scheme
        if (part === UriPartial.authority) {
            ret += this.getAuthority();
        }
        if (part === UriPartial.path) {
            ret += this.getPath();
        }
        if (part === UriPartial.query) {
            ret += this.getQuery();
        }
        return ret;
    };
    Uri.prototype.setPath = function (path) {
        if (path && path[0] !== "/") {
            path = "/" + path;
        }
        this._parsePath(path);
    };
    Uri.prototype.getPathSegments = function () {
        return this._pathSegments;
    };
    Uri.prototype.getLastPathSegment = function () {
        var pathSegments = this._pathSegments;
        return pathSegments[pathSegments.length - 1] || "";
    };
    Uri.prototype.getQuery = function (encoded) {
        return this._serializeQuery(encoded);
    };
    /**
     * Query is not well-defined but is commonly formatted as key=value and delimited with & or ;
     * (http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.2.2)
     *  - URI with query "a=1&b=2" or "a=1;b=2" will return {a: "1", b: "2"}
     *  - Mixed-mode will also work: "a=1&b=2;c=3" will return {a: "1", b: "2", c: "3"}
     *  - Assumes that parameters will be unique (i.e. "a=1&a=2" is not allowed and will produce unexpected results)
     */
    Uri.prototype.setQuery = function (query) {
        this.setQueryFromObject(this._deserializeQuery(query));
    };
    Uri.prototype.getQueryAsObject = function () {
        return this._query;
    };
    Uri.prototype.setQueryFromObject = function (queryObj) {
        this._query = {};
        for (var queryKey in queryObj) {
            if (queryObj.hasOwnProperty(queryKey)) {
                this.setQueryParameter(queryKey, queryObj[queryKey]);
            }
        }
    };
    Uri.prototype.getQueryParameter = function (queryKey) {
        var ret = null;
        var query = this._query;
        if (this._queryCaseInsensitive) {
            queryKey = queryKey.toLowerCase();
            for (var key in query) {
                if (query.hasOwnProperty(key) && key.toLowerCase() === queryKey) {
                    ret = query[key];
                }
            }
        }
        else {
            ret = query[queryKey];
        }
        return ret || null;
    };
    /**
     * Adds query parameter to the end if queryKey does not exist, or
     * overwrites existing query value if queryKey already exists.
     */
    Uri.prototype.setQueryParameter = function (queryKey, queryValue, ignoreEmptyValues) {
        if (ignoreEmptyValues === void 0) { ignoreEmptyValues = true; }
        var queryValueDecoded = this._decodeQueryString(queryValue);
        // there is no point adding undefined or modifying existing values to undefined or null.
        if (!!queryValueDecoded || ignoreEmptyValues) {
            this._query[this._decodeQueryString(queryKey)] = queryValueDecoded;
        }
    };
    Uri.prototype.removeQueryParameter = function (queryKey) {
        delete this._query[this._decodeQueryString(queryKey)];
    };
    Uri.prototype.getFragment = function () {
        return this._fragment;
    };
    Uri.prototype.setFragment = function (fragment) {
        if (fragment[0] === "#") {
            fragment = fragment.substring(1);
        }
        // Treat the fragment as a query string (decode + as space) because we pass in
        // query parameters using the fragment on page load.
        this._fragment = this._decodeQueryString(fragment);
    };
    /**
     * Does a strict equality check of URIs (including same query parameters
     * in the same order, and most comparisons case-sensitive).
     * According to RFC3986: scheme and host should be case-insensitive.
     * Note: This does not follow RFC2616's URI Comparison since it is not HTTP-specific.
     *
     * KNOWN ISSUE: Depending on your definition of "incorrect," this could return
     * incorrect results for URI parts that get decoded.
     * For example: http://somewhere/my%2fpath and http://somewhere/my/path
     * will compare as equal because the comparisons are done to decoded versions.
     */
    Uri.prototype.equals = function (uri) {
        return StringHelper_1.equalsCaseInsensitive(this._scheme, uri.getScheme()) &&
            this._user === uri.getUser() &&
            StringHelper_1.equalsCaseInsensitive(this._host, uri.getHost()) &&
            this._port === uri.getPort() &&
            this._fragment === uri.getFragment() &&
            this._equalsCaseAppropriate(this.getPath(/*trimTrailingSlash*/ true), uri.getPath(true), this._pathCaseInsensitive) &&
            this._equalsCaseAppropriate(this.getQuery(), uri.getQuery(), this._queryCaseInsensitive);
    };
    /**
     * Does an equivalence check of two URIs. Checks to see if the URIs are
     * equivalent, but they may not be exact! Strings are compared case
     * insensitive and query parameters can be in any order.
     *
     * KNOWN ISSUE: Depending on your definition of "incorrect," this could return
     * incorrect results for URI parts that get decoded.
     * For example: http://somewhere/my%2fpath and http://somewhere/my/path
     * will compare as equal because the comparisons are done to decoded versions.
     */
    Uri.prototype.equivalent = function (uri) {
        return StringHelper_1.equalsCaseInsensitive(this._scheme, uri.getScheme()) &&
            StringHelper_1.equalsCaseInsensitive(this._user, uri.getUser()) &&
            StringHelper_1.equalsCaseInsensitive(this._host, uri.getHost()) &&
            StringHelper_1.equalsCaseInsensitive(this._port, uri.getPort()) &&
            StringHelper_1.equalsCaseInsensitive(this.getPath(/*trimTrailingSlash*/ true), uri.getPath(true)) &&
            ObjectUtil_1.deepCompare(queryToLower(this.getQueryAsObject()), queryToLower(uri.getQueryAsObject())) &&
            StringHelper_1.equalsCaseInsensitive(this._fragment, uri.getFragment());
    };
    /**
     * Note that this returns the URL encoded/escaped while the getXXX() methods
     * for the individual components return the unescaped strings. Returning a
     * concatenation of the decoded components would change the semantics of the
     * URL. See section 2.4.2 of RFC 2396 (http://www.ietf.org/rfc/rfc2396.txt).
     *
     * Use doNotPercentEncodeHost to indicate that the output should not have a
     * percent-encoded host, such as when passing to the url parameter of
     * XmlHttpRequest.open(). Section 3.2.2 of RFC 2396 only allows alphanumeric
     * characters and hyphen in the host of a URL, so percent-encoded hosts are
     * not allowed. While section 3.2.2 of RFC 3986 does not restrict the host
     * character set anymore, not all browsers can handle a percent-encoded host
     * - DNS lookup fails.  But, they will convert the unencoded Unicode to the
     * IDNA encoding (punycode), so leaving the host as-is in this case is preferred.
     */
    Uri.prototype.toString = function (outputOptions) {
        return this._getStringInternal(/*encoded*/ true, outputOptions);
    };
    /**
     * This method should be used to obtain a string for display purposes only,
     * because as mentioned above, a decoded URL may have different semantics than
     * the encoded version.
     */
    Uri.prototype.getDecodedStringForDisplay = function () {
        return this._getStringInternal(/*encoded*/ false);
    };
    /*
     * Input URI of "foo://user:pass@host.com/alpha/beta/gamma/delta;p;a;r;a;m;s?q=1&u=2&e=3&r=4&y=5#fragment"
     * would return "foo://user:pass@host.com/alpha/beta/gamma/delta;p;a;r;a;m;s";
     */
    Uri.prototype.getStringWithoutQueryAndFragment = function () {
        return this._getStringWithoutQueryAndFragmentInternal(/*encoded=*/ true);
    };
    Uri.prototype._equalsCaseAppropriate = function (a, b, isCaseInsensitive) {
        if (isCaseInsensitive) {
            return StringHelper_1.equalsCaseInsensitive(a, b);
        }
        return a === b;
    };
    Uri.prototype._getStringInternal = function (encoded, outputOptions) {
        var ret = this._getStringWithoutQueryAndFragmentInternal(encoded, outputOptions);
        var query = this.getQuery(encoded);
        if (query) {
            ret += "?" + query;
        }
        if (this._fragment) {
            ret += "#" + (encoded ? encodeURIComponent(this._fragment) : this._fragment);
        }
        return ret;
    };
    Uri.prototype._getStringWithoutQueryAndFragmentInternal = function (encoded, outputOptions) {
        var ret = "";
        if (this._scheme) {
            ret += (encoded ? encodeURIComponent(this._scheme) : this._scheme) + ":";
        }
        // Authority includes user, host, and port
        var authority = this._getAuthority(/*encoded=*/ encoded, outputOptions);
        if (authority) {
            ret += "//" + authority;
        }
        if (this._pathEncoded) {
            ret += (encoded ? this._pathEncoded : this._path);
        }
        return ret;
    };
    Uri.prototype._deserializeQuery = function (queryStr) {
        var queryObj = {};
        if (queryStr.indexOf("?") === 0) {
            queryStr = queryStr.substring(1);
        }
        for (var _i = 0, _a = queryStr.split(/[;&]+/); _i < _a.length; _i++) {
            var queryPart = _a[_i];
            var keyEndIndex = queryPart.indexOf('=');
            // "foo" is a legal query string equivalent to "foo="
            if (keyEndIndex < 0) {
                keyEndIndex = queryPart.length;
            }
            if (keyEndIndex > 0) {
                queryObj[queryPart.substr(0, keyEndIndex)] = queryPart.substr(keyEndIndex + 1);
            }
        }
        return queryObj;
    };
    Uri.prototype._serializeQuery = function (encoded) {
        var queryStr = "";
        for (var queryKey in this._query) {
            if (this._query.hasOwnProperty(queryKey)) {
                var key = queryKey;
                var value = this._query[queryKey];
                if (encoded) {
                    key = encodeURIComponent(key);
                    value = encodeURIComponent(value);
                }
                if (value === null || value === "") {
                    queryStr += key + "=&";
                }
                else {
                    queryStr += key + "=" + value + "&";
                }
            }
        }
        if (queryStr !== "") {
            queryStr = queryStr.slice(0, -1); //trim extra & at the end
        }
        return queryStr;
    };
    Uri.prototype._parseURI = function (uriString) {
        var remainingString = uriString;
        // Find fragment
        var fragmentBeginPos = remainingString.indexOf("#");
        if (fragmentBeginPos >= 0) {
            var fragment = remainingString.substring(fragmentBeginPos + 1);
            this.setFragment(fragment);
            remainingString = remainingString.substring(0, fragmentBeginPos); //remove fragment
        }
        // Find scheme
        var schemeEndPos = remainingString.search(DELIMITERS);
        if (schemeEndPos >= 0) {
            if (remainingString[schemeEndPos] === ":") {
                this.setScheme(remainingString.substring(0, schemeEndPos));
                remainingString = remainingString.substring(schemeEndPos + 1); //remove scheme
            }
        }
        else {
            this.setPath(remainingString);
            return;
        }
        // Find authority
        var authority = "";
        var doubleSlashPos = remainingString.indexOf("//");
        if (doubleSlashPos === 0) {
            remainingString = remainingString.substring(2); //skip the //
            var authorityEndPos = remainingString.search(AUTHORITY_TERMINATORS);
            if (authorityEndPos >= 0) {
                authority = remainingString.substring(0, authorityEndPos);
                remainingString = remainingString.substring(authorityEndPos); //remove authority
            }
            else {
                authority = remainingString;
                remainingString = "";
            }
            this.setAuthority(authority);
            if (!remainingString) {
                this.setPath("");
                return;
            }
        }
        // Find query
        var queryBeginPos = remainingString.indexOf("?");
        if (queryBeginPos >= 0) {
            this.setQuery(remainingString.substring(queryBeginPos + 1));
            remainingString = remainingString.substring(0, queryBeginPos);
        }
        this.setPath(remainingString);
    };
    Uri.prototype._parseAuthority = function (authority) {
        this._host = authority;
        var userNameEndPos = authority.lastIndexOf("@");
        if (userNameEndPos >= 0) {
            this._host = this._host.substring(userNameEndPos + 1);
        }
        var hostPortSeparatorPos = this._host.indexOf(":");
        if (userNameEndPos < 0 && hostPortSeparatorPos < 0) {
            return;
        }
        var authorityComponents = authority;
        if (userNameEndPos < 0) {
            this._host = authorityComponents;
        }
        else {
            this._user = authorityComponents.substring(0, userNameEndPos);
            this._host = authorityComponents.substring(userNameEndPos + 1);
        }
        if (hostPortSeparatorPos >= 0) {
            this._port = this._host.substring(hostPortSeparatorPos + 1);
            this._host = this._host.substring(0, hostPortSeparatorPos);
        }
        this._user = decodeURIComponent(this._user);
        this._host = decodeURIComponent(this._host);
    };
    Uri.prototype._parsePath = function (remainingString) {
        this._path = decodeURIComponent(remainingString);
        var pathSegments = this._pathSegments = [];
        this._pathEncoded = remainingString;
        // We have to split the path BEFORE decoding so that encoded / characters
        // don't get interpreted as path separators.
        var encodedPathSegments = remainingString.split("/");
        for (var i = 0; i < encodedPathSegments.length; ++i) {
            pathSegments[i] = decodeURIComponent(encodedPathSegments[i]);
        }
        // Trims first/last element if empty
        if (pathSegments[0] === "") {
            pathSegments.shift(); // remove first element
        }
        if (pathSegments[pathSegments.length - 1] === "") {
            pathSegments.pop(); // remove last element
        }
    };
    Uri.prototype._getAuthority = function (encoded, outputOptions) {
        if (outputOptions === void 0) { outputOptions = {}; }
        // Note that if encoded is false, doNotPercentEncodeHost doesn't matter - the whole URI (including host) will not be encoded.
        var doNotPercentEncodeHost = outputOptions && outputOptions.doNotPercentEncodeHost;
        var authority = "";
        var user;
        var host;
        var port;
        if (encoded) {
            // While technically a reserved character, ':' is commonly used in the
            // username to denote username:password, so we special case not encoding
            // the first occurence of this character.
            user = encodeURIComponent(this._user).replace("%3A", ":");
            if (doNotPercentEncodeHost) {
                host = this._host;
            }
            else {
                host = encodeURIComponent(this._host);
            }
            port = encodeURIComponent(this._port);
        }
        else {
            user = this._user;
            host = this._host;
            port = this._port;
        }
        if (user !== "") {
            authority = user + "@";
        }
        if (this._host !== "") {
            authority += host;
        }
        if (this._port !== "") {
            authority += ":" + port;
        }
        return authority;
    };
    Uri.prototype._decodeQueryString = function (component) {
        // For query strings only, "+" is a valid substitute for a space, but decodeURIComponent
        // doesn't take this into account. (Note that replace("+", " ") only replaces one +.)
        var result = component;
        try {
            result = decodeURIComponent(component.replace(/\+/g, " "));
        }
        catch (e) {
            // %1 (or anything with a % that is not a result of calling encodeURIComponent)
            // would make decodeURIComponent throw a URI malformed exception.
            // Return the original value in these cases.
        }
        return result;
    };
    return Uri;
}());
exports.default = Uri;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ExperimentTypeEnum;
(function (ExperimentTypeEnum) {
    ExperimentTypeEnum[ExperimentTypeEnum["Unknown"] = 0] = "Unknown";
    ExperimentTypeEnum[ExperimentTypeEnum["User"] = 1] = "User";
    ExperimentTypeEnum[ExperimentTypeEnum["Site"] = 2] = "Site";
})(ExperimentTypeEnum = exports.ExperimentTypeEnum || (exports.ExperimentTypeEnum = {}));


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function deserializeQuery(paramsString) {
    var viewParams = {};
    if (paramsString) {
        var paramParts = paramsString.split('&');
        for (var i = 0; i < paramParts.length; i++) {
            var param = paramParts[i].split('=');
            // For query strings only, '+' is a valid substitute for a space, but decodeURIComponent
            // doesn't take this into account.
            if (typeof param[1] !== 'undefined') {
                param[1] = param[1].replace(/\+/g, ' ');
                viewParams[param[0]] = decodeURIComponent(param[1]);
            }
        }
    }
    return viewParams;
}
exports.deserializeQuery = deserializeQuery;
function getQueryStringFromUrl(url) {
    return url.substring(url.indexOf('?') + 1);
}
exports.getQueryStringFromUrl = getQueryStringFromUrl;
function getUrlWithoutQueryString(url) {
    return url.substring(0, url.indexOf('?'));
}
exports.getUrlWithoutQueryString = getUrlWithoutQueryString;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var Features_1 = __webpack_require__(34);
var FeaturesBasic_1 = __webpack_require__(35);
var AddressParser = __webpack_require__(64);
var BaseDataStore_1 = __webpack_require__(9);
var DataStoreCachingType_1 = __webpack_require__(7);
var Killswitch_1 = __webpack_require__(13);
exports.ENABLE_PARAM_KEY = 'enableFeatures';
exports.DISABLE_PARAM_KEY = 'disableFeatures';
var STORE_KEY = 'Store';
var AllowFeatureOverrides = { ODB: 587, ODC: 'AllowFeatureOverrides', Fallback: false };
var SPODebugOnlyCookieRedirect = { ODB: 357, ODC: null, Fallback: false };
var STORE_NAME = "FeatureOverrides";
var _overrides = {};
var _store = new BaseDataStore_1.default(STORE_NAME, DataStoreCachingType_1.default.session);
// Evaluate the AllowFeatureOverrides feature only once since we are going to need it a lot
var _canOverride = Features_1.default.isFeatureEnabled(AllowFeatureOverrides)
    // anywhere debugonlycookieredirect is enabled, we allow feature overrides too
    || Features_1.default.isFeatureEnabled(SPODebugOnlyCookieRedirect);
if (true) {
    _canOverride = true;
}
var ENABLE_COOKIE_NAME = STORE_NAME + "_" + exports.ENABLE_PARAM_KEY;
var DISABLE_COOKIE_NAME = STORE_NAME + "_" + exports.DISABLE_PARAM_KEY;
function _getCookieValue(cookieName) {
    var val = document.cookie.match('(^|;)\\s*' + cookieName + '\\s*=\\s*([^;]+)');
    return val ? val.pop() : "";
}
function _setFeatureSettingsToCookie(overrides) {
    var enableFeatures = [];
    var disableFeatures = [];
    for (var key in overrides) {
        (overrides[key] ? enableFeatures : disableFeatures).push(key);
    }
    document.cookie = ENABLE_COOKIE_NAME + "=" + enableFeatures.join(",") + ";path=/";
    document.cookie = DISABLE_COOKIE_NAME + "=" + disableFeatures.join(",") + ";path=/";
}
function _getFeatureSettingsFromCookie() {
    var overrides = {};
    var enableFeatures = _getCookieValue(ENABLE_COOKIE_NAME);
    if (enableFeatures) {
        for (var _i = 0, _a = enableFeatures.split(','); _i < _a.length; _i++) {
            var param = _a[_i];
            overrides[param] = true;
        }
    }
    var disableFeatures = _getCookieValue(DISABLE_COOKIE_NAME);
    if (disableFeatures) {
        for (var _b = 0, _c = disableFeatures.split(','); _b < _c.length; _b++) {
            var param = _c[_b];
            overrides[param] = false;
        }
    }
    return overrides;
}
function init() {
    var useSessionStorage = Killswitch_1.Killswitch.isActivated("CA76C674-5DEE-4C8A-9EDF-82C275E0CF01", "11/27/2018", "Don't save enable/disable features query params to session storage");
    if (useSessionStorage) {
        // Load existing values
        var overrides = _store.getValue(STORE_KEY);
        if (overrides) {
            _overrides = overrides;
        }
        else {
            _overrides = {};
        }
    }
    else {
        _overrides = _getFeatureSettingsFromCookie();
    }
    // Parse the url and add any valid feature params in the override map
    var uri = location.search ? location.search.substring(1) : '';
    var params = AddressParser.deserializeQuery(uri);
    var enableFeatures = params[exports.ENABLE_PARAM_KEY];
    if (enableFeatures) {
        for (var _i = 0, _a = enableFeatures.split(','); _i < _a.length; _i++) {
            var param = _a[_i];
            _overrides[param] = true;
        }
    }
    var disableFeatures = params[exports.DISABLE_PARAM_KEY];
    if (disableFeatures) {
        for (var _b = 0, _c = disableFeatures.split(','); _b < _c.length; _b++) {
            var param = _c[_b];
            _overrides[param] = false;
        }
    }
    if (useSessionStorage) {
        _store.setValue(STORE_KEY, _overrides);
    }
    else {
        _setFeatureSettingsToCookie(_overrides);
    }
}
init();
var FeatureOverrides = /** @class */ (function () {
    function FeatureOverrides() {
    }
    Object.defineProperty(FeatureOverrides, "Overrides", {
        get: function () {
            return _overrides;
        },
        enumerable: true,
        configurable: true
    });
    FeatureOverrides.isFeatureEnabled = function (feature, expFeatures) {
        // Check if there is an overriden value for the given feature
        if (_canOverride) {
            if (feature.ODB in _overrides) {
                return _overrides[feature.ODB];
            }
            else if (feature.ODC in _overrides) {
                return _overrides[feature.ODC];
            }
        }
        if (expFeatures) {
            return FeaturesBasic_1.isSPFeatureEnabled(feature, expFeatures);
        }
        return Features_1.default.isFeatureEnabled(feature);
    };
    FeatureOverrides.AllowFeatureOverrides = AllowFeatureOverrides;
    FeatureOverrides.SPODebugOnlyCookieRedirect = SPODebugOnlyCookieRedirect;
    return FeatureOverrides;
}());
exports.default = FeatureOverrides;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Promise_1 = __webpack_require__(12);
var Signal_1 = __webpack_require__(67);
var Scope_1 = __webpack_require__(36);
var Disposable_1 = __webpack_require__(37);
var lastId = 0;
var ResourceKey = /** @class */ (function () {
    function ResourceKey(nameOrOptions) {
        this.id = ++lastId;
        if (typeof nameOrOptions === 'string') {
            this.name = nameOrOptions;
            this.factory = null;
            this.loader = null;
        }
        else {
            this.name = nameOrOptions.name;
            this.factory = nameOrOptions.factory;
            this.loader = nameOrOptions.loader;
        }
    }
    Object.defineProperty(ResourceKey.prototype, "lazy", {
        /**
         * Gets an identifier for this {ResourceKey} as a lazy dependency (wrap in a function for deferred evaluation)
         */
        get: function () {
            return new ResourceDependency(this, 1 /* lazy */);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceKey.prototype, "local", {
        /**
         * Gets an identifier for this {ResourceKey} as a local dependency (resolved in the local ResourceScope)
         */
        get: function () {
            return new ResourceDependency(this, 2 /* local */);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceKey.prototype, "optional", {
        /**
         * Gets an identifier for this {ResourceKey} as an optional dependency
         */
        get: function () {
            return new ResourceDependency(this, 4 /* optional */);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceKey.prototype, "bypass", {
        /**
         * Gets an identifier for this {ResourceKey} as an optional dependency
         */
        get: function () {
            return new ResourceDependency(this, 8 /* bypass */);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Provides information about this resource key
     */
    ResourceKey.prototype.toString = function () {
        return "Resource #" + this.id + " \"" + this.name + "\"";
    };
    return ResourceKey;
}());
exports.ResourceKey = ResourceKey;
var DependencyFlags;
(function (DependencyFlags) {
    DependencyFlags[DependencyFlags["none"] = 0] = "none";
    DependencyFlags[DependencyFlags["lazy"] = 1] = "lazy";
    DependencyFlags[DependencyFlags["local"] = 2] = "local";
    DependencyFlags[DependencyFlags["optional"] = 4] = "optional";
    DependencyFlags[DependencyFlags["bypass"] = 8] = "bypass";
})(DependencyFlags || (DependencyFlags = {}));
var ResourceDependency = /** @class */ (function () {
    function ResourceDependency(key, flags) {
        this.key = key;
        this.flags = flags;
    }
    Object.defineProperty(ResourceDependency.prototype, "lazy", {
        get: function () {
            return new ResourceDependency(this.key, this.flags | 1 /* lazy */);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "local", {
        get: function () {
            return new ResourceDependency(this.key, this.flags | 2 /* local */);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "optional", {
        get: function () {
            return new ResourceDependency(this.key, this.flags | 4 /* optional */);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "bypass", {
        get: function () {
            return new ResourceDependency(this.key, this.flags | 8 /* bypass */);
        },
        enumerable: true,
        configurable: true
    });
    ResourceDependency.prototype.toString = function () {
        var flags = this.flags;
        return "" + this.key + (flags & 1 /* lazy */ ? '.lazy' : '') + (flags & 2 /* local */ ? '.local' : '') + (flags & 4 /* optional */ ? '.optional' : '') + (flags & 8 /* bypass */ ? '.bypass' : '');
    };
    return ResourceDependency;
}());
var ConstantResourceFactory = /** @class */ (function () {
    function ConstantResourceFactory(value) {
        this._value = value;
        this.dependencies = {};
    }
    ConstantResourceFactory.prototype.create = function () {
        return { instance: this._value };
    };
    return ConstantResourceFactory;
}());
exports.ConstantResourceFactory = ConstantResourceFactory;
exports.resourceScopeKey = new ResourceKey({
    name: 'resources'
});
exports.asyncLoadBarrierKey = new ResourceKey({
    name: 'asyncLoadBarrier'
});
var CacheOnSuccessLoader = /** @class */ (function () {
    function CacheOnSuccessLoader(loader) {
        this._loader = loader;
        this._cached = null;
    }
    CacheOnSuccessLoader.prototype.load = function () {
        var _this = this;
        if (this._cached) {
            return this._cached;
        }
        var load = this._cached = preventCancellation(this._loader.load());
        load.then(function () {
            // On success, forget the loader to conserve memory.
            _this._loader = null;
        }, function () {
            // On error, reset the cache so the next load can try again.
            _this._cached = null;
        });
        return load;
    };
    return CacheOnSuccessLoader;
}());
var Handle = /** @class */ (function () {
    function Handle(entry, instanceManager) {
        this.entry = entry;
        this.manager = instanceManager;
        this.instance = null;
    }
    Handle.prototype.getInstance = function (key, resourceScopeOptions) {
        if (this.instance) {
            return this.instance;
        }
        var manager = this.manager;
        var factory = this.entry.factory;
        var resource = factory.create(manager.resolve(factory.dependencies, resourceScopeOptions));
        var instance = this.instance = resource.instance;
        if (resource.disposable) {
            manager.scope.attach(resource.disposable);
        }
        return instance;
    };
    Handle.prototype.promote = function (targetHandleManager) {
        var entry = this.entry;
        return new Handle({
            manager: targetHandleManager,
            loader: entry.loader,
            factory: entry.factory
        });
    };
    return Handle;
}());
function getResolvedConstructor(resolvableConstructor, resolvedDependencies) {
    var Resolved = function (params) {
        var instance = resolvableConstructor.call(this, params, resolvedDependencies) || this;
        return instance;
    };
    if (true) {
        // This pattern results in the correct type being displayed in the debugger
        var wrappedConstructor_1 = Resolved;
        Resolved = function (params) {
            var instance = wrappedConstructor_1.call(Object.create(resolvableConstructor.prototype), params);
            return instance;
        };
    }
    Resolved.prototype = resolvableConstructor.prototype;
    return Resolved;
}
exports.getResolvedConstructor = getResolvedConstructor;
function formatResourceTree(stack) {
    if (stack.length < 1) {
        return ' Consumed directly.';
    }
    return stack.concat(['']).reverse().join('\n  Required by ');
}
function formatLoadTree(stack) {
    if (stack.length < 2) {
        return ' Loaded directly.';
    }
    return [''].concat(stack.slice(1)).join('\n  Required by ');
}
var HandleManager = /** @class */ (function () {
    function HandleManager(parentOrOptions) {
        this._handles = {};
        this._isLocked = false;
        this._loader = null;
        var options;
        if (parentOrOptions instanceof HandleManager) {
            if (parentOrOptions.isDisposed) {
                throw new Error('Parent ResourceScope has already been disposed!');
            }
            options = parentOrOptions.options;
            this._parent = parentOrOptions;
            this._level = parentOrOptions._level + 1;
        }
        else {
            options = parentOrOptions || {};
            this._parent = null;
            this._level = 0;
        }
        this.scope = new Scope_1.default();
        this.options = options;
    }
    Object.defineProperty(HandleManager.prototype, "isDisposed", {
        get: function () {
            return this.scope.isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    HandleManager.prototype.block = function (key) {
        return this._expose(key);
    };
    HandleManager.prototype.isDescendantOf = function (manager) {
        return this._level > manager._level;
    };
    HandleManager.prototype.getHandle = function (key) {
        var manager = this;
        var keyId = key.id;
        // Starting with this scope, attempt to find the first scope with an entry (may be undefined)
        // for the given key. Stop when there are no more ancestor scopes.
        while (!(keyId in manager._handles) && manager._parent) {
            manager = manager._parent;
        }
        var handles = manager._handles;
        return handles[keyId] || this.options.useFactoriesOnKeys &&
            (key.factory && (handles[keyId] = new Handle({
                factory: key.factory,
                manager: manager
            })) || (key.loader && (handles[keyId] = new Handle({
                loader: new CacheOnSuccessLoader(key.loader),
                manager: manager
            }))));
    };
    HandleManager.prototype.expose = function (key, source, instance) {
        return this._expose(key, function (handleManager) { return new Handle({
            factory: source.factory,
            loader: source.loader,
            manager: handleManager
        }, instance && handleManager); });
    };
    HandleManager.prototype.getLoader = function () {
        if (this._loader) {
            return this._loader;
        }
        this.lock();
        var loader = this._loader = new ResourceLoader(this);
        return loader;
    };
    HandleManager.prototype.dispose = function () {
        this.scope.dispose();
        this._handles = {};
        this._loader = null;
        this.consume = this.resolve = onConsumeAfterDispose;
        this.getLoader = onLoadAfterDispose;
    };
    HandleManager.prototype.bind = function (key) {
        var handle = this.getHandle(key);
        if (handle) {
            return this._expose(key, function (handleManager) { return handle.promote(handleManager); });
        }
        return this;
    };
    HandleManager.prototype.lock = function () {
        this._isLocked = !!this.options.lockResourcesForChildren;
    };
    HandleManager.prototype.consume = function (dependency, scopeOptions) {
        var _this = this;
        this.lock();
        var key = (dependency.key || dependency);
        var options = dependency.flags;
        var thunk;
        if (key === exports.resourceScopeKey) {
            var resourceScope_1;
            thunk = function () {
                if (!resourceScope_1) {
                    resourceScope_1 = _this.scope.attach(new ResourceScope(_this, scopeOptions || { owner: "" + key }));
                }
                return resourceScope_1;
            };
        }
        else {
            var handle_1 = this._getValidHandle(dependency, []);
            if (!(handle_1 instanceof Error)) {
                thunk = function () { return handle_1.getInstance(key, scopeOptions || { owner: "" + key }); };
            }
            else if (!(options & 4 /* optional */)) {
                throw handle_1;
            }
        }
        return ((options & 1 /* lazy */) ? thunk : (thunk && thunk()));
    };
    HandleManager.prototype.isExposed = function (dependency) {
        return !(this._getValidHandle(dependency, []) instanceof Error);
    };
    HandleManager.prototype.resolve = function (dependencies, scopeOptions) {
        var result = {};
        for (var _i = 0, _a = Object.keys(dependencies); _i < _a.length; _i++) {
            var id = _a[_i];
            var dependency = dependencies[id];
            if (!dependency) {
                continue;
            }
            result[id] = this.consume(dependencies[id], scopeOptions);
        }
        return result;
    };
    HandleManager.prototype._getValidHandle = function (resourceDependency, stack) {
        var key = (resourceDependency.key || resourceDependency);
        var keyId = key.id;
        if (stack.indexOf(key) >= 0) {
            // Circular reference will *always* throw, even on isExposed.
            throw new Error(key + " has a circular dependency." + formatResourceTree(stack));
        }
        // If we have a handle with a manager cached, return it.
        var localHandle = this._handles[keyId];
        if (localHandle && localHandle.manager) {
            return localHandle;
        }
        var handle = this.getHandle(key);
        if (!handle) {
            return new Error(key + " is being consumed, but is not available in the current scope." + formatResourceTree(stack));
        }
        var entry = handle.entry;
        var factory = entry.factory;
        if (!factory) {
            return new Error(key + " is being consumed synchronously, but was exposed asynchronously and has not been loaded." + formatResourceTree(stack));
        }
        // Find the highest possible scope at which an instance of T can be stored.
        stack.push(key);
        var instanceManager = handle.manager;
        var targetManager = (resourceDependency.flags & 2 /* local */)
            ? this : instanceManager || entry.manager;
        var dependencies = factory.dependencies || {};
        for (var _i = 0, _a = Object.keys(dependencies); _i < _a.length; _i++) {
            var id = _a[_i];
            var dependency = dependencies[id];
            // Dependency on resourceScopeKey does not affect targeting
            if (!dependency || (dependency.key || dependency) === exports.resourceScopeKey) {
                continue;
            }
            // Recurse on dependencies.
            var dependencyHandle = this._getValidHandle(dependency, stack);
            if (dependencyHandle instanceof Error) {
                if (!(dependency.flags & 4 /* optional */)) {
                    stack.pop();
                    return dependencyHandle;
                }
            }
            else if (dependencyHandle.manager.isDescendantOf(targetManager)) {
                targetManager = dependencyHandle.manager;
            }
        }
        stack.pop();
        if (!instanceManager || instanceManager !== targetManager) {
            // Need a new handle.
            handle = new Handle(entry, targetManager);
            // Place on targetManager, so that other levels can reuse
            targetManager._handles[keyId] = handle;
        }
        return this._handles[keyId] = handle;
    };
    HandleManager.prototype._expose = function (key, createHandle) {
        if (this.isDisposed) {
            throw new Error('Cannot expose a resource on a ResourceScope that has been disposed.');
        }
        if (key === exports.resourceScopeKey) {
            throw new Error('It is invalid to expose the ResourceScope key');
        }
        var keyId = key.id;
        var handleManager = this._isLocked ? this.scope.attach(new HandleManager(this)) : this;
        var handles = handleManager._handles;
        if (handles[keyId]) {
            if (this.options.noDoubleExpose) {
                throw new Error(key + " has already been exposed/consumed at this scope.");
            }
        }
        handles[keyId] = createHandle ? createHandle(handleManager) : void 0;
        return handleManager;
    };
    return HandleManager;
}());
function onConsumeAfterDispose(resourceDependency) {
    if (resourceDependency instanceof ResourceDependency || resourceDependency instanceof ResourceKey) {
        throw new Error("Cannot consume " + resourceDependency + " from a disposed ResourceScope.");
    }
    throw new Error('Cannot resolve resources from a disposed ResourceScope.');
}
function onLoadAfterDispose() {
    throw new Error('Cannot load a resource from a ResourceScope that has been disposed.');
}
function voidify() {
    // Do nothing
}
function getFirstError(errors) {
    for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
        var error = errors_1[_i];
        if (error) {
            return Promise_1.default.reject(error);
        }
    }
    return Promise_1.default.reject(new Error('A dependency could not be loaded.'));
}
var ResourceLoader = /** @class */ (function () {
    function ResourceLoader(handleManager) {
        this._handleManager = handleManager;
        this._loadState = {};
        this._root = handleManager.consume(exports.asyncLoadBarrierKey.optional);
    }
    /**
     * Performs an async load of the specified resource. Should return a successful result if the value is optional or loads.
     * Should return an error result if the value is non-optional and fails to load.
     * Should return the same promise for multiple requests to the same key.
     */
    ResourceLoader.prototype.loadAsync = function (dependency, stack) {
        // Loading the ResourceScope key is always successful.
        var key = dependency.key || dependency;
        if (key === exports.resourceScopeKey) {
            return Promise_1.default.resolve();
        }
        var options = dependency.flags;
        var promise = this._loadAsync(key, !!(options & 8 /* bypass */), [dependency].concat(stack));
        return (options & 4 /* optional */) ? promise.catch(voidify) : promise;
    };
    ResourceLoader.prototype.loadAllAsync = function (dependencies, bypass, stack) {
        if (dependencies) {
            var dependencyNames = Object.keys(dependencies);
            var length_1 = dependencyNames.length;
            if (length_1 > 0) {
                var promises = [];
                while (length_1--) {
                    var name_1 = dependencyNames[length_1];
                    var dependency = dependencies[name_1];
                    if (!dependency) {
                        continue;
                    }
                    promises.push(this.loadAsync(bypass ? dependency.bypass : dependency, stack));
                }
                return Promise_1.default.all(promises).then(voidify, getFirstError);
            }
        }
        return Promise_1.default.resolve();
    };
    ResourceLoader.prototype._loadAsync = function (key, bypass, stack) {
        var _this = this;
        // Check the cache
        var keyId = key.id;
        var loadStateMap = this._loadState;
        var cached = loadStateMap[keyId];
        if (cached) {
            return cached;
        }
        // Validate that there is a valid handle for the key
        var handleManager = this._handleManager;
        var handle = handleManager.getHandle(key);
        if (!handle) {
            return loadStateMap[keyId] = Promise_1.default.reject(new Error(key + " is being loaded, but has no factory/loader. Check to ensure that either:" +
                ("\n  1) " + key + " is defined with a 'factory' or 'loader' specified.") +
                ("\n  2) A higher-level component calls 'expose', 'exposeFactory', or 'exposeAsync' for " + key + "." + formatLoadTree(stack))));
        }
        // Mark possible circular reference
        loadStateMap[keyId] = Promise_1.default.resolve();
        // If we have a synchronously available factory, load its dependencies
        var entry = handle.entry;
        var factory = entry.factory;
        if (factory) {
            // Ensure that the bypass flag propagates down the tree if specified higher up
            // Otherwise this can result in waiting indefinitely
            return loadStateMap[keyId] = this.loadAllAsync(factory.dependencies, bypass, stack);
        }
        // Finally, fall back to the loader
        var loader = entry.loader;
        if (!loader) {
            return loadStateMap[keyId] = Promise_1.default.reject(new Error(key + " is being loaded, but no loader was defined. Check to ensure that either:" +
                ("\n  1) " + key + " is defined with a 'loader' specified.") +
                ("\n  2) A higher-level component calls 'exposeAsync' for " + key + "." + formatLoadTree(stack))));
        }
        var root = this._root;
        var rootPromise = !bypass && root && root.wait() || Promise_1.default.resolve();
        return loadStateMap[keyId] = rootPromise.then(function () { return loader.load(); }).then(function (value) {
            entry.factory = value;
            var factoryDependencies = value.dependencies;
            if (factoryDependencies) {
                return _this.loadAllAsync(factoryDependencies, bypass, stack);
            }
        });
    };
    return ResourceLoader;
}());
var ResourceScope = /** @class */ (function () {
    function ResourceScope(parentOrOptions, options) {
        var parentOwner;
        var handleManager;
        if (parentOrOptions instanceof ResourceScope) {
            handleManager = parentOrOptions._handleManager;
            parentOwner = parentOrOptions._owner;
        }
        else if (parentOrOptions instanceof HandleManager) {
            handleManager = parentOrOptions;
        }
        else {
            options = parentOrOptions || options;
        }
        var scope = new Scope_1.default();
        if (handleManager) {
            if (handleManager.scope.isDisposed) {
                throw new Error('Parent ResourceScope has already been disposed.');
            }
            handleManager.lock();
            if (!handleManager.options.lockResourcesForChildren) {
                this._forkOnWrite = true;
            }
        }
        this._handleManager = handleManager || (handleManager = scope.attach(new HandleManager(options)));
        this._scope = scope;
        var owner = options ? options.owner : '';
        this._owner = parentOwner ? parentOwner + " > " + owner : owner;
    }
    /**
     * Obtains an instance of a resource with the given key exposed by either this scope
     * or a parent. Throws if the resource is not found and isOptional is not set.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     * @returns an instance of the resource, if available in this scope or a parent.
     */
    ResourceScope.prototype.consume = function (dependency) {
        return this._handleManager.consume(dependency);
    };
    /**
     * Obtains an instance of a resource with the given key exposed by either this scope
     * or a parent. Throws if the resource is not found and isOptional is not set.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     * @returns a promise for an instance of the resource, if available in this scope or a parent.
     */
    ResourceScope.prototype.consumeAsync = function (dependency) {
        var handleManager = this._handleManager;
        return preventCancellation(handleManager.getLoader().loadAsync(dependency, [])).then(function () {
            return handleManager.consume(dependency);
        });
    };
    /**
     * Ensures that the specified dependencies have been loaded for synchronous consumption.
     * @param dependencies {IResourceDependencies} - the dependencies to load.
     * @returns a promise that will complete when the specified resources are available.
     */
    ResourceScope.prototype.load = function (dependencies) {
        return preventCancellation(this._handleManager.getLoader().loadAllAsync(dependencies, false, []));
    };
    /**
     * Exposes an asynchronous loader for a resource with the given type-safe key.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     * @param loader - the object that can asynchronously load a factory of the desired type
     */
    ResourceScope.prototype.exposeAsync = function (key, loader) {
        this._expose(key, {
            loader: new CacheOnSuccessLoader(loader)
        });
    };
    /**
     * Exposes a factory for a resource with the given type-safe key.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     * @param factory - the factory that will construct instances when required by this or any child scope.
     */
    ResourceScope.prototype.exposeFactory = function (key, factory) {
        this._expose(key, {
            factory: factory
        });
    };
    /**
     * Exposes a resource with the given type-safe key.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     * @param instance - the instance of the resource to use within this scope.
     */
    ResourceScope.prototype.expose = function (key, instance) {
        this._expose(key, {
            factory: new ConstantResourceFactory(instance)
        }, instance);
        return instance;
    };
    /**
     * Hides any resources exposed by parent scopes for the specified key.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     */
    ResourceScope.prototype.block = function (key) {
        this._handleManager = this._prepareWrite().block(key);
    };
    /**
     * Re-exposes the currently exposed resource at the specified key at the current resource scope.
     * The effect of this is that the lifetime of instances created by the resource system that depend on the
     * specific key will not exceed the lifetime of this resource scope.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     */
    ResourceScope.prototype.bind = function (key) {
        this._handleManager = this._prepareWrite().bind(key);
    };
    /**
     * Checks if a given resource key is defined and known to the system; i.e. if a factory or loader exists.
     */
    ResourceScope.prototype.isDefined = function (key) {
        var handleManager = this._handleManager;
        return !handleManager.isDisposed && !!handleManager.getHandle(key);
    };
    /**
     * Checks if a given resource key is exposed (i.e. can be synchronously obtained) in the resource scope
     * (including in parent scopes). If the resource key only has a loader, this method will return `false`
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     * @return {boolean}
     */
    ResourceScope.prototype.isExposed = function (dependency) {
        var handleManager = this._handleManager;
        return !handleManager.isDisposed && handleManager.isExposed(dependency);
    };
    /**
     * Produces an alternate constructor for the given type which pre-injects the instance with resources
     * before invoking the real constructor.
     * This function preserves the original argument types for the constructor, allowing validation
     * of arguments.
     * @param type - the type of object for which to create an injected constructor.
     * @returns an injected version of the original constructor for the type.
     */
    ResourceScope.prototype.injected = function (type, options) {
        if (options === void 0) { options = {}; }
        var injectChildResourceScope = options.injectChildResourceScope;
        var childOptions = {
            owner: options.owner || type.name
        };
        var resources = injectChildResourceScope ? this._scope.attach(new ResourceScope(this, childOptions)) : this;
        var Injected = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this.resources = resources;
            var instance = type.apply(this, args) || this;
            if (injectChildResourceScope) {
                Disposable_1.hook(instance, disposeInstanceResources);
            }
            return instance;
        };
        if (true) {
            // This pattern results in the correct type being displayed in the debugger
            var wrappedConstructor_2 = Injected;
            Injected = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var instance = wrappedConstructor_2.apply(Object.create(type.prototype), args);
                return instance;
            };
        }
        Injected.prototype = type.prototype;
        return Injected;
    };
    /**
     * Resolves a set of resource keys
     *
     * @param dependencies - an object that maps names to {ResourceKey} instances.
     * @returns an object mapping the original names to the resolved resources.
     */
    ResourceScope.prototype.resolve = function (dependencies) {
        return this._handleManager.resolve(dependencies);
    };
    /**
     * Resolves a set of resource keys
     *
     * @param dependencies - an object that maps names to {ResourceKey} instances.
     * @returns an object mapping the original names to the resolved resources.
     */
    ResourceScope.prototype.resolveAsync = function (dependencies) {
        var _this = this;
        return this.load(dependencies).then(function () { return _this.resolve(dependencies); });
    };
    ResourceScope.prototype.resolved = function (type, dependencies) {
        return getResolvedConstructor(type, this.resolve(tslib_1.__assign({}, (type.dependencies || {}), (dependencies || {}))));
    };
    ResourceScope.prototype.resolvedAsync = function (type, dependencies) {
        var _this = this;
        return this.load(tslib_1.__assign({}, (type.dependencies || {}), (dependencies || {}))).then(function () { return _this.resolved(type, dependencies); });
    };
    /**
     * Disposes this resource scope and any resources bound to this scope's lifetime.
     */
    ResourceScope.prototype.dispose = function () {
        this._scope.dispose();
    };
    ResourceScope.prototype._expose = function (key, source, instance) {
        this._handleManager = this._prepareWrite().expose(key, source, instance);
    };
    // These methods are to support legacy call patterns by imitating old behavior
    ResourceScope.prototype._prepareWrite = function () {
        if (this._forkOnWrite) {
            this._forkOnWrite = false;
            return this._scope.attach(new HandleManager(this._handleManager));
        }
        return this._handleManager;
    };
    return ResourceScope;
}());
exports.ResourceScope = ResourceScope;
function disposeInstanceResources() {
    this.resources.dispose();
}
function preventCancellation(promise) {
    var signal = new Signal_1.default();
    promise.then(function (result) { return signal.complete(result); }, function (error) { return signal.error(error); });
    return signal.getPromise();
}
exports.default = ResourceScope;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// OneDrive:IgnoreCodeCoverage
var Promise_1 = __webpack_require__(12);
/**
 * Signal is used to manage a promise without having to pass a function to the Promise constructor.
 * Example:
 * var s = new Signal<boolean>();
 * setTimeout(() => {
 *    s.complete(true);
 * }, 1000);
 * return s.promise;
 */
var Signal = /** @class */ (function () {
    /**
     * Create a new Signal (also known as a Deferred in some circles.)
     * @param: oncancel A function to be called when the promise is cancelled.
     */
    function Signal(oncancel) {
        this._promise = new Promise_1.SignalPromise(oncancel);
    }
    /**
     * The underlying promise that the Signal manages.
     */
    Signal.prototype.getPromise = function () {
        return this._promise;
    };
    /**
     * Cancel the underlying promise.
     */
    Signal.prototype.cancel = function () {
        this._promise.cancel();
    };
    /**
     * Complete the underlying promise with the given value.
     */
    Signal.prototype.complete = function (value) {
        this._promise._completed(value);
    };
    /**
     * Put the underlying promise into the error state with the given value.
     */
    Signal.prototype.error = function (value) {
        this._promise._error(value);
    };
    return Signal;
}());
exports.default = Signal;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ItemType;
(function (ItemType) {
    ItemType[ItemType["File"] = 0] = "File";
    ItemType[ItemType["Folder"] = 1] = "Folder";
    ItemType[ItemType["Media"] = 2] = "Media";
    ItemType[ItemType["OneNote"] = 3] = "OneNote";
    ItemType[ItemType["Unknown"] = 4] = "Unknown";
    ItemType[ItemType["Error"] = 5] = "Error";
    ItemType[ItemType["App"] = 6] = "App";
    ItemType[ItemType["Subsite"] = 7] = "Subsite";
    /** A shortcut link pointing to some target destination or Url */
    ItemType[ItemType["Shortcut"] = 8] = "Shortcut";
})(ItemType = exports.ItemType || (exports.ItemType = {}));
exports.default = ItemType;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var RgbaColor_1 = __webpack_require__(14);
var Shades_1 = __webpack_require__(117);
/**
 * Utility class with static methods to work with Fabric-style themes.
 */
var FabricTheming = /** @class */ (function () {
    function FabricTheming() {
    }
    /**
     * Generates a palette of Fabric colors from a primary RGB color value.
     * @param {RgbaColor} primaryRgb Primary RGB color used to generate a palette.
     * @param {boolean} inverted Whether the theme is inverted, with a dark background and light foreground.
     */
    FabricTheming.generateFabricColors = function (primaryRgb, inverted) {
        if (inverted === void 0) { inverted = false; }
        var generatedShades = {
            "themeDarker": Shades_1.Shade.Shade8,
            "themeDark": Shades_1.Shade.Shade7,
            "themeDarkAlt": Shades_1.Shade.Shade6,
            "themeLight": Shades_1.Shade.Shade3,
            "themeLighter": Shades_1.Shade.Shade2,
            "themeLighterAlt": Shades_1.Shade.Shade1,
            "themePrimary": Shades_1.Shade.Unshaded,
            "themeAccent": Shades_1.Shade.Unshaded,
            "themeSecondary": Shades_1.Shade.Shade5,
            "themeTertiary": Shades_1.Shade.Shade4
        };
        // Expected color slots. Start each defaulting to null to avoid warnings about missing slots.
        var colors = FabricTheming._getDefaultThemeTokenMap();
        // Starting points for the generated palette.
        var primaryColor = RgbaColor_1.default.fromRgba(primaryRgb.R, primaryRgb.G, primaryRgb.B);
        for (var shadeName in generatedShades) {
            var shade = generatedShades[shadeName];
            colors[shadeName] = Shades_1.getShade(primaryColor, shade, inverted);
        }
        var accent = colors["themeAccent"];
        colors["themeAccentTranslucent10"] = accent ?
            RgbaColor_1.default.fromRgba(accent.R, accent.G, accent.B, 0.1 * RgbaColor_1.default.maxComponent) : null;
        // Handle neutral slots for inverted themes
        if (inverted) {
            var invertedText = '#fff';
            var invertedNeutralQuaternary = '#4f4f4f';
            var invertedNeutralQuaternaryAlt = '#484848';
            var invertedNeutralColors = {
                'black': '#fff',
                'blackTranslucent40': '#66ffffff',
                'neutralDark': '#f4f4f4',
                'neutralPrimary': invertedText,
                'neutralPrimaryTranslucent50': '#7fffffff',
                'neutralPrimaryAlt': '#dadada',
                'neutralSecondary': '#d0d0d0',
                'neutralTertiary': '#c8c8c8',
                'neutralTertiaryAlt': '#6d6d6d',
                'neutralQuaternary': invertedNeutralQuaternary,
                'neutralQuaternaryAlt': invertedNeutralQuaternaryAlt,
                'cmdbarSelected': invertedNeutralQuaternary,
                'cmdbarSelectedHover': invertedNeutralQuaternaryAlt,
                'neutralLight': '#3f3f3f',
                'neutralLighter': '#313131',
                'neutralLighterAlt': '#282828',
                'white': '#1f1f1f',
                'whiteTranslucent40': '#661f1f1f',
                'error': '#f00',
                'errorBackground': '#7e3333'
            };
            for (var neutralSlot in invertedNeutralColors) {
                if (invertedNeutralColors.hasOwnProperty(neutralSlot)) {
                    colors[neutralSlot] =
                        RgbaColor_1.default.fromHtmlColor(invertedNeutralColors[neutralSlot]);
                }
            }
        }
        return colors;
    };
    FabricTheming._getDefaultThemeTokenMap = function () {
        return {
            backgroundOverlay: null,
            themeDarker: null,
            themeDark: null,
            themeDarkAlt: null,
            themePrimary: null,
            themeSecondary: null,
            themeTertiary: null,
            themeLight: null,
            themeLighter: null,
            themeLighterAlt: null,
            black: null,
            cmdbarSelected: null,
            cmdbarSelectedHover: null,
            neutralDark: null,
            neutralPrimary: null,
            neutralPrimaryAlt: null,
            neutralPrimaryTranslucent50: null,
            neutralSecondary: null,
            neutralSecondaryAlt: null,
            neutralTertiary: null,
            neutralTertiaryAlt: null,
            neutralQuaternary: null,
            neutralQuaternaryAlt: null,
            neutralLight: null,
            neutralLighter: null,
            neutralLighterAlt: null,
            white: null,
            blackTranslucent40: null,
            whiteTranslucent40: null,
            yellow: null,
            yellowLight: null,
            orange: null,
            orangeLight: null,
            redDark: null,
            red: null,
            magentaDark: null,
            magenta: null,
            magentaLight: null,
            purpleDark: null,
            purple: null,
            purpleLight: null,
            blueDark: null,
            blueMid: null,
            blue: null,
            blueLight: null,
            tealDark: null,
            teal: null,
            tealLight: null,
            greenDark: null,
            green: null,
            greenLight: null,
            error: null,
            errorBackground: null,
            success: null,
            successBackground: null,
            alert: null,
            alertBackground: null,
            infoBackground: null,
            info: null,
            orangeLighter: null
        };
    };
    return FabricTheming;
}());
exports.default = FabricTheming;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var RgbaColor_1 = __webpack_require__(14);
var ThemeCache_1 = __webpack_require__(118);
var Promise_1 = __webpack_require__(12);
var Engagement_event_1 = __webpack_require__(17);
var Qos_event_1 = __webpack_require__(18);
var Killswitch_1 = __webpack_require__(13);
/**
 * Provides theme data, either from the local cache or from the server.
 */
var ThemeProvider = /** @class */ (function () {
    /**
     * Constructs a ThemeProvider which acts like the provided loadData function but with caching.
     * @param {() => Promise<IThemeData>} loadData Used to load data on a cache miss.
     */
    function ThemeProvider(loadData) {
        this._loadData = loadData;
    }
    ThemeProvider.getBackgroundUrl = function (data) {
        if (data) {
            return ThemeProvider._makeCssUrl(data.backgroundImageUri);
        }
        else {
            return 'none';
        }
    };
    /**
     * Given a URL, returns a string value which can be safely used as a
     * background-image value in a CSS rule. If the url is falsey, this
     * returns "none" to specify no background-image.
     * @param {string} url The URL of a background image.
     */
    ThemeProvider._makeCssUrl = function (url) {
        var cssUrlValue = "none";
        if (url) {
            cssUrlValue = 'url("' +
                ThemeProvider._escapeQuotesAndParentheses(url) +
                '")';
        }
        return cssUrlValue;
    };
    /**
     * Escapes single- and double-quotes along with parentheses so that the
     * resulting string is safe to use in a CSS background-image: url()
     * @param {string} str The string to escape.
     */
    ThemeProvider._escapeQuotesAndParentheses = function (str) {
        var replacements = { "'": "%27", '"': "%22", "(": "%28", ")": "%29" };
        var result = null;
        if (str != null) {
            result = str.replace(/(['"\(\)])/gm, function (match, capture) {
                return replacements[capture];
            });
        }
        return result;
    };
    /**
     * Loads the theme data and returns a map from theme tokens to replacement values.
     * Suitable for use with loadTheme in load-themed-styles.
     * @param {string} cacheToken Cache token used to validate cached data.
     * @param {boolean} forceUpdate Whether to force fresh data to be loaded and cached.
     */
    ThemeProvider.prototype.loadThemeTokenMap = function (cacheToken, forceUpdate) {
        return this.loadThemeData(cacheToken, forceUpdate).then(function (themeData) {
            var themeValues;
            if (themeData && themeData.palette) {
                themeValues = {};
                var palette = themeData.palette;
                for (var colorSlot in palette) {
                    var rgbaValue = palette[colorSlot];
                    themeValues[colorSlot] = rgbaValue ? RgbaColor_1.default.toHtmlString(rgbaValue) : null;
                }
                themeValues["backgroundImageUri"] =
                    ThemeProvider._makeCssUrl(themeData.backgroundImageUri);
            }
            return themeValues;
        }, function (error) { return null; }); // on error, return null
    };
    /**
     * Loads the theme data from the cache or via the a loadData method.
     * @param {string} cacheToken Cache token used to validate cached data.
     * @param {boolean} forceUpdate Whether to force fresh data to be loaded and cached.
     */
    ThemeProvider.prototype.loadThemeData = function (cacheToken, forceUpdate) {
        if (!forceUpdate && this._dataPromise) {
            return this._dataPromise;
        }
        var _this = this;
        var failureResultCode = null;
        var failureResultType = Qos_event_1.ResultTypeEnum.Failure;
        this._dataPromise = Qos_event_1.Qos.instrumentPromise(
        /*startSchema*/ { name: "ThemeProvider.LoadData" }, 
        /*createPromise*/ function () { return new Promise_1.default(function loadDataOnExecute(complete, error) {
            var previousData = null;
            if (!forceUpdate) {
                // Checks if we have valid cached data before returning it.
                previousData = ThemeCache_1.default.getCachedTheme(cacheToken);
            }
            // If we have previous data and an update is not forced, use that data.
            if (previousData) {
                Engagement_event_1.Engagement.logData({ name: "ThemeProvider.DataFromCache" });
                complete(previousData);
            }
            else {
                if (forceUpdate) {
                    Engagement_event_1.Engagement.logData({ name: "ThemeProvider.ForceUpdateData" });
                }
                Engagement_event_1.Engagement.logData({ name: "ThemeProvider.DataFromServer" });
                // Get updated data. Might result in a server call.
                _this._loadData(forceUpdate).done(function onComplete(themeData) {
                    if (themeData) {
                        if (Killswitch_1.Killswitch.isActivated('d1147437-6254-48b4-b8bd-daada2ef95a1', '02/21/2019', 'Remove error condition for no cache token')) {
                            if (themeData.cacheToken) {
                                ThemeCache_1.default.updateThemeCache(themeData, cacheToken);
                                complete(themeData);
                            }
                            else {
                                failureResultCode = "NoCacheToken";
                                if (error) {
                                    error("Theme data with no CacheToken returned");
                                }
                            }
                        }
                        else {
                            if (themeData.cacheToken) {
                                ThemeCache_1.default.updateThemeCache(themeData, cacheToken);
                            }
                            complete(themeData);
                        }
                    }
                    else {
                        failureResultCode = "NoData";
                        if (error) {
                            error("No model returned");
                        }
                    }
                }, function onError(err) {
                    if (Promise_1.default.isCanceled(error)) {
                        failureResultCode = "Canceled";
                        failureResultType = Qos_event_1.ResultTypeEnum.ExpectedFailure;
                    }
                    else {
                        failureResultCode = "ServerLoadFailure";
                    }
                    if (error) {
                        error(err);
                    }
                });
            }
        }); }, 
        /*getCompleteSchema*/ null, 
        /*getErrorSchema*/ function getErrorSchema(error) {
            if (Promise_1.default.isCanceled(error)) {
                failureResultType = Qos_event_1.ResultTypeEnum.ExpectedFailure;
                failureResultCode = "Canceled";
            }
            return {
                resultType: failureResultType,
                resultCode: failureResultCode || "Other",
                error: error
            };
        });
        return this._dataPromise;
    };
    return ThemeProvider;
}());
exports.default = ThemeProvider;


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: C:/agent/1/_work/9/s/common/temp/node_modules/.onedrive.pkgs.visualstudio.com/tslib/1.9.3/node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(0);

// EXTERNAL MODULE: external "@microsoft/sp-extension-base"
var sp_extension_base_ = __webpack_require__(24);
var sp_extension_base__default = /*#__PURE__*/__webpack_require__.n(sp_extension_base_);

// EXTERNAL MODULE: external "@microsoft/sp-diagnostics"
var sp_diagnostics_ = __webpack_require__(2);
var sp_diagnostics__default = /*#__PURE__*/__webpack_require__.n(sp_diagnostics_);

// EXTERNAL MODULE: external "@microsoft/sp-core-library"
var sp_core_library_ = __webpack_require__(1);
var sp_core_library__default = /*#__PURE__*/__webpack_require__.n(sp_core_library_);

// CONCATENATED MODULE: ./lib/extensibility/placeholder/PlaceholderContent.js

var PlaceholderContent_PlaceholderContent =  (function () {
    function PlaceholderContent(parameters) {
        this._disposeHandler = undefined;
        this._isDisposed = false;
        this._placeholder = parameters.placeholder;
        this._disposeHandler = parameters.options ? parameters.options.onDispose : undefined;
        this._domElement = parameters.domElement;
    }
    Object.defineProperty(PlaceholderContent.prototype, "name", {
        get: function () {
            return this._placeholder.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlaceholderContent.prototype, "domElement", {
        get: function () {
            return this._domElement;
        },
        enumerable: true,
        configurable: true
    });
    PlaceholderContent.prototype._setPlaceholder = function (placeholder) {
        this._placeholder = placeholder;
    };
    PlaceholderContent.prototype.dispose = function () {
        if (!this._isDisposed) {
            if (this._disposeHandler) {
                try {
                    this._disposeHandler(this);
                }
                catch (error) {
                    sp_diagnostics_["_TraceLogger"].logError(PlaceholderContent._logSource, new Error("The onDispose API threw an exception for placeholder '" + this._placeholder.name + "'. Error information is '" + error.message + "'")); 
                }
            }
            this._placeholder.removePlaceholderContent(this);
            delete this._domElement;
            delete this._placeholder;
            delete this._disposeHandler;
        }
        this._isDisposed = true;
    };
    Object.defineProperty(PlaceholderContent.prototype, "isDisposed", {
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlaceholderContent.prototype, "isVisible", {
        get: function () {
            return document.body.contains(this._domElement);
        },
        enumerable: true,
        configurable: true
    });
    PlaceholderContent._logSource = sp_diagnostics_["_LogSource"].create('Placeholder');
    return PlaceholderContent;
}());
/* harmony default export */ var placeholder_PlaceholderContent = (PlaceholderContent_PlaceholderContent);

// CONCATENATED MODULE: ./lib/extensibility/placeholder/PlaceholderName.js
var PlaceholderName;
(function (PlaceholderName) {
    PlaceholderName[PlaceholderName["Top"] = 1] = "Top";
    PlaceholderName[PlaceholderName["Bottom"] = 2] = "Bottom";
})(PlaceholderName || (PlaceholderName = {}));
/* harmony default export */ var placeholder_PlaceholderName = (PlaceholderName);

// CONCATENATED MODULE: ./lib/extensibility/placeholder/Placeholder.js



var Placeholder_Placeholder =  (function () {
    function Placeholder(definition, manager) {
        this._entries = [];
        sp_core_library_["Validate"].isNotNullOrUndefined(definition, 'definition');
        sp_core_library_["Validate"].isNotNullOrUndefined(definition.domElement, 'definition.domElement');
        sp_core_library_["Validate"].isNotNullOrUndefined(manager, 'manager');
        this._name = definition.name;
        this._domElement = definition.domElement;
        this._applicationDomElement = undefined;
    }
    Object.defineProperty(Placeholder.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Placeholder.prototype.createPlaceholderContent = function (sequence, options) {
        var contentDiv = document.createElement('div');
        var position = this._addContentDiv(contentDiv, sequence);
        var placeholderContent = new placeholder_PlaceholderContent({
            placeholder: this,
            sequence: sequence,
            domElement: contentDiv,
            options: options
        });
        this._entries.splice(position, 0, { placeholderContent: placeholderContent, sequence: sequence });
        return placeholderContent;
    };
    Placeholder.prototype.removePlaceholderContent = function (placeholderContent) {
        for (var i = 0; i < this._entries.length; i++) {
            if (this._entries[i].placeholderContent === placeholderContent) {
                this._domElement.removeChild(this._entries[i].placeholderContent.domElement);
                this._entries.splice(i, 1);
                i--; 
            }
        }
    };
    Placeholder.prototype.attachToApplication = function (applicationDomElement) {
        this._applicationDomElement = applicationDomElement;
        this._applicationDomElement.appendChild(this._domElement);
    };
    Placeholder.prototype.detachFromApplication = function () {
        if (this._applicationDomElement) {
            this._applicationDomElement.appendChild(this._domElement);
            this._applicationDomElement = undefined;
        }
    };
    Placeholder.prototype._addContentDiv = function (domElement, sequence) {
        var i;
        if (this.name === placeholder_PlaceholderName.Bottom) {
            i = this._entries.length;
            while (i > 0 && sequence > this._entries[i - 1].sequence) {
                i--;
            }
        }
        else {
            i = 0;
            while (i < this._entries.length && sequence >= this._entries[i].sequence) {
                i++;
            }
        }
        if (i < this._entries.length) {
            var nextDiv = this._entries[i].placeholderContent.domElement;
            this._domElement.insertBefore(domElement, nextDiv);
        }
        else {
            this._domElement.appendChild(domElement);
        }
        return i;
    };
    return Placeholder;
}());
/* harmony default export */ var placeholder_Placeholder = (Placeholder_Placeholder);

// CONCATENATED MODULE: ./lib/extensibility/placeholder/PlaceholderManager.js




var PlaceholderManager_PlaceholderManager =  (function () {
    function PlaceholderManager(serviceScope) {
        this._isEnabled = false;
        this._changedEvent = new sp_core_library_["SPEvent"](PlaceholderManager.placeholdersChangedEventName);
        this._placeholders = new Map();
        this._placeholders.set(placeholder_PlaceholderName.Top, this._createPlaceholder(placeholder_PlaceholderName.Top));
        this._placeholders.set(placeholder_PlaceholderName.Bottom, this._createPlaceholder(placeholder_PlaceholderName.Bottom));
    }
    Object.defineProperty(PlaceholderManager.prototype, "changedEvent", {
        get: function () {
            return this._changedEvent;
        },
        enumerable: true,
        configurable: true
    });
    PlaceholderManager.prototype.initializePlaceholders = function (definitions) {
        var _this = this;
        sp_core_library_["Validate"].isNotNullOrUndefined(definitions, 'definitions');
        definitions.forEach(function (def) { return _this.addPlaceholder(def.name, def.domElement); });
    };
    PlaceholderManager.prototype.addPlaceholder = function (name, domElement) {
        sp_core_library_["Validate"].isTrue(this.placeholders.has(name), 'placeholder exists');
        this._placeholders.get(name).attachToApplication(domElement);
        sp_core_library_["_SPEventManager"].instance.raiseStickyEvent(PlaceholderManager.placeholdersChangedEventName, new sp_core_library_["SPEventArgs"]());
    };
    PlaceholderManager.prototype.removePlaceholder = function (name) {
        sp_core_library_["Validate"].isTrue(this.placeholders.has(name), 'placeholder exists');
        this._placeholders.get(name).detachFromApplication();
        sp_core_library_["_SPEventManager"].instance.raiseStickyEvent(PlaceholderManager.placeholdersChangedEventName, new sp_core_library_["SPEventArgs"]());
    };
    Object.defineProperty(PlaceholderManager.prototype, "isEnabled", {
        get: function () {
            return this._isEnabled;
        },
        enumerable: true,
        configurable: true
    });
    PlaceholderManager.prototype._enable = function () {
        this._isEnabled = true;
    };
    Object.defineProperty(PlaceholderManager.prototype, "placeholders", {
        get: function () {
            return this._placeholders;
        },
        enumerable: true,
        configurable: true
    });
    PlaceholderManager.prototype._createPlaceholder = function (name) {
        return new placeholder_Placeholder({ name: name, domElement: document.createElement('div') }, this);
    };
    PlaceholderManager.serviceKey = sp_core_library_["ServiceKey"].create('sp-application-base:PlaceholderManager', PlaceholderManager);
    PlaceholderManager.placeholdersChangedEventName = 'placeholders.changedEvent';
    return PlaceholderManager;
}());
/* harmony default export */ var placeholder_PlaceholderManager = (PlaceholderManager_PlaceholderManager);

// CONCATENATED MODULE: ./lib/extensibility/placeholder/PlaceholderProvider.js


var PlaceholderProvider_PlaceholderProvider =  (function () {
    function PlaceholderProvider(serviceScope, sequence) {
        var _this = this;
        this._placeholderContents = [];
        this._isDisposed = false;
        this._sequence = sequence;
        serviceScope.whenFinished(function () {
            _this._placeholderManager = serviceScope.consume(placeholder_PlaceholderManager.serviceKey);
        });
    }
    PlaceholderProvider.prototype.dispose = function () {
        if (!this._isDisposed) {
            this._placeholderContents.forEach(function (content) { return content.dispose(); });
            delete this._placeholderContents;
            delete this._placeholderManager;
        }
        this._isDisposed = true;
    };
    Object.defineProperty(PlaceholderProvider.prototype, "isDisposed", {
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    PlaceholderProvider.prototype.tryCreateContent = function (name, options) {
        sp_diagnostics_["_TraceLogger"].logVerbose(PlaceholderProvider._logSource, "Creating placeholder content in placeholder \"" + name + "\"");
        var qosMonitor = new sp_diagnostics_["_QosMonitor"]('Placeholder.tryCreateContent');
        if (this._placeholderManager.changedEvent._listenerCount() === 0) {
            console.log('tryCreateContent was called, but PlaceholderProvider.changedEvent has no handlers. ' +
                'This is likely to cause an error in the future.  You should probably be calling ' +
                'tryCreateContent in the PlaceholderProvider.changedEvent callback.');
        }
        if (!this._placeholderManager.isEnabled || !this._placeholderManager.placeholders.has(name)) {
            var error = new Error("No placeholder found with the name '" + name + "'");
            qosMonitor.writeExpectedFailure('PlaceholderNotFound', error, { name: name });
            return undefined;
        }
        var placeholder = this._placeholderManager.placeholders.get(name);
        if (!placeholder) {
            var error = new Error('Placeholder dictionary has only the key but not the value for the placeholder');
            qosMonitor.writeUnexpectedFailure('NoValueInPlaceholdersMap', error, { name: name });
            return undefined;
        }
        var content;
        try {
            content = placeholder.createPlaceholderContent(this._sequence, options);
        }
        catch (error) {
            qosMonitor.writeUnexpectedFailure('CreateContentFailed', error, { name: name });
            return undefined;
        }
        if (content) {
            this._placeholderContents.push(content);
            qosMonitor.writeSuccess({ name: name });
        }
        else {
            var error = new Error('Placeholder could not create new content');
            qosMonitor.writeUnexpectedFailure('CreateContentUndefined', error, { name: name });
        }
        return content;
    };
    Object.defineProperty(PlaceholderProvider.prototype, "placeholderNames", {
        get: function () {
            if (!this._placeholderManager.isEnabled) {
                return [];
            }
            var array = [];
            this._placeholderManager.placeholders.forEach(function (value, key) { return array.push(key); });
            return array;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlaceholderProvider.prototype, "changedEvent", {
        get: function () {
            return this._placeholderManager.changedEvent;
        },
        enumerable: true,
        configurable: true
    });
    PlaceholderProvider._logSource = sp_diagnostics_["_LogSource"].create('PlaceholderProvider');
    return PlaceholderProvider;
}());
/* harmony default export */ var placeholder_PlaceholderProvider = (PlaceholderProvider_PlaceholderProvider);

// EXTERNAL MODULE: external "@microsoft/decorators"
var decorators_ = __webpack_require__(15);
var decorators__default = /*#__PURE__*/__webpack_require__.n(decorators_);

// EXTERNAL MODULE: external "@microsoft/sp-component-base"
var sp_component_base_ = __webpack_require__(40);
var sp_component_base__default = /*#__PURE__*/__webpack_require__.n(sp_component_base_);

// EXTERNAL MODULE: external "@microsoft/sp-loader"
var sp_loader_ = __webpack_require__(3);
var sp_loader__default = /*#__PURE__*/__webpack_require__.n(sp_loader_);

// EXTERNAL MODULE: external "@microsoft/sp-http"
var sp_http_ = __webpack_require__(6);
var sp_http__default = /*#__PURE__*/__webpack_require__.n(sp_http_);

// EXTERNAL MODULE: C:/agent/1/_work/9/s/common/temp/node_modules/.onedrive.pkgs.visualstudio.com/@ms/odsp-utilities/27.23.2/node_modules/@ms/odsp-utilities/lib/theming/SuiteNavTheming.js
var SuiteNavTheming = __webpack_require__(72);
var SuiteNavTheming_default = /*#__PURE__*/__webpack_require__.n(SuiteNavTheming);

// EXTERNAL MODULE: C:/agent/1/_work/9/s/common/temp/node_modules/.onedrive.pkgs.visualstudio.com/@ms/odsp-utilities/27.23.2/node_modules/@ms/odsp-utilities/lib/models/store/BaseDataStore.js
var BaseDataStore = __webpack_require__(9);
var BaseDataStore_default = /*#__PURE__*/__webpack_require__.n(BaseDataStore);

// EXTERNAL MODULE: C:/agent/1/_work/9/s/common/temp/node_modules/.onedrive.pkgs.visualstudio.com/@ms/odsp-utilities/27.23.2/node_modules/@ms/odsp-utilities/lib/models/store/DataStoreCachingType.js
var DataStoreCachingType = __webpack_require__(7);
var DataStoreCachingType_default = /*#__PURE__*/__webpack_require__.n(DataStoreCachingType);

// EXTERNAL MODULE: external "@ms/sp-telemetry"
var sp_telemetry_ = __webpack_require__(10);
var sp_telemetry__default = /*#__PURE__*/__webpack_require__.n(sp_telemetry_);

// CONCATENATED MODULE: C:/agent/1/_work/9/s/libraries/sp-suite-nav/lib/models/IShellBaseTheme.js
var DEFAULT_APP_BRAND_THEME = {
    Primary: '#0078D4'
};

// CONCATENATED MODULE: C:/agent/1/_work/9/s/libraries/sp-suite-nav/lib/models/SuiteNavLinkIds.js
var SuiteNavLinkIds =  (function () {
    function SuiteNavLinkIds() {
    }
    SuiteNavLinkIds.CUSTOM_SETTINGS_1 = 'WorkloadSettingsSubLinks1';
    SuiteNavLinkIds.CUSTOM_SETTINGS_2 = 'WorkloadSettingsSubLinks2';
    SuiteNavLinkIds.CUSTOM_SETTINGS_3 = 'WorkloadSettingsSubLinks3';
    SuiteNavLinkIds.FEEDBACK = 'ShellFeedback';
    SuiteNavLinkIds.DIAGNOSTICS = 'Diagnostics';
    SuiteNavLinkIds.O365_SETTINGS = 'ShellO365Settings'; 
    SuiteNavLinkIds.ADD_APP = 'SuiteMenu_zz5_MenuItemCreate'; 
    SuiteNavLinkIds.CREATE_PAGE = 'SuiteMenu_MenuItemCreatePage'; 
    SuiteNavLinkIds.SITE_CONTENTS = 'SuiteMenu_zz6_MenuItem_ViewAllSiteContents'; 
    SuiteNavLinkIds.SITE_SETTINGS = 'SuiteMenu_zz7_MenuItem_Settings'; 
    SuiteNavLinkIds.USER_ACTIVITY = 'UserActivity'; 
    SuiteNavLinkIds.ABOUT_ME = 'ShellAboutMe'; 
    SuiteNavLinkIds.SETTINGS = 'ShellSettings'; 
    SuiteNavLinkIds.MY_SETTINGS = 'SuiteMenu_zz2_ID_PersonalInformation'; 
    SuiteNavLinkIds.SIGN_OUT = 'ShellSignout';
    SuiteNavLinkIds.HELP = 'HelpLink';
    SuiteNavLinkIds.COMMUNITY = 'ShellCommunity';
    SuiteNavLinkIds.PRIVACY = 'ShellPrivacy';
    SuiteNavLinkIds.LEGAL = 'ShellLegal';
    SuiteNavLinkIds.ADMIN = 'ShellAdmin';
    SuiteNavLinkIds.MAIL = 'ShellMail'; 
    SuiteNavLinkIds.CALENDAR = 'ShellCalendar';
    SuiteNavLinkIds.PEOPLE = 'ShellPeople';
    SuiteNavLinkIds.ONEDRIVE = 'ShellDocuments'; 
    SuiteNavLinkIds.SHAREPOINT = 'ShellSharepoint';
    SuiteNavLinkIds.WORD = 'ShellWordOnline';
    SuiteNavLinkIds.EXCEL = 'ShellExcelOnline';
    SuiteNavLinkIds.POWERPOINT = 'ShellPowerPointOnline';
    SuiteNavLinkIds.ONENOTE = 'ShellOneNoteOnline';
    SuiteNavLinkIds.SITES = 'ShellSites';
    SuiteNavLinkIds.YAMMER = 'ShellYammer';
    SuiteNavLinkIds.TASKS = 'ShellTasks';
    SuiteNavLinkIds.POWER_BI = 'ShellPowerBI';
    SuiteNavLinkIds.DELVE = 'ShellOfficeGraph'; 
    SuiteNavLinkIds.VIDEO = 'ShellVideo';
    SuiteNavLinkIds.ALCHEMY = 'ShellAlchemy';
    SuiteNavLinkIds.SMILE = 'ShellSendASmile';
    SuiteNavLinkIds.SHAREPOINT_WORKLOAD = 'Sharepoint';
    return SuiteNavLinkIds;
}());
/* harmony default export */ var models_SuiteNavLinkIds = (SuiteNavLinkIds);

// CONCATENATED MODULE: C:/agent/1/_work/9/s/libraries/sp-suite-nav/lib/dataAccess/SPOSuiteNavDataSource.js


var SPOSuiteNavDataSource_SPOSuiteNavDataSource =  (function () {
    function SPOSuiteNavDataSource(httpClient, currentUICultureName, webServerRelativeUrl) {
        this.suiteNavService = 0 ;
        this._currentUICultureName = currentUICultureName;
        this._spHttpClient = httpClient;
        this._siteRelUrl = webServerRelativeUrl === '/' ? '' : webServerRelativeUrl;
    }
    SPOSuiteNavDataSource.prototype.loadData = function () {
        var url = this._siteRelUrl
            + '/_layouts/15/online/handlers/SpoSuiteLinks.ashx?Locale='
            + this._currentUICultureName
            + '&v=2&mobilereq=0&msajax=1';
        var qosMonitor = new sp_diagnostics_["_QosMonitor"]('SPOSuiteNavDataSource');
        return this._spHttpClient.post(url, sp_http_["SPHttpClient"].configurations.v1, {})
            .then(function (response) {
            if (response.status !== 200 || response.headers.get('SharePointError')) {
                var errorMessage = 'Failed to retrieve SPO SuiteNavData';
                var error = new Error(errorMessage);
                sp_diagnostics_["_TraceLogger"].logVerbose(SPOSuiteNavDataSource._logSource, errorMessage);
                qosMonitor.writeUnexpectedFailure('FailedToRetrieveSPOSuiteNavData', error, {
                    responseStatus: response ? response.status : '',
                    correlationId: response ? response.correlationId : ''
                });
                return Promise.reject(errorMessage);
            }
            qosMonitor.writeSuccess();
            return response.json().then(function (jsonResponse) {
                return jsonResponse;
            });
        });
    };
    SPOSuiteNavDataSource._logSource = sp_diagnostics_["_LogSource"].create('SPOSuiteNavDataSource');
    return SPOSuiteNavDataSource;
}());
/* harmony default export */ var dataAccess_SPOSuiteNavDataSource = (SPOSuiteNavDataSource_SPOSuiteNavDataSource);

// CONCATENATED MODULE: C:/agent/1/_work/9/s/libraries/sp-suite-nav/lib/dataAccess/OnPremSuiteNavDataSource.js



var OnPremSuiteNavDataSource_OnPremSuiteNavDataSource =  (function () {
    function OnPremSuiteNavDataSource(httpClient, currentUICultureName, webServerRelativeUrl) {
        this.suiteNavService = 1 ;
        this._currentUICultureName = currentUICultureName;
        this._spHttpClient = httpClient;
        this._siteRelUrl = webServerRelativeUrl === '/' ? '' : webServerRelativeUrl;
    }
    OnPremSuiteNavDataSource.prototype.loadData = function () {
        var _this = this;
        var url = this._siteRelUrl
            + '/_api/Microsoft.SharePoint.Portal.SuiteNavData.GetSuiteNavData?v=2&Locale='
            + this._currentUICultureName;
        var qosMonitor = new sp_diagnostics_["_QosMonitor"]('OnPremSuiteNavDataSource');
        return this._spHttpClient.get(url, sp_http_["SPHttpClient"].configurations.v1)
            .then(function (response) {
            if (response.status !== 200) {
                _this._logAndThrowSuiteNavLoadingError(qosMonitor, response);
            }
            return response.json().then(function (jsonString) {
                if (jsonString.value === '') {
                    _this._logAndThrowSuiteNavLoadingError(qosMonitor, response);
                }
                else {
                    qosMonitor.writeSuccess();
                    var suiteNavResponse = JSON.parse(jsonString.value);
                    if (suiteNavResponse.NavBarData && !suiteNavResponse.NavBarData.Dimensions) {
                        suiteNavResponse.NavBarData.Dimensions = { Top: lib_SuiteNavManager._defaultSuiteNavHeight };
                    }
                    return suiteNavResponse; 
                }
            });
        });
    };
    OnPremSuiteNavDataSource.prototype._logAndThrowSuiteNavLoadingError = function (qosMonitor, response) {
        var errorMessage = 'Failed to retrieve Hybrid SuiteNavData';
        var error = new Error(errorMessage);
        qosMonitor.writeUnexpectedFailure('FailedToRetrieveOnPremSuiteNavData', error, {
            responseStatus: response ? response.status : '',
            correlationId: response ? response.correlationId : ''
        });
        sp_diagnostics_["_TraceLogger"].logVerbose(OnPremSuiteNavDataSource._logSource, errorMessage);
        throw error;
    };
    OnPremSuiteNavDataSource._logSource = sp_diagnostics_["_LogSource"].create('OnPremSuiteNavDataSource');
    return OnPremSuiteNavDataSource;
}());
/* harmony default export */ var dataAccess_OnPremSuiteNavDataSource = (OnPremSuiteNavDataSource_OnPremSuiteNavDataSource);

// CONCATENATED MODULE: C:/agent/1/_work/9/s/libraries/sp-suite-nav/lib/FlexPaneWrapper.js

var FlexPaneWrapper_FlexPaneWrapper =  (function () {
    function FlexPaneWrapper() {
    }
    FlexPaneWrapper.prototype.OnFlexPaneVisibilityChanged = function (callback) {
        try {
            return O365Shell.FlexPane.OnFlexPaneVisibilityChanged(callback);
        }
        catch (e) {
            this._createFlexPaneWrapperErrorLogEntry('OnFlexPaneVisibilityChanged', e);
        }
    };
    FlexPaneWrapper.prototype.OpenFlexPaneForProvider = function (provider) {
        try {
            O365Shell.FlexPane.OpenFlexPaneForProvider(provider);
        }
        catch (e) {
            this._createFlexPaneWrapperErrorLogEntry('OpenFlexPaneForProvider', e);
        }
    };
    FlexPaneWrapper.prototype._createFlexPaneWrapperErrorLogEntry = function (moduleName, errorMessage) {
        sp_diagnostics_["_TraceLogger"].logVerbose(FlexPaneWrapper.logSource, 'FlexPaneWrapper ' + moduleName + ' ' + errorMessage);
    };
    FlexPaneWrapper.logSource = sp_diagnostics_["_LogSource"].create('FlexPaneWrapper');
    return FlexPaneWrapper;
}());
/* harmony default export */ var lib_FlexPaneWrapper = (FlexPaneWrapper_FlexPaneWrapper);

// CONCATENATED MODULE: C:/agent/1/_work/9/s/libraries/sp-suite-nav/lib/NavigationWrapper.js
var NavigationWrapper =  (function () {
    function NavigationWrapper() {
    }
    NavigationWrapper.prototype.OnLinkClick = function (callback) {
        return O365Shell.Navigation.OnLinkClick(callback);
    };
    NavigationWrapper.prototype.OnHamburgerButtonClick = function (callback) {
        return O365Shell.Navigation.OnHamburgerButtonClick(callback);
    };
    return NavigationWrapper;
}());
/* harmony default export */ var lib_NavigationWrapper = (NavigationWrapper);

// CONCATENATED MODULE: C:/agent/1/_work/9/s/libraries/sp-suite-nav/lib/O365ShellSettingsWrapper.js
var O365ShellSettingsWrapper =  (function () {
    function O365ShellSettingsWrapper() {
    }
    O365ShellSettingsWrapper.prototype.AddOrUpdateWorkloadSettingLink = function (settingLink) {
        try {
            if (O365Shell && O365Shell.Settings) {
                return O365Shell.Settings.AddOrUpdateWorkloadSettingLink(settingLink);
            }
        }
        catch (e) {
        }
    };
    O365ShellSettingsWrapper.prototype.RemoveWorkloadSettingLink = function (settingLinkID) {
        try {
            if (O365Shell && O365Shell.Settings) {
                return O365Shell.Settings.RemoveWorkloadSettingLink(settingLinkID);
            }
        }
        catch (e) {
        }
    };
    O365ShellSettingsWrapper.prototype.SetWorkloadSettingsLinks = function (settingLink) {
        try {
            if (O365Shell && O365Shell.Settings) {
                return O365Shell.Settings.SetWorkloadSettingsLinks(settingLink);
            }
        }
        catch (e) {
        }
    };
    return O365ShellSettingsWrapper;
}());
/* harmony default export */ var lib_O365ShellSettingsWrapper = (O365ShellSettingsWrapper);

// CONCATENATED MODULE: C:/agent/1/_work/9/s/libraries/sp-suite-nav/lib/O365ShellWrapper.js



var O365ShellWrapper_O365ShellWrapper =  (function () {
    function O365ShellWrapper() {
        this._postRenderSignal = new Promise(function () {
            return;
        });
        this.FlexPane = new lib_FlexPaneWrapper();
        this.Navigation = new lib_NavigationWrapper();
    }
    Object.defineProperty(O365ShellWrapper.prototype, "Settings", {
        get: function () {
            if (!this._o365ShellSettings) {
                if (this.DoesShellExist() && O365Shell.Settings) {
                    this._o365ShellSettings = new lib_O365ShellSettingsWrapper();
                }
            }
            return this._o365ShellSettings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(O365ShellWrapper.prototype, "Theme", {
        get: function () {
            if (this.DoesShellExist() && O365Shell.Theme) {
                return O365Shell.Theme;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(O365ShellWrapper.prototype, "Search", {
        get: function () {
            if (this.DoesShellExist() && O365Shell.Search) {
                return O365Shell.Search;
            }
        },
        enumerable: true,
        configurable: true
    });
    O365ShellWrapper.prototype.SetData = function (shellData) {
        O365Shell.SetData(shellData);
    };
    O365ShellWrapper.prototype.Render = function (renderSettings, postRendercallback) {
        O365Shell.Render(renderSettings, postRendercallback);
    };
    O365ShellWrapper.prototype.RenderAsync = function (renderSettings, renderCallback, postRenderCallback) {
        O365Shell.RenderAsync(renderSettings, renderCallback, postRenderCallback);
    };
    O365ShellWrapper.prototype.LoadShellPlus = function () {
        O365Shell.LoadShellPlus();
    };
    O365ShellWrapper.prototype.DoesShellExist = function () {
        return typeof O365Shell !== 'undefined';
    };
    O365ShellWrapper.prototype.OnHasMember = function (memberName, callback) {
        var _this = this;
        if (this._hasMember(memberName)) {
            callback();
        }
        else {
            this._postRenderSignal.then(function () { return _this.OnHasMember(memberName, callback); });
        }
    };
    O365ShellWrapper.prototype.AddOrUpdateWorkloadSettingLink = function (settingLink) {
        if (this.DoesShellExist() && this.Settings) {
            this.Settings.AddOrUpdateWorkloadSettingLink(settingLink);
        }
    };
    O365ShellWrapper.prototype.RemoveWorkloadSettingLink = function (settingLinkID) {
        if (this.DoesShellExist() && this.Settings) {
            this.Settings.RemoveWorkloadSettingLink(settingLinkID);
        }
    };
    O365ShellWrapper.prototype.SetWorkloadSettingsLinks = function (settingsLinks) {
        if (this.DoesShellExist() && this.Settings) {
            this.Settings.SetWorkloadSettingsLinks(settingsLinks);
        }
    };
    O365ShellWrapper.prototype._hasMember = function (memberName) {
        return this.DoesShellExist() && Boolean(O365Shell[memberName]);
    };
    return O365ShellWrapper;
}());
/* harmony default export */ var lib_O365ShellWrapper = (O365ShellWrapper_O365ShellWrapper);

// CONCATENATED MODULE: C:/agent/1/_work/9/s/libraries/sp-suite-nav/lib/SuiteNavManager.js














var SuiteNavManager_SuiteNavManager =  (function () {
    function SuiteNavManager(suiteNavDiv, serviceScope, isFullPageLoad) {
        if (isFullPageLoad === void 0) { isFullPageLoad = true; }
        var _this = this;
        this._suiteNavDiv = suiteNavDiv;
        this._isFullPageLoad = isFullPageLoad;
        serviceScope.whenFinished(function () {
            _this._httpClient = serviceScope.consume(sp_http_["SPHttpClient"].serviceKey);
        });
    }
    SuiteNavManager._updateCache = function (model, service) {
        SuiteNavManager._cache.setValue(SuiteNavManager.DATA_KEY, model);
        SuiteNavManager._cache.setValue(SuiteNavManager.DATE_KEY, new Date());
        SuiteNavManager._cache.setValue(SuiteNavManager.VERSION_KEY, SuiteNavManager.CACHE_VERSION);
        SuiteNavManager._cache.setValue(SuiteNavManager.SESSION_KEY, true, DataStoreCachingType_default.a.session);
        SuiteNavManager._cache.setValue(SuiteNavManager.SERVICE_KEY, service);
    };
    SuiteNavManager._clearCache = function () {
        SuiteNavManager._cache.remove(SuiteNavManager.DATA_KEY);
        SuiteNavManager._cache.remove(SuiteNavManager.DATE_KEY);
        SuiteNavManager._cache.remove(SuiteNavManager.VERSION_KEY);
        SuiteNavManager._cache.remove(SuiteNavManager.SERVICE_KEY);
    };
    SuiteNavManager.getCachedThemeData = function () {
        var cachedThemeData;
        var themeDataCache = SuiteNavManager._cache.getValue(SuiteNavManager.THEME_KEY);
        if (themeDataCache && themeDataCache.themeData) {
            cachedThemeData = themeDataCache.themeData;
        }
        return cachedThemeData;
    };
    SuiteNavManager.updateCachedThemeData = function (themeData) {
        var themeCache = {
            themeData: themeData,
            cacheDate: new Date()
        };
        SuiteNavManager._cache.setValue(SuiteNavManager.THEME_KEY, themeCache);
    };
    SuiteNavManager.prototype.loadSuiteNav = function (suiteNavConfig) {
        var _this = this;
        sp_core_library_["Validate"].isNotNullOrUndefined(suiteNavConfig, 'suiteNavConfig');
        if (this._isSuiteNavNewFlowFlightEnabled()) {
            this._initializeSuiteNavConfig(suiteNavConfig);
            this._completeSuiteNavNewFlow();
        }
        else {
            this._initializeSuiteNavConfig(suiteNavConfig);
            var o365ShellWrapper_1 = new lib_O365ShellWrapper();
            this._suiteNavModelPromise = this._getSuiteNavModel(o365ShellWrapper_1.DoesShellExist());
            this._suiteNavModelPromise.then(function (suiteNavModel) {
                var suiteNavJSPromise = !o365ShellWrapper_1.DoesShellExist() ?
                    _this._getSuiteNavShell(suiteNavModel.CssUrl, suiteNavModel.JsUrl, suiteNavModel) :
                    Promise.resolve(undefined);
                suiteNavJSPromise.then(function () {
                    _this._setO365ShellData(o365ShellWrapper_1, suiteNavModel.NavBarData);
                    _this._renderSuiteNav(o365ShellWrapper_1);
                });
            });
        }
    };
    SuiteNavManager.prototype.loadSuiteNavNewFlow = function (suiteNavConfig) {
        var _this = this;
        sp_core_library_["Validate"].isNotNullOrUndefined(suiteNavConfig, 'suiteNavConfig');
        this._initializeSuiteNavConfig(suiteNavConfig);
        var qosMonitor = new sp_diagnostics_["_QosMonitor"]('SuiteNavManager');
        this._suiteNavLoadStart = sp_telemetry_["_PerformanceLogger"].now();
        this.o365ShellWrapperPromise.then(function (o365Shell) { return _this._renderSuiteNav(o365Shell, qosMonitor); }).catch(function (errorMessage) {
            qosMonitor.writeUnexpectedFailure('SuiteNavManagerFailure', new Error(errorMessage));
        });
    };
    SuiteNavManager.prototype._initializeSuiteNavConfig = function (suiteNavConfig) {
        this._suiteNavManagerConfiguration = suiteNavConfig;
        if (this._suiteNavManagerConfiguration.updateSuiteNavHeight) {
            this._suiteNavManagerConfiguration.updateSuiteNavHeight(SuiteNavManager._defaultSuiteNavHeight);
        }
        this._suiteNavManagerConfiguration.o365ShellRenderSettings.top = this._suiteNavDiv.id;
    };
    SuiteNavManager.prototype._completeSuiteNavNewFlow = function () {
        var _this = this;
        var o365ShellPromise = this.o365ShellWrapperPromise.then(function (o365Shell) {
            _this._renderSuiteNav(o365Shell);
            return o365Shell;
        });
        var suiteNavModelPromise = this._getSuiteNavModel(!!this._o365ShellWrapper);
        Promise.all([o365ShellPromise, suiteNavModelPromise]).then(function (promiseResults) {
            var o365ShellPromiseResult = promiseResults[0];
            var suiteNavModelPromiseResult = promiseResults[1];
            if (o365ShellPromiseResult) {
                _this._setO365ShellData(o365ShellPromiseResult, suiteNavModelPromiseResult.NavBarData);
                if (!_this._isFullPageLoad) {
                    _this._onRender(o365ShellPromiseResult);
                    _this._onPostRender();
                }
            }
        });
    };
    SuiteNavManager.prototype._getShellBootstrapHost = function () {
        var searchParams = new URLSearchParams(window.location.search);
        if (searchParams.get('usePPE') === 'true') {
            return "" + SuiteNavManager.REACT_SHELL_BOOTSTRAPPER_PPE_HOST;
        }
        else {
            return "" + SuiteNavManager.REACT_SHELL_BOOTSTRAPPER_HOST;
        }
    };
    SuiteNavManager.prototype._getShellBootstrapUrl = function () {
        return "" + this._getShellBootstrapHost() + SuiteNavManager.REACT_SHELL_BOOTSTRAPPER_API;
    };
    SuiteNavManager.prototype._getSuiteNavModel = function (forceFetchData) {
        var _this = this;
        var suiteNavModelPromise;
        if (!forceFetchData && this._isCacheValid() && !this._isCacheOutdated()) {
            suiteNavModelPromise = this._loadSuiteNavFromCache();
        }
        else {
            SuiteNavManager._clearCache();
            suiteNavModelPromise = this._loadSuiteNavFromServer();
        }
        return suiteNavModelPromise.then(function (model) {
            model.NavBarData =
                _this._suiteNavManagerConfiguration.modifySuiteNavData(model);
            model.CacheToken = _this._suiteNavManagerConfiguration.cacheToken;
            model.UserIdentifier = _this._suiteNavManagerConfiguration.systemUserKey;
            model.NavBarData.AppBrandTheme = DEFAULT_APP_BRAND_THEME;
            SuiteNavManager._updateCache(model, _this._suiteNavDataSource.suiteNavService);
            if (model && model.NavBarData && model.NavBarData.Dimensions && model.NavBarData.Dimensions.Top) {
                if (_this._suiteNavManagerConfiguration.updateSuiteNavHeight) {
                    _this._suiteNavManagerConfiguration.updateSuiteNavHeight(model.NavBarData.Dimensions.Top);
                }
            }
            return model;
        });
    };
    SuiteNavManager.prototype._loadSuiteNavFromCache = function () {
        var _this = this;
        return new Promise(function (complete) {
            SuiteNavManager._cache.getValue(SuiteNavManager.SERVICE_KEY) ===
                0  ?
                _this._suiteNavDataSource = _this._createSPODataSource() :
                _this._suiteNavDataSource = _this._createOnPremDataSource();
            complete(SuiteNavManager._cache.getValue(SuiteNavManager.DATA_KEY));
        });
    };
    SuiteNavManager.prototype._loadSuiteNavFromServer = function () {
        var _this = this;
        this._suiteNavDataSource = this._createSPODataSource();
        var onPremDataSource = this._createOnPremDataSource();
        var onPremSuiteNavResponse = onPremDataSource.loadData();
        onPremSuiteNavResponse.catch(function () {
            _this._createSuiteNavErrorLogEntry('loadData', 'Failed to retrieve Hybrid SuiteNavData');
        });
        return this._suiteNavDataSource.loadData().then(function (response) {
            return response;
        }).catch(function () {
            _this._createSuiteNavErrorLogEntry('loadData', 'Failed to retrieve SPO SuiteNavData');
            _this._suiteNavDataSource = onPremDataSource;
            return onPremSuiteNavResponse;
        });
    };
    SuiteNavManager.prototype._getSuiteNavShell = function (cssUrl, jsUrl, suiteNavModel) {
        sp_core_library_["Validate"].isNonemptyString(cssUrl, 'cssUrl');
        sp_core_library_["Validate"].isNonemptyString(jsUrl, 'jsUrl');
        var element = document.createElement('link');
        element.rel = 'stylesheet';
        element.type = 'text/css';
        element.href = cssUrl;
        document.head.appendChild(element);
        if (suiteNavModel && suiteNavModel.NavBarData && suiteNavModel.NavBarData.ClientData) {
            try {
                var clientData = JSON.parse(suiteNavModel.NavBarData.ClientData);
                if (clientData && clientData.IsFallbackShell) {
                    Object(SuiteNavTheming["loadFallbackShellThemableCss"])();
                }
            }
            catch (errClientData) {
            }
        }
        return sp_loader_["SPComponentLoader"].loadScript(jsUrl);
    };
    Object.defineProperty(SuiteNavManager.prototype, "o365ShellWrapperPromise", {
        get: function () {
            var _this = this;
            if (!this._o365ShellPromise) {
                this._o365ShellPromise =
                    sp_loader_["SPComponentLoader"].loadScript(this._getShellBootstrapUrl()).then(function () {
                        var o365ShellWrapper = new lib_O365ShellWrapper();
                        if (o365ShellWrapper.DoesShellExist()) {
                            _this._suiteNavModuleLoaded = sp_telemetry_["_PerformanceLogger"].now();
                            _this._o365ShellWrapper = o365ShellWrapper;
                            return _this._o365ShellWrapper;
                        }
                    });
            }
            return this._o365ShellPromise;
        },
        enumerable: true,
        configurable: true
    });
    SuiteNavManager.prototype._renderSuiteNav = function (o365Shell, qosMonitor) {
        var _this = this;
        if (o365Shell && !this._renderedOnce) {
            this._renderedOnce = true;
            if (this._isFullPageLoad) {
                o365Shell.RenderAsync(this._getRenderSettings(), function () {
                    _this._suiteNavRendered = sp_telemetry_["_PerformanceLogger"].now();
                    if (qosMonitor) {
                        qosMonitor.writeSuccess({
                            suiteNavLoadStart: _this._suiteNavLoadStart,
                            suiteNavModuleLoaded: _this._suiteNavModuleLoaded,
                            suiteNavRendered: _this._suiteNavRendered
                        });
                    }
                    _this._onRender(o365Shell);
                }, function () {
                    _this._onPostRender();
                });
            }
            else if (!this._isSuiteNavNewFlowFlightEnabled()) {
                this._onRender(o365Shell);
                this._onPostRender();
            }
            o365Shell.OnHasMember('LoadShellPlus', function () {
                _this._loadShellPlus(o365Shell);
            });
            if (o365Shell.Theme) {
                o365Shell.Theme.OnThemeChanged(function (themeData) {
                    return SuiteNavManager.updateCachedThemeData(themeData);
                });
            }
        }
    };
    SuiteNavManager.prototype._setO365ShellData = function (o365Shell, navBarData) {
        o365Shell.SetData(navBarData);
    };
    SuiteNavManager.prototype._getRenderSettings = function () {
        if (this._isSuiteNavNewFlowFlightEnabled()) {
            var cachedThemeData = SuiteNavManager.getCachedThemeData();
            return tslib_es6["__assign"]({}, this._suiteNavManagerConfiguration.o365ShellRenderSettings, { initialRenderData: {
                    AppBrandTheme: cachedThemeData ? cachedThemeData : DEFAULT_APP_BRAND_THEME,
                    Culture: this._suiteNavManagerConfiguration.currentUICultureName,
                    CurrentMainLinkElementID: models_SuiteNavLinkIds.SITES,
                    IsConsumer: false,
                    ShellBootHost: this._getShellBootstrapHost(),
                    UserDisplayName: this._suiteNavManagerConfiguration.userDisplayName,
                    UserID: this._suiteNavManagerConfiguration.userId,
                    WorkloadId: models_SuiteNavLinkIds.SHAREPOINT_WORKLOAD
                } });
        }
        else {
            return this._suiteNavManagerConfiguration.o365ShellRenderSettings;
        }
    };
    SuiteNavManager.prototype._onRender = function (o365Shell) {
        var actionsMap = this._suiteNavManagerConfiguration.getActionsMap();
        if (actionsMap && Object.keys(actionsMap).length > 0) {
            o365Shell.Navigation.OnLinkClick(function (eventArgs) {
                var action = actionsMap && actionsMap[eventArgs.Id];
                if (action) {
                    action();
                }
            });
        }
        if (this._suiteNavManagerConfiguration.hamburgerCallback) {
            if (o365Shell.Navigation.OnHamburgerButtonClick) {
                o365Shell.Navigation.OnHamburgerButtonClick(this._suiteNavManagerConfiguration.hamburgerCallback);
            }
        }
    };
    SuiteNavManager.prototype._onPostRender = function () {
        if (this._suiteNavManagerConfiguration.suiteNavPostRenderCallback) {
            this._suiteNavManagerConfiguration.suiteNavPostRenderCallback();
        }
    };
    SuiteNavManager.prototype._loadShellPlus = function (o365Shell) {
        var _this = this;
        return new Promise(function () {
            o365Shell.LoadShellPlus();
        }).catch(function (errorMessage) {
            _this._createSuiteNavErrorLogEntry('loadShellPlus', errorMessage);
        });
    };
    SuiteNavManager.prototype._isCacheValid = function () {
        var model = SuiteNavManager._cache.getValue(SuiteNavManager.DATA_KEY);
        var oldVersion = SuiteNavManager._cache.getValue(SuiteNavManager.VERSION_KEY);
        var cssJsUrlPresent = model && model.NavBarData && (model.JsUrl.length > 0 && model.CssUrl.length > 0);
        var sameVersion = oldVersion === SuiteNavManager.CACHE_VERSION;
        var sameUser = model && model.UserIdentifier === this._suiteNavManagerConfiguration.systemUserKey;
        var sameCacheToken = model && model.CacheToken === this._suiteNavManagerConfiguration.cacheToken;
        return cssJsUrlPresent && sameVersion && sameUser && sameCacheToken;
    };
    SuiteNavManager.prototype._isCacheOutdated = function () {
        var cacheDate = Date.parse(SuiteNavManager._cache.getValue(SuiteNavManager.DATE_KEY));
        var currentDate = new Date();
        var cachedThisSession = SuiteNavManager._cache.getValue(SuiteNavManager.SESSION_KEY, DataStoreCachingType_default.a.session);
        return (isNaN(cacheDate) ||
            currentDate.getTime() - cacheDate > 24 * 60 * 60 * 1000 ||
            (BaseDataStore_default.a.hasStorageType(DataStoreCachingType_default.a.session) && !cachedThisSession));
    };
    SuiteNavManager.prototype._createSPODataSource = function () {
        return new dataAccess_SPOSuiteNavDataSource(this._httpClient, this._suiteNavManagerConfiguration.currentUICultureName, this._suiteNavManagerConfiguration.webServerRelativeUrl);
    };
    SuiteNavManager.prototype._createOnPremDataSource = function () {
        return new dataAccess_OnPremSuiteNavDataSource(this._httpClient, this._suiteNavManagerConfiguration.currentUICultureName, this._suiteNavManagerConfiguration.webServerRelativeUrl);
    };
    SuiteNavManager.prototype._createSuiteNavErrorLogEntry = function (moduleName, errorMessage) {
        sp_diagnostics_["_TraceLogger"].logVerbose(SuiteNavManager._logSource, 'SuiteNavManager ' + moduleName + ' ' + errorMessage);
    };
    SuiteNavManager.prototype._isSuiteNavNewFlowFlightEnabled = function () {
        return sp_core_library_["_SPFlight"].isEnabled(1309 );
    };
    SuiteNavManager._defaultSuiteNavHeight = '50px';
    SuiteNavManager.CACHE_PREFIX = 'SPPPLATSuiteNav';
    SuiteNavManager.SERVICE_KEY = 'SuiteNavService';
    SuiteNavManager.DATA_KEY = 'Data';
    SuiteNavManager.DATE_KEY = 'CacheDate';
    SuiteNavManager.VERSION_KEY = 'CacheVersion';
    SuiteNavManager.SESSION_KEY = 'CachedThisSession';
    SuiteNavManager.THEME_KEY = 'ThemeData';
    SuiteNavManager.REACT_SHELL_BOOTSTRAPPER_HOST = 'https://shellprod.msocdn.com';
    SuiteNavManager.REACT_SHELL_BOOTSTRAPPER_PPE_HOST = 'https://shellppe.msocdn.com';
    SuiteNavManager.REACT_SHELL_BOOTSTRAPPER_API = '/api/shellbootstrapper/business/oneshell';
    SuiteNavManager.CACHE_VERSION = 1;
    SuiteNavManager._cache = new BaseDataStore_default.a(SuiteNavManager.CACHE_PREFIX, DataStoreCachingType_default.a.local);
    SuiteNavManager._logSource = sp_diagnostics_["_LogSource"].create('SuiteNavManager');
    return SuiteNavManager;
}());
/* harmony default export */ var lib_SuiteNavManager = (SuiteNavManager_SuiteNavManager);

// CONCATENATED MODULE: C:/agent/1/_work/9/s/libraries/sp-suite-nav/lib/SuiteNavManagerConfiguration.js




var SUITE_NAV_USE_SPO_BEHAVIOR_KILL_SWITCH = sp_core_library_["Guid"].parse('22F8084E-9DEB-4642-B63E-E70A7F87C998');
var SuiteNavManagerConfiguration_SuiteNavManagerConfiguration =  (function () {
    function SuiteNavManagerConfiguration(suiteNavConfig) {
        this._currentUICultureName = suiteNavConfig.currentUICultureName;
        this._settingsLinks = suiteNavConfig.settingsData;
        this._signoutUrl = suiteNavConfig.signoutUrl;
        this._siteClientTag = suiteNavConfig.siteClientTag;
        this._systemUserKey = suiteNavConfig.systemUserKey;
        this._webServerRelativeUrl = suiteNavConfig.webServerRelativeUrl;
        this._isSuiteNavDisabled = !!suiteNavConfig.disableSuiteNav;
        this._isSuiteNavLoadingDeferred = !!suiteNavConfig.deferSuiteNavLoading;
        this._o365ShellRenderSettings = {
            collapseO365Settings: true,
            disableDelayLoad: false,
            disableShellPlus: false,
            layout: 'Mouse',
            enableSearchUX: this.isSearchBoxInHeaderFlighted(),
            top: undefined 
        };
        this._hamburgerMenuCallback = undefined;
        this._suiteNavPostRenderCallback = undefined;
        this._webTemplateId = suiteNavConfig.webTemplateId;
        this._userDisplayName = suiteNavConfig.userDisplayName;
    }
    SuiteNavManagerConfiguration.prototype.isSuiteNavDisabled = function () {
        return this._isSuiteNavDisabled;
    };
    SuiteNavManagerConfiguration.prototype.disableSuiteNav = function () {
        this._isSuiteNavDisabled = true;
    };
    SuiteNavManagerConfiguration.prototype.isSuiteNavLoadingDeferred = function () {
        return this._isSuiteNavLoadingDeferred;
    };
    SuiteNavManagerConfiguration.prototype.deferSuiteNavLoading = function () {
        this._isSuiteNavLoadingDeferred = true;
    };
    SuiteNavManagerConfiguration.prototype.modifySuiteNavData = function (suiteNavModel) {
        var suiteNavData = suiteNavModel.NavBarData;
        if (!sp_core_library_["_SPKillSwitch"].isActivated(sp_core_library_["Guid"].parse('5bafa34c-ba7d-4de4-97e8-1cdfb4ce051e'), '3/2/2018', 'Add SharePoint text in SuiteNav Banner')) {
            suiteNavData.CurrentMainLinkElementID = models_SuiteNavLinkIds.SITES;
        }
        suiteNavData.CurrentWorkloadSettingsSubLinks =
            this._settingsLinks && this._settingsLinks.length > 0 ? this._settingsLinks : undefined;
        suiteNavData.FeedbackLink = undefined;
        if (suiteNavData.SignOutLink && this._signoutUrl) {
            suiteNavData.SignOutLink.Url = this._signoutUrl;
        }
        if (suiteNavData.HelpLink) {
            suiteNavData.HelpLink.Url = 'https://go.microsoft.com/fwlink/p/?linkid=827181';
        }
        if (!sp_core_library_["_SPKillSwitch"].isActivated(SUITE_NAV_USE_SPO_BEHAVIOR_KILL_SWITCH, '9/08/2017', 'SuiteNavUseSPOBehaviors')) {
            var webTemplate = this._webTemplateId;
            var isMySite = webTemplate === "21"  || webTemplate === "54" ;
            suiteNavData.UseSPOBehaviors = !isMySite;
        }
        return suiteNavData;
    };
    SuiteNavManagerConfiguration.prototype.getActionsMap = function () {
        return {};
    };
    Object.defineProperty(SuiteNavManagerConfiguration.prototype, "systemUserKey", {
        get: function () {
            return this._systemUserKey || '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SuiteNavManagerConfiguration.prototype, "userId", {
        get: function () {
            if (this.systemUserKey !== '') {
                return this.systemUserKey.substring(this.systemUserKey.lastIndexOf('|') + 1, this.systemUserKey.indexOf('@'));
            }
            else {
                return '';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SuiteNavManagerConfiguration.prototype, "cacheToken", {
        get: function () {
            var clientTag = this._siteClientTag;
            if (clientTag !== undefined) {
                return clientTag.substring(0, clientTag.indexOf('$$'));
            }
            return '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SuiteNavManagerConfiguration.prototype, "o365ShellRenderSettings", {
        get: function () {
            return this._o365ShellRenderSettings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SuiteNavManagerConfiguration.prototype, "currentUICultureName", {
        get: function () {
            return this._currentUICultureName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SuiteNavManagerConfiguration.prototype, "webServerRelativeUrl", {
        get: function () {
            return this._webServerRelativeUrl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SuiteNavManagerConfiguration.prototype, "userDisplayName", {
        get: function () {
            return this._userDisplayName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SuiteNavManagerConfiguration.prototype, "hamburgerCallback", {
        get: function () {
            return this._hamburgerMenuCallback;
        },
        set: function (hamburgerCallback) {
            this._hamburgerMenuCallback = hamburgerCallback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SuiteNavManagerConfiguration.prototype, "suiteNavPostRenderCallback", {
        get: function () {
            return this._suiteNavPostRenderCallback;
        },
        set: function (suiteNavPostRenderCallback) {
            this._suiteNavPostRenderCallback = suiteNavPostRenderCallback;
        },
        enumerable: true,
        configurable: true
    });
    SuiteNavManagerConfiguration.prototype.isSearchBoxInHeaderFlighted = function () {
        return sp_core_library_["_SPFlight"].isEnabled(1455);
    };
    tslib_es6["__decorate"]([
        decorators_["virtual"]
    ], SuiteNavManagerConfiguration.prototype, "getActionsMap", null);
    return SuiteNavManagerConfiguration;
}());
/* harmony default export */ var lib_SuiteNavManagerConfiguration = (SuiteNavManagerConfiguration_SuiteNavManagerConfiguration);

// CONCATENATED MODULE: C:/agent/1/_work/9/s/libraries/sp-suite-nav/lib/index.js



// CONCATENATED MODULE: ./lib/BaseApplicationContext.js




var BaseApplicationContext_BaseApplicationContext =  (function (_super) {
    tslib_es6["__extends"](BaseApplicationContext, _super);
    function BaseApplicationContext(parameters) {
        var _this = _super.call(this, parameters) || this;
        _this._disposed = false;
        _this._preloadedData = parameters.navigator.preloadedData;
        _this._navigator = parameters.navigator;
        _this._chrome = parameters.chrome;
        _this._loadType = parameters.loadType;
        _this._prefetchedDataEvent = new sp_core_library_["SPEvent"](lib_BaseApplication._prefetchedDataEventName);
        return _this;
    }
    BaseApplicationContext.prototype.dispose = function () {
        if (this._disposed) {
            return;
        }
        if (this._navigator) {
            this._navigator = undefined;
        }
        if (this._chrome) {
            this._chrome.dispose();
        }
        _super.prototype.dispose.call(this);
        this._disposed = true;
    };
    BaseApplicationContext.prototype.initializeSuiteNavManager = function (suiteNavManager) {
        this._suiteNavManager = suiteNavManager;
    };
    Object.defineProperty(BaseApplicationContext.prototype, "preloadedData", {
        get: function () { return this._preloadedData; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseApplicationContext.prototype, "navigator", {
        get: function () { return this._navigator; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseApplicationContext.prototype, "chrome", {
        get: function () { return this._chrome; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseApplicationContext.prototype, "loadType", {
        get: function () { return this._loadType; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseApplicationContext.prototype, "prefetchedDataEvent", {
        get: function () { return this._prefetchedDataEvent; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseApplicationContext.prototype, "suiteNavManager", {
        get: function () {
            return this._suiteNavManager;
        },
        enumerable: true,
        configurable: true
    });
    return BaseApplicationContext;
}(sp_component_base_["BaseComponentContext"]));
/* harmony default export */ var lib_BaseApplicationContext = (BaseApplicationContext_BaseApplicationContext);

// CONCATENATED MODULE: ./lib/SPApplicationBase.resx.js
var SPApplicationBase_resx_key = '_tZTEjqMO7pBJoQSOs5iS2g';
var allStrings = ( false) ?
    require("./resx-strings/en-us.json") :
    __webpack_require__(73);
var strings = allStrings[SPApplicationBase_resx_key];
/* harmony default export */ var SPApplicationBase_resx = (strings);

// CONCATENATED MODULE: ./lib/frameworkPlaceholders/AadPlaceholderManager.js





var AadPlaceholderManager_AadPlaceholderManager =  (function () {
    function AadPlaceholderManager() {
    }
    AadPlaceholderManager.prototype.setUpTokenAcquistionFailurePlaceholder = function (application, serviceScope) {
        var _this = this;
        var tokenProvider = sp_http_["_AadTokenProviders"].configurable;
        var placeHolderProvider = new placeholder_PlaceholderProvider(serviceScope, 0 );
        var placeholderManager = serviceScope.consume(placeholder_PlaceholderManager.serviceKey);
        placeHolderProvider.changedEvent.add(application, function () {
            if (!_this._aadPlaceHolderContent) {
                _this._aadPlaceHolderContent = placeHolderProvider.tryCreateContent(placeholder_PlaceholderName.Top);
            }
        });
        tokenProvider.tokenAcquisitionEvent.add(application, function (eventArgs) {
            if (!placeholderManager.isEnabled) {
                _this._renderTokenAcquistionAlert(eventArgs);
            }
            else {
                if (_this._aadPlaceHolderContent) {
                    _this._renderTokenAcquistionPlaceholder(_this._aadPlaceHolderContent, eventArgs);
                }
                else {
                    _this._renderTokenAcquistionAlert(eventArgs);
                }
            }
        });
    };
    AadPlaceholderManager.prototype._renderTokenAcquistionPlaceholder = function (placeholderContent, eventArgs) {
        placeholderContent.domElement.setAttribute('style', 'text-align: center; padding: 10px; background-color:#fff4ce;');
        var errorMessageElement = document.createElement('span');
        errorMessageElement.innerText = eventArgs.message;
        placeholderContent.domElement.appendChild(errorMessageElement);
        if (eventArgs.redirectUrl) {
            var resolveLinkElement = document.createElement('a');
            resolveLinkElement.href = eventArgs.redirectUrl;
            resolveLinkElement.innerText = SPApplicationBase_resx.clickToResolveIssueLinkText;
            placeholderContent.domElement.appendChild(resolveLinkElement);
        }
    };
    AadPlaceholderManager.prototype._renderTokenAcquistionAlert = function (eventArgs) {
        if (confirm(eventArgs.message) && eventArgs.redirectUrl) {
            window.location.href = eventArgs.redirectUrl;
        }
    };
    return AadPlaceholderManager;
}());
/* harmony default export */ var frameworkPlaceholders_AadPlaceholderManager = (AadPlaceholderManager_AadPlaceholderManager);

// EXTERNAL MODULE: external "@ms/sp-load-themed-styles"
var sp_load_themed_styles_ = __webpack_require__(74);
var sp_load_themed_styles__default = /*#__PURE__*/__webpack_require__.n(sp_load_themed_styles_);

// EXTERNAL MODULE: external "@microsoft/sp-lodash-subset"
var sp_lodash_subset_ = __webpack_require__(39);
var sp_lodash_subset__default = /*#__PURE__*/__webpack_require__.n(sp_lodash_subset_);

// EXTERNAL MODULE: C:/agent/1/_work/9/s/common/temp/node_modules/.onedrive.pkgs.visualstudio.com/@ms/odsp-utilities-bundle/5.0.3/node_modules/@ms/odsp-utilities-bundle/lib/index.js
var lib = __webpack_require__(42);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// EXTERNAL MODULE: C:/agent/1/_work/9/s/common/temp/node_modules/.onedrive.pkgs.visualstudio.com/@ms/odsp-utilities/27.23.2/node_modules/@ms/odsp-utilities/lib/theming/FabricTheming.js
var FabricTheming = __webpack_require__(69);
var FabricTheming_default = /*#__PURE__*/__webpack_require__.n(FabricTheming);

// EXTERNAL MODULE: C:/agent/1/_work/9/s/common/temp/node_modules/.onedrive.pkgs.visualstudio.com/@ms/odsp-utilities/27.23.2/node_modules/@ms/odsp-utilities/lib/theming/RgbaColor.js
var RgbaColor = __webpack_require__(14);
var RgbaColor_default = /*#__PURE__*/__webpack_require__.n(RgbaColor);

// EXTERNAL MODULE: C:/agent/1/_work/9/s/common/temp/node_modules/.onedrive.pkgs.visualstudio.com/@ms/odsp-utilities/27.23.2/node_modules/@ms/odsp-utilities/lib/theming/ThemeProvider.js
var ThemeProvider = __webpack_require__(70);
var ThemeProvider_default = /*#__PURE__*/__webpack_require__.n(ThemeProvider);

// EXTERNAL MODULE: C:/agent/1/_work/9/s/common/temp/node_modules/.onedrive.pkgs.visualstudio.com/@ms/odsp-utilities/27.23.2/node_modules/@ms/odsp-utilities/lib/theming/WebTheme.js
var WebTheme = __webpack_require__(119);
var WebTheme_default = /*#__PURE__*/__webpack_require__.n(WebTheme);

// EXTERNAL MODULE: external "@microsoft/sp-page-context"
var sp_page_context_ = __webpack_require__(38);
var sp_page_context__default = /*#__PURE__*/__webpack_require__.n(sp_page_context_);

// CONCATENATED MODULE: ./lib/pageChrome/SPThemeProvider.js













var SPThemeProvider_SPThemeProvider =  (function () {
    function SPThemeProvider(serviceScope) {
        var _this = this;
        serviceScope.whenFinished(function () {
            _this._pageContext = serviceScope.consume(sp_page_context_["PageContext"].serviceKey);
            _this._httpClient = serviceScope.consume(sp_http_["SPHttpClient"].serviceKey);
            _this._themeProvider = _this._getThemeProvider();
            try {
                var contextUri = new lib["Uri"](window.location.href);
                _this._themeOverride = contextUri.getQueryParameter('ThemeOverride');
            }
            catch (ignoredUrlException) {
            }
        });
    }
    SPThemeProvider._deleteNullThemeColor = function (palette) {
        for (var color in palette) {
            if (palette.hasOwnProperty(color) && !palette[color]) {
                delete palette[color];
            }
        }
    };
    SPThemeProvider._createDefaultTheme = function () {
        var themeData = {
            backgroundImageUri: undefined,
            cacheToken: undefined,
            isDefault: undefined,
            isInverted: false,
            palette: undefined,
            version: '1.0'
        };
        return themeData;
    };
    SPThemeProvider.prototype.loadThemedStyles = function () {
        if (!this._loadThemedStylesPromiseMap) {
            this._loadThemedStylesPromiseMap = new Map();
        }
        var cacheToken = this._getCacheToken();
        var loadThemeStylesODSPPromise = this._loadThemedStylesPromiseMap.get(cacheToken);
        if (!loadThemeStylesODSPPromise) {
            loadThemeStylesODSPPromise = Promise.all([this._themeProvider.loadThemeTokenMap(cacheToken), this._themeProvider.loadThemeData(cacheToken)]).then(function (themeArgs) {
                var palette = themeArgs[0];
                var themeData = themeArgs[1];
                SPThemeProvider._deleteNullThemeColor(palette);
                var isPaletteCurrentOrEmpty = SPThemeProvider._currentPalette ?
                    !sp_lodash_subset_["isEqual"](SPThemeProvider._currentPalette, palette) :
                    !sp_lodash_subset_["isEmpty"](palette);
                if (isPaletteCurrentOrEmpty) {
                    var theme_1 = {
                        palette: palette,
                        isInverted: themeData.isInverted
                    };
                    sp_loader_["SPComponentLoader"].loadComponentById('02a01e42-69ab-403d-8a16-acd128661f8e')
                        .then(function (module) { return module.loadTheme(theme_1); });
                }
                SPThemeProvider._currentPalette = palette;
                return themeArgs;
            });
            this._loadThemedStylesPromiseMap.set(cacheToken, loadThemeStylesODSPPromise);
        }
        return loadThemeStylesODSPPromise;
    };
    SPThemeProvider.prototype.loadData = function () {
        var _this = this;
        var tagName = 'SPThemeProvider.loadData';
        var qosMonitor = new sp_diagnostics_["_QosMonitor"](tagName);
        if (this._pageContext.legacyPageContext.themedCssFolderUrl) {
            var webUrl = this._pageContext.web.serverRelativeUrl;
            var getThemeDataUrl_1 = WebTheme_default.a.makeWebThemeRestUrl(webUrl, this._pageContext.cultureInfo.currentUICultureName, this._themeOverride);
            return new lib["Promise"](function (resolve, reject) {
                _this._httpClient.get(getThemeDataUrl_1, sp_http_["SPHttpClient"].configurations.v1)
                    .then(function (response) {
                    if (response.status === 200) {
                        return response.json()
                            .then(function (json) {
                            var themeDataRaw = JSON.parse(json.value);
                            if (themeDataRaw) {
                                var themeData = WebTheme_default.a.processRawThemeData(themeDataRaw);
                                themeData.cacheToken = _this._pageContext.legacyPageContext.themedCssFolderUrl;
                                qosMonitor.writeSuccess();
                                resolve(themeData);
                            }
                            else {
                                qosMonitor.writeUnexpectedFailure();
                                resolve(undefined);
                            }
                        });
                    }
                    else {
                        qosMonitor.writeUnexpectedFailure(tagName, new Error(response.statusText));
                        resolve(undefined);
                    }
                });
            });
        }
        else if (this._pageContext.legacyPageContext.groupColor) {
            var htmlThemeColor = this._pageContext.legacyPageContext.groupColor;
            var rgbaThemeColor = RgbaColor_default.a.fromHtmlColor(htmlThemeColor);
            if (rgbaThemeColor) {
                var fabTheme = {
                    backgroundImageUri: undefined,
                    cacheToken: this._getCacheToken(),
                    isDefault: false,
                    isInverted: false,
                    palette: FabricTheming_default.a.generateFabricColors(rgbaThemeColor),
                    version: '1'
                };
                return lib["Promise"].wrap(fabTheme);
            }
            else {
                return lib["Promise"].wrap();
            }
        }
        else {
            qosMonitor.writeSuccess();
            return lib["Promise"].wrap(SPThemeProvider._createDefaultTheme());
        }
    };
    SPThemeProvider.prototype._getThemeProvider = function () {
        return new ThemeProvider_default.a(this.loadData.bind(this));
    };
    SPThemeProvider.prototype._getCacheToken = function () {
        var webTemplate = String(this._pageContext.web.templateName);
        var groupColor = webTemplate === "1"  ||
            webTemplate === "64"  ? this._pageContext.legacyPageContext.groupColor : undefined;
        var groupColorToken = groupColor && (groupColor + ';web#' + webTemplate);
        return this._themeOverride || this._pageContext.legacyPageContext.themedCssFolderUrl || groupColorToken;
    };
    SPThemeProvider._currentPalette = undefined;
    tslib_es6["__decorate"]([
        decorators_["virtual"]
    ], SPThemeProvider.prototype, "_getThemeProvider", null);
    return SPThemeProvider;
}());
/* harmony default export */ var pageChrome_SPThemeProvider = (SPThemeProvider_SPThemeProvider);

// CONCATENATED MODULE: ./lib/ApplicationLoadType.js
var ApplicationLoadType;
(function (ApplicationLoadType) {
    ApplicationLoadType[ApplicationLoadType["FullPageLoad"] = 0] = "FullPageLoad";
    ApplicationLoadType[ApplicationLoadType["InPlaceNavigation"] = 1] = "InPlaceNavigation";
})(ApplicationLoadType || (ApplicationLoadType = {}));

// CONCATENATED MODULE: ./lib/common/Flights.js

var Flights_Flights =  (function () {
    function Flights() {
    }
    Flights.useNewChromeSequence = function () {
        var skipFlightValidationForSPD = !sp_core_library_["_SPKillSwitch"].isActivated(sp_core_library_["Guid"].parse('e413f087-b95f-4d63-8c6f-56f02f29fd01'), '2/20/2019', 'Temporarily Skip Connected SPA Flight for SPD') && (navigator.userAgent.indexOf('SharePointDesktop') !== -1);
        return skipFlightValidationForSPD || sp_core_library_["_SPFlight"].isEnabled(1342 );
    };
    return Flights;
}());


// EXTERNAL MODULE: ./lib/common/Killswitches.js
var Killswitches = __webpack_require__(23);

// CONCATENATED MODULE: ./lib/navigator/NavigationDataProvider.js



var NavigationDataProvider_NavigationDataProvider =  (function () {
    function NavigationDataProvider(serviceScope, validator) {
        sp_core_library_["Validate"].isNotNullOrUndefined(serviceScope, 'serviceScope');
        sp_core_library_["Validate"].isNotNullOrUndefined(validator, 'validator');
        this._spHttpClient = serviceScope.consume(sp_http_["SPHttpClient"].serviceKey);
        this._dataValidator = validator;
    }
    NavigationDataProvider.prototype.getData = function (url, props) {
        sp_core_library_["Validate"].isNonemptyString(url, 'url');
        return sp_loader_["_SPLoaderFlights"]._useNewBootSequence() ?
            this._getStore().then(function (store) { return store.getData(url, props); }) :
            Promise.resolve({
                preloadedData: this._fetchData(url)
            });
    };
    NavigationDataProvider.prototype.invalidate = function (url) {
        return this._getStore().then(function (store) {
            store.remove(url);
        });
    };
    NavigationDataProvider.prototype._getStore = function () {
        var _this = this;
        if (this._navigationStore) {
            return Promise.resolve(this._navigationStore);
        }
        return this._navigationStorePromise || (this._navigationStorePromise = __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 123))
            .then(function (dataStore) {
            _this._navigationStore = new dataStore.default(NavigationDataProvider.storeKey, function (url, headers) {
                return _this._fetchData(url, headers);
            }, _this._dataValidator);
            return _this._navigationStore;
        }));
    };
    NavigationDataProvider.prototype._fetchData = function (url, requestHeaders) {
        return this._spHttpClient.get(url + (url.indexOf('?') === -1 ? '?' : '&') + 'as=json', sp_http_["SPHttpClient"].configurations.v1, requestHeaders ? { headers: requestHeaders } : undefined).then(function (response) {
            if (!response.ok) {
                throw new Error(response.statusMessage);
            }
            else {
                return response.json();
            }
        });
    };
    NavigationDataProvider.storeKey = 'sp-application-base:NavigationDataStore';
    return NavigationDataProvider;
}());
/* harmony default export */ var navigator_NavigationDataProvider = (NavigationDataProvider_NavigationDataProvider);

// CONCATENATED MODULE: ./lib/extensibility/BaseApplicationCustomizer.js




var BaseApplicationCustomizer_BaseApplicationCustomizer =  (function (_super) {
    tslib_es6["__extends"](BaseApplicationCustomizer, _super);
    function BaseApplicationCustomizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BaseApplicationCustomizer.prototype._initializeExtensionType = function () {
        _super.prototype._initializeExtensionType.call(this);
        var qosMonitor = new sp_diagnostics_["_QosMonitor"]('BaseApplicationCustomizer.onPlaceholdersChanged.setUp');
        if (this.onPlaceholdersChanged.length === 1) {
            this._placeholdersChangedCallback = this.onPlaceholdersChanged.bind(this, this.context.placeholderProvider);
            this.context.placeholderProvider.changedEvent.add(this, this._placeholdersChangedCallback);
            qosMonitor.writeSuccess();
        }
        else {
            qosMonitor.writeExpectedFailure('DifferentSignature');
        }
    };
    BaseApplicationCustomizer.prototype.dispose = function () {
        if (this._placeholdersChangedCallback) {
            this.context.placeholderProvider.changedEvent.remove(this, this._placeholdersChangedCallback);
        }
        _super.prototype.dispose.call(this);
    };
    BaseApplicationCustomizer.prototype.onPlaceholdersChanged = function (placeholderProvider) {
        return;
    };
    tslib_es6["__decorate"]([
        decorators_["virtual"]
    ], BaseApplicationCustomizer.prototype, "onPlaceholdersChanged", null);
    return BaseApplicationCustomizer;
}(sp_extension_base_["BaseExtension"]));
/* harmony default export */ var extensibility_BaseApplicationCustomizer = (BaseApplicationCustomizer_BaseApplicationCustomizer);

// CONCATENATED MODULE: ./lib/extensibility/customAction/ClientSideCustomAction.js




var ClientSideCustomAction_ClientSideCustomAction =  (function () {
    function ClientSideCustomAction() {
    }
    ClientSideCustomAction._tryCreateFromPreloadedCustomAction = function (customAction) {
        var typedCustomAction = undefined;
        var qosMonitor = new sp_diagnostics_["_QosMonitor"]('ClientSideCustomActions.CreateFromPreloadedCustomAction');
        try {
            typedCustomAction = new ClientSideCustomAction();
            var componentId = customAction.clientSideComponentId;
            sp_core_library_["Validate"].isNonemptyString(componentId, 'customAction.clientSideComponentId');
            sp_core_library_["Validate"].isNonemptyString(customAction.location, 'customAction.location');
            sp_core_library_["Validate"].isNotNullOrUndefined(sp_core_library_["Guid"].tryParse(componentId), 'customAction.clientSideComponentId as Guid');
            if (!sp_loader_["SPComponentLoader"].tryGetManifestById(componentId)) {
                var error = new Error("Custom action with component id \"" + componentId + "\" didn't have a manifest.");
                qosMonitor.writeUnexpectedFailure('ManifestNotFound', error, { customAction: componentId });
                throw error;
            }
            typedCustomAction.title = customAction.title;
            typedCustomAction.location = customAction.location;
            typedCustomAction.clientSideComponentId = sp_core_library_["Guid"].parse(componentId);
            typedCustomAction.clientSideComponentProperties = customAction.clientSideComponentProperties;
            typedCustomAction.registrationType = customAction.registrationType;
            typedCustomAction.registrationId = customAction.registrationId;
            typedCustomAction.sequence = customAction.sequence;
            typedCustomAction.requireSiteAdministrator = customAction.requireSiteAdministrator;
            var rights = customAction.rights;
            if (rights && rights.High !== undefined && rights.Low !== undefined) {
                typedCustomAction.rights = new sp_page_context_["SPPermission"](rights);
            }
            else {
                sp_diagnostics_["_TraceLogger"].logVerbose(ClientSideCustomAction._logSource, "The rights object has invalid format. One of High or Low fields cannot be undefined. Object value is '" + JSON.stringify(rights)); 
            }
            qosMonitor.writeSuccess({
                customAction: typedCustomAction.tag
            });
            return typedCustomAction;
        }
        catch (error) {
            sp_diagnostics_["_TraceLogger"].logError(ClientSideCustomAction._logSource, new Error("Failed to create client-side custom action. Error: " + error.message));
            qosMonitor.writeUnexpectedFailure('UnhandledCreateError', error, {
                customAction: customAction.clientSideComponentId
            });
            return undefined;
        }
    };
    ClientSideCustomAction._tryCreateFromDebugData = function (location, clientSideComponentId, clientSideComponentProperties, sequence) {
        try {
            sp_core_library_["Validate"].isNotNullOrUndefined(clientSideComponentId, 'clientSideComponentId');
            sp_core_library_["Validate"].isNonemptyString(location, 'location');
            var customAction = new ClientSideCustomAction();
            customAction.location = location;
            customAction.clientSideComponentId = clientSideComponentId;
            customAction.clientSideComponentProperties = clientSideComponentProperties;
            customAction.sequence = sequence;
            return customAction;
        }
        catch (error) {
            sp_diagnostics_["_TraceLogger"].logError(ClientSideCustomAction._logSource, new Error("Failed to create client-side custom action. Error: " + error.message));
            return undefined;
        }
    };
    Object.defineProperty(ClientSideCustomAction.prototype, "tag", {
        get: function () {
            return this.location + "." + this.clientSideComponentId.toString();
        },
        enumerable: true,
        configurable: true
    });
    ClientSideCustomAction._logSource = sp_diagnostics_["_LogSource"].create('ClientSideCustomAction');
    return ClientSideCustomAction;
}());
/* harmony default export */ var customAction_ClientSideCustomAction = (ClientSideCustomAction_ClientSideCustomAction);

// CONCATENATED MODULE: ./lib/extensibility/customAction/CustomActionLocations.js
var CustomActionLocations =  (function () {
    function CustomActionLocations() {
    }
    CustomActionLocations.APPLICATION_CUSTOMIZER = 'ClientSideExtension.ApplicationCustomizer';
    CustomActionLocations.LISTVIEW_COMMANDSET_CONTEXTMENU = 'ClientSideExtension.ListViewCommandSet.ContextMenu';
    CustomActionLocations.LISTVIEW_COMMANDSET_COMMANDBAR = 'ClientSideExtension.ListViewCommandSet.CommandBar';
    CustomActionLocations.LISTVIEW_COMMANDSET_DEFAULT = 'ClientSideExtension.ListViewCommandSet';
    return CustomActionLocations;
}());
/* harmony default export */ var customAction_CustomActionLocations = (CustomActionLocations);

// CONCATENATED MODULE: ./lib/extensibility/ApplicationCustomizerLoader.js










var ApplicationCustomizerLoader_ApplicationCustomizerLoader =  (function () {
    function ApplicationCustomizerLoader(serviceScope) {
        var _this = this;
        this._customActionFromPreloadedData = [];
        this._debugCustomActions = [];
        this._debugCustomizerLoaded = false;
        sp_core_library_["Validate"].isNotNullOrUndefined(serviceScope, 'serviceScope');
        this._extensionManager = new sp_extension_base_["_ExtensionManager"](serviceScope, extensibility_BaseApplicationCustomizer);
        serviceScope.whenFinished(function () {
            _this._placeholderManager = serviceScope.consume(placeholder_PlaceholderManager.serviceKey);
            _this._placeholderManager._enable();
        });
        this._currentCustomActions = new Set();
    }
    ApplicationCustomizerLoader.prototype.loadExtensions = function (preloadedCustomActions) {
        var _this = this;
        var futureCustomActions = new Set(preloadedCustomActions);
        var hadCustomActions = this._currentCustomActions.size > 0;
        var hasDebugCustomActions = this._hasDebugCustomActions();
        var willHaveCustomActions = futureCustomActions.size > 0 || hasDebugCustomActions;
        var areCustomActionsEqual = (!hadCustomActions && !willHaveCustomActions) ||
            (hadCustomActions && willHaveCustomActions && Object(sp_lodash_subset_["isEqual"])(this._currentCustomActions, futureCustomActions));
        var extensionsDisposed = false;
        this._currentCustomActions = futureCustomActions;
        if (hadCustomActions && !areCustomActionsEqual) {
            sp_diagnostics_["_TraceLogger"].logVerbose(ApplicationCustomizerLoader._logSource, 'Disposing existing extensions');
            this._disposeExtensions();
            extensionsDisposed = true;
        }
        if ((willHaveCustomActions && !areCustomActionsEqual) || 
            (hasDebugCustomActions && extensionsDisposed) 
        ) {
            sp_diagnostics_["_TraceLogger"].logVerbose(ApplicationCustomizerLoader._logSource, 'Loading new extensions');
            return this._loadExtensions(preloadedCustomActions).then(function () { return _this._loadDebugCustomizerIfEnabled(); });
        }
        return this._loadDebugCustomizerIfEnabled();
    };
    Object.defineProperty(ApplicationCustomizerLoader.prototype, "_customActions", {
        get: function () {
            return this._debugCustomActions.concat(this._customActionFromPreloadedData);
        },
        enumerable: true,
        configurable: true
    });
    ApplicationCustomizerLoader.prototype._loadDebugCustomizerIfEnabled = function () {
        var _this = this;
        var debugApplicationCustomizerId = 'd29758ba-0fc0-4eac-bcfd-7fe5a7d0bc32';
        if (sp_core_library_["_SPFlight"].isDebugFlightEnabled && sp_core_library_["_SPFlight"].isEnabled(1178 ) &&
            !this._debugCustomizerLoaded) {
            var customAction_1 = customAction_ClientSideCustomAction._tryCreateFromDebugData('ClientSideExtension.ApplicationCustomizer', sp_core_library_["Guid"].parse(debugApplicationCustomizerId), 
            undefined, 
            0);
            if (customAction_1) {
                return sp_loader_["_ManifestStore"].instance.requestManifest(debugApplicationCustomizerId).then(function () {
                    _this._createApplicationCustomizer(customAction_1);
                    _this._debugCustomizerLoaded = true;
                }).catch(function (error) {
                    sp_diagnostics_["_TraceLogger"].logError(ApplicationCustomizerLoader._logSource, error);
                });
            }
        }
        return Promise.resolve();
    };
    ApplicationCustomizerLoader.prototype._disposeExtensions = function () {
        this._extensionManager.disposeExtensions();
        this._debugCustomizerLoaded = false;
    };
    ApplicationCustomizerLoader.prototype._loadExtensions = function (preloadedCustomActions) {
        this._loadCustomActions(preloadedCustomActions);
        var extensionPromises = [];
        var customActions = this._customActions;
        for (var _i = 0, customActions_1 = customActions; _i < customActions_1.length; _i++) {
            var customAction = customActions_1[_i];
            if (customAction.location === customAction_CustomActionLocations.APPLICATION_CUSTOMIZER) {
                extensionPromises.push(this._createApplicationCustomizer(customAction));
            }
        }
        return Promise.all(extensionPromises).then(function (extensions) { return; });
    };
    ApplicationCustomizerLoader.prototype._createApplicationCustomizer = function (customAction) {
        var _this = this;
        var qosMonitor = new sp_diagnostics_["_QosMonitor"]('ApplicationCustomizer.Create');
        return this._extensionManager.createExtension(customAction.clientSideComponentId.toString(), customAction.clientSideComponentProperties, function (extensionContextParameters) {
            return new extensibility_ApplicationCustomizerContext(extensionContextParameters, {
                sequence: customAction.sequence !== undefined ? customAction.sequence : 65535 
            });
        }).then(function (extension) {
            qosMonitor.writeSuccess(_this._createQosExtraData(customAction));
            return extension;
        }).catch(function (error) {
            var err = new Error("Failed to create application customizer '" + customAction.tag + "'. Error information is '" + error.message + "'."); 
            qosMonitor.writeExpectedFailure('FailedCreateExtension', error, _this._createQosExtraData(customAction));
            sp_diagnostics_["_TraceLogger"].logError(ApplicationCustomizerLoader._logSource, err);
            throw err;
        });
    };
    ApplicationCustomizerLoader.prototype._createQosExtraData = function (customAction) {
        return {
            customAction: customAction.tag
        };
    };
    ApplicationCustomizerLoader.prototype._loadCustomActions = function (customActions) {
        this._customActionFromPreloadedData = this._loadCustomActionsFromPreloadedData(customActions);
        this._debugCustomActions = this._loadCustomActionsFromQueryParameter();
    };
    ApplicationCustomizerLoader.prototype._loadCustomActionsFromPreloadedData = function (customActions) {
        var clientSideCustomActions = [];
        if (!!customActions) {
            for (var _i = 0, customActions_2 = customActions; _i < customActions_2.length; _i++) {
                var customAction = customActions_2[_i];
                if (customAction.location === customAction_CustomActionLocations.APPLICATION_CUSTOMIZER) {
                    var clientSideCustomAction = customAction_ClientSideCustomAction._tryCreateFromPreloadedCustomAction(customAction);
                    if (clientSideCustomAction) {
                        clientSideCustomActions.push(clientSideCustomAction);
                    }
                }
            }
        }
        return clientSideCustomActions;
    };
    ApplicationCustomizerLoader.prototype._hasDebugCustomActions = function () {
        var queryParameters = new URL(window.location.href).searchParams;
        return !!queryParameters.get('customActions') ||
            (sp_core_library_["_SPFlight"].isDebugFlightEnabled && sp_core_library_["_SPFlight"].isEnabled(1178 )); 
    };
    ApplicationCustomizerLoader.prototype._loadCustomActionsFromQueryParameter = function () {
        var parameters = new URL(window.location.href).searchParams;
        var parameterValue = parameters.get('customActions');
        var clientSideCustomActions = [];
        if (parameterValue) {
            var qosMonitor = new sp_diagnostics_["_QosMonitor"]('ApplicationCustomizerLoader.parseQueryParam');
            try {
                var decodedParameterValue = decodeURIComponent(parameterValue);
                var queryValue = JSON.parse(decodedParameterValue);
                var missingManifestIds = [];
                if (queryValue) {
                    for (var _i = 0, _a = Object.keys(queryValue); _i < _a.length; _i++) {
                        var key = _a[_i];
                        var clientSideComponentId = sp_core_library_["Guid"].tryParse(key);
                        var location_1 = queryValue[key].location;
                        var properties = queryValue[key].properties;
                        var sequence = queryValue[key].sequence;
                        sp_core_library_["Validate"].isNotNullOrUndefined(clientSideComponentId, 'clientSideComponentId');
                        sp_core_library_["Validate"].isNotNullOrUndefined(location_1, 'location');
                        if (!sp_loader_["SPComponentLoader"].tryGetManifestById(clientSideComponentId.toString())) {
                            missingManifestIds.push(clientSideComponentId);
                            continue; 
                        }
                        if (clientSideComponentId && location_1) {
                            var customActions = customAction_ClientSideCustomAction._tryCreateFromDebugData(location_1, clientSideComponentId, properties ? JSON.stringify(properties) : '', sequence);
                            if (customActions) {
                                clientSideCustomActions.push(customActions);
                            }
                        }
                    }
                }
                if (missingManifestIds.length > 0) {
                    this._processMissingManifestsErrors(missingManifestIds, qosMonitor);
                }
                else {
                    qosMonitor.writeSuccess();
                }
            }
            catch (e) {
                this._processQueryParamParseErrors(e, parameterValue, qosMonitor);
            }
        }
        return clientSideCustomActions;
    };
    ApplicationCustomizerLoader.prototype._processMissingManifestsErrors = function (missingManifestIds, qosMonitor) {
        var errorMessage = 'Custom action component ids are specified by query parameters but ' +
            'matching manifests cannot be found.';
        var error = new Error(errorMessage + ' Ids: ' + missingManifestIds.join(', '));
        sp_diagnostics_["_TraceLogger"].logError(ApplicationCustomizerLoader._logSource, error, 'parseCustomActionsQueryParameter');
        console.error(error.message);
        qosMonitor.writeExpectedFailure('ManifestNotFound', error);
    };
    ApplicationCustomizerLoader.prototype._processQueryParamParseErrors = function (error, parameterValue, qosMonitor) {
        sp_diagnostics_["_TraceLogger"].logError(ApplicationCustomizerLoader._logSource, new Error('Failed to parse the "customActions" URL query parameter:' + error.message));
        console.error('The "customActions" URL query parameter is improperly formatted: '
            + decodeURIComponent(parameterValue));
        qosMonitor.writeExpectedFailure('ParseFailure', error);
    };
    ApplicationCustomizerLoader._logSource = sp_diagnostics_["_LogSource"].create('ApplicationCustomizerLoader');
    return ApplicationCustomizerLoader;
}());
/* harmony default export */ var extensibility_ApplicationCustomizerLoader = (ApplicationCustomizerLoader_ApplicationCustomizerLoader);

// CONCATENATED MODULE: ./lib/error/SPGlobalErrorHandler.js

var SPGlobalErrorHandler_SPGlobalErrorHandler =  (function () {
    function SPGlobalErrorHandler() {
    }
    SPGlobalErrorHandler.basicTracingHandler = function (message, filename, lineno, colno, error) {
        var eventName = 'window.onerror';
        if (filename && SPGlobalErrorHandler._isFromFile(filename, 'CKEDITOR')) {
            SPGlobalErrorHandler._logErrorFromFile(message, SPGlobalErrorHandler._ckLogSource, lineno, colno, error, eventName);
        }
        else {
            var genericError = error ||
                new Error("Error:" + message + ", file:" + filename + ", line:" + lineno + ", column:" + colno);
            sp_diagnostics_["_TraceLogger"].logError(SPGlobalErrorHandler._genericLogSource, genericError, eventName);
        }
    };
    SPGlobalErrorHandler._isFromFile = function (filename, match) {
        return filename.length > 0 && filename.toUpperCase().indexOf(match) !== -1;
    };
    SPGlobalErrorHandler._logErrorFromFile = function (message, logSource, lineno, colno, error, eventName) {
        var fileError = error ||
            new Error("Error:" + message + ", line:" + lineno + ", column:" + colno);
        sp_diagnostics_["_TraceLogger"].logError(logSource, fileError, eventName);
    };
    SPGlobalErrorHandler._ckLogSource = sp_diagnostics_["_LogSource"].create('CKGlobalError');
    SPGlobalErrorHandler._genericLogSource = sp_diagnostics_["_LogSource"].create('OtherGlobalError');
    return SPGlobalErrorHandler;
}());
/* harmony default export */ var error_SPGlobalErrorHandler = (SPGlobalErrorHandler_SPGlobalErrorHandler);

// CONCATENATED MODULE: ./lib/extensibility/DialogManagerConfiguration.js

var DialogManagerConfiguration_DialogManagerConfiguration =  (function () {
    function DialogManagerConfiguration() {
    }
    Object.defineProperty(DialogManagerConfiguration, "instance", {
        get: function () {
            if (!this._instance) {
                this._instance = new DialogManagerConfiguration();
            }
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DialogManagerConfiguration.prototype, "allowDialogs", {
        get: function () {
            sp_core_library_["Validate"].isNotNullOrUndefined(this._allowDialogs, 'allowDialogs');
            return this._allowDialogs;
        },
        set: function (value) {
            sp_core_library_["Validate"].isNotNullOrUndefined(value, 'value');
            this._allowDialogs = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DialogManagerConfiguration.prototype, "domElement", {
        get: function () {
            sp_core_library_["Validate"].isNotNullOrUndefined(this._domElement, 'domElement');
            return this._domElement;
        },
        enumerable: true,
        configurable: true
    });
    DialogManagerConfiguration.prototype.initialize = function (domElement, allowDialogs) {
        if (allowDialogs === void 0) { allowDialogs = true; }
        this._allowDialogs = allowDialogs;
        this._domElement = domElement;
    };
    DialogManagerConfiguration.prototype.dispose = function () {
        this._allowDialogs = undefined;
        this._domElement = undefined;
    };
    return DialogManagerConfiguration;
}());
/* harmony default export */ var extensibility_DialogManagerConfiguration = (DialogManagerConfiguration_DialogManagerConfiguration);

// CONCATENATED MODULE: ./lib/pageChrome/SPPageChrome.module.scss.js
__webpack_require__(120);
var styles = {
    spPageContentTransition: 'spPageContentTransition_6b79199f',
};
/* harmony default export */ var SPPageChrome_module_scss = (styles);

// CONCATENATED MODULE: ./lib/pageChrome/SPPageChrome.js








var SPPageChrome_SPPageChrome =  (function () {
    function SPPageChrome(serviceScope, parentChrome) {
        this._isDisposed = false;
        this._masterChrome = parentChrome;
        this._createPageChrome();
        extensibility_DialogManagerConfiguration.instance.initialize(this.dialogContainerDiv);
        this._spThemeProvider = new pageChrome_SPThemeProvider(serviceScope);
    }
    SPPageChrome.prototype.changeSuiteNavHeight = function (pixels) {
        var top = parseInt(pixels, 10) + 'px';
        this.suiteNavDiv.style.height = top;
    };
    Object.defineProperty(SPPageChrome.prototype, "themeProvider", {
        get: function () {
            return this._spThemeProvider;
        },
        enumerable: true,
        configurable: true
    });
    SPPageChrome.prototype.show = function () {
        if (!this._isDisposed) {
            if (Flights_Flights.useNewChromeSequence()) {
                this._masterChrome.show();
                this._masterChrome.chromeDiv.appendChild(this.appAndPropertyPaneDiv);
                this._masterChrome.chromeDiv.appendChild(this.dialogContainerDiv);
            }
            else {
                document.body.appendChild(this._chromeDiv);
            }
        }
    };
    SPPageChrome.prototype.hide = function () {
        if (!this._isDisposed) {
            if (Flights_Flights.useNewChromeSequence()) {
                this.appAndPropertyPaneDiv = this._masterChrome.chromeDiv.removeChild(this.appAndPropertyPaneDiv);
                this.dialogContainerDiv = this._masterChrome.chromeDiv.removeChild(this.dialogContainerDiv);
            }
            else {
                this._chromeDiv = document.body.removeChild(this._chromeDiv);
            }
        }
    };
    SPPageChrome.prototype.dispose = function () {
        if (sp_loader_["_SPLoaderFlights"]._useNewBootSequence() && !this._isDisposed) {
            delete this.appDiv;
            delete this.propertyPaneContainerDiv;
            if (this.appAndPropertyPaneDiv) {
                delete this.appAndPropertyPaneDiv;
            }
            delete this.dialogContainerDiv;
            if (!Flights_Flights.useNewChromeSequence()) {
                delete this.suiteNavDiv;
                delete this._chromeDiv;
            }
            this._isDisposed = true;
        }
    };
    Object.defineProperty(SPPageChrome.prototype, "isDisposed", {
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    SPPageChrome.prototype._createPageChrome = function () {
        sp_telemetry_["_PerformanceLogger"].devMark('SPPageChrome.createPageChrome');
        if (Flights_Flights.useNewChromeSequence()) {
            sp_core_library_["Validate"].isNotNullOrUndefined(this._masterChrome, 'masterChrome');
            sp_core_library_["Validate"].isNotDisposed(this._masterChrome, 'masterChrome');
            sp_core_library_["Validate"].isNotNullOrUndefined(this._masterChrome.chromeDiv, 'chromeDiv');
            sp_core_library_["Validate"].isNotNullOrUndefined(this._masterChrome.suiteNavDiv, 'suiteNavDiv');
            this.suiteNavDiv = this._masterChrome.suiteNavDiv;
        }
        else {
            document.body.className = 'ms-font-m';
            this._chromeDiv = document.createElement('div');
            this._chromeDiv.setAttribute('class', 'SPPageChrome');
            this.suiteNavDiv = document.createElement('div');
            this.suiteNavDiv.setAttribute('id', 'SuiteNavPlaceHolder');
            this._chromeDiv.appendChild(this.suiteNavDiv);
        }
        this.appDiv = document.createElement('div');
        this.appDiv.setAttribute('class', "SPPageChrome-app");
        this.appDiv.setAttribute('id', 'spPageChromeAppDiv');
        this.appDiv.setAttribute('data-sp-feature-tag', 'Page Chrome');
        this.appDiv.setAttribute('data-sp-feature-instance-id', '_Page Chrome');
        this.appDiv.setAttribute('data-sp-a11y-navigatebyhierarchy', 'true');
        this.propertyPaneContainerDiv = document.createElement('div');
        this.propertyPaneContainerDiv.setAttribute('class', "spPropertyPaneContainer " + SPPageChrome_module_scss.spPageContentTransition);
        this.propertyPaneContainerDiv.setAttribute('id', 'spPropertyPaneContainer');
        this.appAndPropertyPaneDiv = document.createElement('div');
        this.appAndPropertyPaneDiv.setAttribute('class', sp_core_library_["_SPFlight"].isEnabled(175) ? 
            'spAppAndPropertyPanelContainer spAppAndPropertyPanelNavBelowHeader' :
            'spAppAndPropertyPanelContainer');
        this.appAndPropertyPaneDiv.appendChild(this.appDiv);
        this.appAndPropertyPaneDiv.appendChild(this.propertyPaneContainerDiv);
        this.dialogContainerDiv = document.createElement('div');
        this.dialogContainerDiv.setAttribute('id', 'spDialogContainerDiv');
        if (!Flights_Flights.useNewChromeSequence()) {
            this._chromeDiv.appendChild(this.appAndPropertyPaneDiv);
            this._chromeDiv.appendChild(this.dialogContainerDiv);
            if (!window.onerror) {
                window.onerror = error_SPGlobalErrorHandler.basicTracingHandler;
            }
        }
    };
    return SPPageChrome;
}());
/* harmony default export */ var pageChrome_SPPageChrome = (SPPageChrome_SPPageChrome);

// CONCATENATED MODULE: ./lib/navigator/INavigationResult.js
var NavigationOperation;
(function (NavigationOperation) {
    NavigationOperation[NavigationOperation["UpdateContext"] = 0] = "UpdateContext";
    NavigationOperation[NavigationOperation["LoadApplication"] = 1] = "LoadApplication";
    NavigationOperation[NavigationOperation["Unsupported"] = 2] = "Unsupported";
})(NavigationOperation || (NavigationOperation = {}));

// CONCATENATED MODULE: ./lib/pageChrome/SPMasterChrome.js


var SPMasterChrome_SPMasterChrome =  (function () {
    function SPMasterChrome() {
        this._isVisible = false;
        this._isDisposed = false;
        this._createPageChrome();
    }
    SPMasterChrome.prototype.show = function () {
        if (!this._isDisposed && !this._isVisible) {
            document.body.appendChild(this._chromeDiv);
            this._isVisible = true;
        }
    };
    SPMasterChrome.prototype.hide = function () {
        if (!this._isDisposed && this._isVisible) {
            this._chromeDiv = document.body.removeChild(this._chromeDiv);
            this._isVisible = false;
        }
    };
    SPMasterChrome.prototype.dispose = function () {
        if (!this._isDisposed) {
            this._chromeDiv = document.body.removeChild(this._chromeDiv);
            delete this._suiteNavDiv;
            delete this._chromeDiv;
            this._isDisposed = true;
        }
    };
    Object.defineProperty(SPMasterChrome.prototype, "chromeDiv", {
        get: function () {
            return this._chromeDiv;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SPMasterChrome.prototype, "suiteNavDiv", {
        get: function () {
            return this._suiteNavDiv;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SPMasterChrome.prototype, "isDisposed", {
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    SPMasterChrome.prototype._createPageChrome = function () {
        sp_telemetry_["_PerformanceLogger"].devMark('SPPageChrome.createPageChromeMaster');
        document.body.className = 'ms-font-m';
        this._chromeDiv = document.createElement('div');
        this._chromeDiv.setAttribute('class', 'SPPageChrome');
        this._suiteNavDiv = document.createElement('div');
        this._suiteNavDiv.setAttribute('id', 'SuiteNavPlaceHolder');
        this._chromeDiv.appendChild(this._suiteNavDiv);
        if (!window.onerror) {
            window.onerror = error_SPGlobalErrorHandler.basicTracingHandler;
        }
    };
    return SPMasterChrome;
}());
/* harmony default export */ var pageChrome_SPMasterChrome = (SPMasterChrome_SPMasterChrome);

// CONCATENATED MODULE: ./lib/navigator/NavigationOrchestrator.js














var NavigationOrchestrator_NavigationOrchestrator =  (function () {
    function NavigationOrchestrator(serviceScope, applicationManager, navigator) {
        sp_core_library_["Validate"].isNotNullOrUndefined(serviceScope, 'serviceScope');
        this._serviceScope = serviceScope;
        this._applicationManager = applicationManager || new lib_ApplicationManager(serviceScope, navigator);
        this._pageContext = serviceScope.consume(sp_page_context_["PageContext"].serviceKey);
        this._applicationCustomizerLoader = new extensibility_ApplicationCustomizerLoader(serviceScope);
    }
    NavigationOrchestrator.raiseNavigatedEvent = function () {
        sp_core_library_["_SPEventManager"].instance.raiseStickyEvent(lib_BaseApplication._navigatedEventName, {});
    };
    NavigationOrchestrator.prototype.navigate = function (preloadedData) {
        var _this = this;
        var isDifferentApp = !this._applicationManager.currentApplicationId.equals(sp_core_library_["Guid"].empty)
            && !this._applicationManager.currentApplicationId.equals(sp_core_library_["Guid"].tryParse(preloadedData.clientSideApplicationId) || sp_core_library_["Guid"].empty);
        if (!sp_loader_["_SPLoaderFlights"]._useNewBootSequence()) {
            if (isDifferentApp) {
                return Promise.resolve({
                    preloadedData: preloadedData,
                    application: undefined,
                    operation: NavigationOperation.Unsupported
                });
            }
        }
        this._fixPreloadedDataItem(preloadedData);
        var isCrossSite = this._isCrossSite(preloadedData, this._pageContext);
        var pageChrome = undefined;
        this._pageContext.initialize(sp_page_context_["SharePointPageContextDataProvider"]._createPageContextData(preloadedData.spPageContextInfo), preloadedData.spPageContextInfo);
        sp_loader_["_ManifestStore"].instance.replaceManifests(preloadedData.manifests);
        if (!lib_ApplicationManager._isChromelessApplication(preloadedData.clientSideApplicationId)) {
            if (Flights_Flights.useNewChromeSequence() && !this._masterChrome) {
                this._masterChrome = new pageChrome_SPMasterChrome();
            }
            pageChrome = new pageChrome_SPPageChrome(this._serviceScope, this._masterChrome);
        }
        if (Killswitches["a" /* Killswitches */].themeProviderOverrideKSActive()
            && isCrossSite
            && !lib_ApplicationManager._isChromelessApplication(preloadedData.clientSideApplicationId)) {
            var themeProvider = new pageChrome_SPThemeProvider(this._serviceScope);
            themeProvider.loadThemedStyles();
        }
        this._updateTelemetry(preloadedData);
        preloadedData.spPageContextInfo = undefined;
        sp_core_library_["Session"]._changePage();
        NavigationOrchestrator.raiseNavigatedEvent();
        if (sp_loader_["_SPLoaderFlights"]._useNewBootSequence()) {
            if (!Killswitches["a" /* Killswitches */].themeProviderOverrideKSActive()
                && !isDifferentApp
                && isCrossSite
                && !lib_ApplicationManager._isChromelessApplication(preloadedData.clientSideApplicationId)) {
                this._applicationManager.currentApplication._loadTheme();
            }
            if (this._applicationManager.currentApplicationId.equals(sp_core_library_["Guid"].tryParse(preloadedData.clientSideApplicationId) || sp_core_library_["Guid"].empty)) {
                this._loadApplicationCustomizers(preloadedData);
                return Promise.resolve({
                    preloadedData: preloadedData,
                    application: this._applicationManager.currentApplication,
                    operation: NavigationOperation.UpdateContext
                });
            }
            else {
                if (!Killswitches["a" /* Killswitches */].appCustomizersLoadSequenceKSActive()) {
                    var appStartPromise = this._applicationManager.startApplication(preloadedData, pageChrome);
                    this._loadApplicationCustomizers(preloadedData);
                    return appStartPromise.then(function (application) {
                        return Promise.resolve({
                            preloadedData: preloadedData,
                            application: application,
                            operation: NavigationOperation.LoadApplication
                        });
                    });
                }
                else {
                    return this._applicationManager.startApplication(preloadedData, pageChrome)
                        .then(function (application) {
                        _this._loadApplicationCustomizers(preloadedData);
                        return Promise.resolve({
                            preloadedData: preloadedData,
                            application: application,
                            operation: NavigationOperation.LoadApplication
                        });
                    });
                }
            }
        }
        else {
            return Promise.resolve({
                preloadedData: preloadedData,
                application: undefined,
                operation: NavigationOperation.UpdateContext
            });
        }
    };
    NavigationOrchestrator.prototype._loadApplicationCustomizers = function (preloadedData) {
        if (preloadedData.clientSideApplicationId !== NavigationOrchestrator.classicPagesComponentId &&
            preloadedData.clientSideApplicationId !== NavigationOrchestrator.workbenchComponentId) {
            sp_diagnostics_["_TraceLogger"].logVerbose(NavigationOrchestrator._logSource, 'Loading application customizers');
            return this._applicationCustomizerLoader.loadExtensions(preloadedData.customActions);
        }
        else {
            sp_diagnostics_["_TraceLogger"].logVerbose(NavigationOrchestrator._logSource, 'Application Customizer is not supported for classic pages and workbench.');
            return Promise.resolve();
        }
    };
    NavigationOrchestrator.prototype._updateTelemetry = function (preloadedData) {
        var _a = this._pageContext.legacyPageContext, siteId = _a.siteId, webId = _a.webId;
        var emptyIdValueForMerge = ''; 
        var listId = (this._pageContext.list && this._pageContext.list.id.toString()) ||
            emptyIdValueForMerge;
        var uniqueId = (preloadedData.item && preloadedData.item.UniqueId) ||
            emptyIdValueForMerge;
        sp_telemetry_["_Telemetry"].updateSettings({
            siteId: siteId,
            webId: webId,
            listId: listId,
            listItemUniqueId: uniqueId
        });
        sp_diagnostics_["_Diagnostics"].updateSettings({
            siteId: siteId,
            webId: webId,
            listId: listId,
            listItemUniqueId: uniqueId
        });
    };
    NavigationOrchestrator.prototype._isCrossSite = function (preloadedData, pageContext) {
        if (!pageContext.isInitialized) { 
            return false;
        }
        return !sp_core_library_["Guid"].parse(preloadedData.spPageContextInfo.webId).equals(pageContext.web.id) ||
            !sp_core_library_["Guid"].parse(preloadedData.spPageContextInfo.siteId).equals(pageContext.site.id);
    };
    NavigationOrchestrator.prototype._fixPreloadedDataItem = function (preloadedData) {
        var INVALID_PAGE_ITEM_ID = -1;
        if (preloadedData.spPageContextInfo.pageItemId === INVALID_PAGE_ITEM_ID &&
            preloadedData.item &&
            preloadedData.item.ID !== INVALID_PAGE_ITEM_ID) {
            preloadedData.spPageContextInfo.pageItemId = preloadedData.item.ID;
        }
        return preloadedData;
    };
    NavigationOrchestrator.classicPagesComponentId = 'eb4b666b-5c29-4dad-9a99-23613f21a2b7';
    NavigationOrchestrator.workbenchComponentId = '8be81a5c-af38-4bb2-af97-afa3b64dfbed';
    NavigationOrchestrator._logSource = sp_diagnostics_["_LogSource"].create('NavigationOrchestrator');
    return NavigationOrchestrator;
}());
/* harmony default export */ var navigator_NavigationOrchestrator = (NavigationOrchestrator_NavigationOrchestrator);

// CONCATENATED MODULE: ./lib/navigator/PrefetchedDataEventArgs.js


var PrefetchedDataEventArgs_PrefetchedDataEventArgs =  (function (_super) {
    tslib_es6["__extends"](PrefetchedDataEventArgs, _super);
    function PrefetchedDataEventArgs(appId, url, data) {
        var _this = this;
        sp_core_library_["Validate"].isNonemptyString(appId, 'id');
        sp_core_library_["Validate"].isNonemptyString(url, 'url');
        _this = _super.call(this) || this;
        _this.applicationId = appId;
        _this.url = url;
        _this.data = data;
        return _this;
    }
    return PrefetchedDataEventArgs;
}(sp_core_library_["SPEventArgs"]));
/* harmony default export */ var navigator_PrefetchedDataEventArgs = (PrefetchedDataEventArgs_PrefetchedDataEventArgs);

// CONCATENATED MODULE: ./lib/navigator/Navigator.js









var navigateQosScenarioName = 'Navigator.navigate';
var navigateToPreloadedDataQosScenarioName = 'Navigator.navigateToPreloadedData';
var prefetchNavigationDataQosScenarioName = 'Navigator.prefetch';
var NAVIGATE_TO_URL_ON_ERROR = sp_core_library_["Guid"].parse('9078878d-3ba1-41e4-8faf-fb4e2e69f3dc');
var Navigator_Navigator =  (function () {
    function Navigator(serviceScope, applicationManager) {
        var _this = this;
        sp_core_library_["Validate"].isNotNullOrUndefined(serviceScope, 'serviceScope');
        this._navigationDataProvider = new navigator_NavigationDataProvider(serviceScope, function (data) {
            _this._validatePreloadedData(data);
        });
        this._navigationOrchestrator = new navigator_NavigationOrchestrator(serviceScope, applicationManager, this);
    }
    Object.defineProperty(Navigator.prototype, "preloadedData", {
        get: function () {
            sp_core_library_["Validate"].isNotNullOrUndefined(this._preloadedData, 'preloadedData');
            return this._preloadedData;
        },
        enumerable: true,
        configurable: true
    });
    Navigator.prototype.navigate = function (url, props) {
        var _this = this;
        sp_core_library_["Validate"].isNonemptyString(url, 'url');
        var qosMonitor = new sp_diagnostics_["_QosMonitor"](navigateQosScenarioName);
        return this._navigationDataProvider.getData(url, props).then(function (response) {
            return response.preloadedData.then(function (preloadedData) {
                _this._processDataPrefetch(url, preloadedData, response.prefetchedData, true);
                return _this.navigateToPreloadedData(preloadedData);
            }).then(function (navigationResult) {
                qosMonitor.writeSuccess();
                return navigationResult;
            });
        }).catch(function (error) {
            qosMonitor.writeUnexpectedFailure(undefined, error);
            if (sp_core_library_["_SPKillSwitch"].isActivated(NAVIGATE_TO_URL_ON_ERROR, '04/16/2018', 'Navigate to url on error')) {
                location.href = url;
            }
            throw error;
        });
    };
    Navigator.prototype.prefetch = function (url, props) {
        var _this = this;
        if (!sp_loader_["_SPLoaderFlights"]._useNewBootSequence()) {
            return Promise.resolve();
        }
        var prefetchProps = Killswitches["a" /* Killswitches */].usePrefetchHeader() ? tslib_es6["__assign"]({}, props, { isPrefetchRequest: true }) : props;
        sp_core_library_["Validate"].isNonemptyString(url, 'url');
        var qosMonitor = new sp_diagnostics_["_QosMonitor"](prefetchNavigationDataQosScenarioName);
        return new Promise(function (resolve, reject) {
            _this._navigationDataProvider.getData(url, prefetchProps).then(function (response) {
                response.preloadedData.then(function (preloadedData) {
                    _this._processDataPrefetch(url, preloadedData, response.prefetchedData, false);
                    qosMonitor.writeSuccess();
                    resolve();
                });
            }).catch(function (error) {
                qosMonitor.writeUnexpectedFailure(undefined, error);
                reject(error);
            });
        });
    };
    Navigator.prototype.navigateToPreloadedData = function (preloadedData) {
        var _this = this;
        var qosMonitor = new sp_diagnostics_["_QosMonitor"](navigateToPreloadedDataQosScenarioName);
        try {
            this._validatePreloadedData(preloadedData);
            this._preloadedData = preloadedData;
            return this._navigationOrchestrator.navigate(preloadedData).then(function (navigationResult) {
                _this._preloadedData = navigationResult.preloadedData;
                qosMonitor.writeSuccess();
                return navigationResult;
            }).catch(function (error) {
                qosMonitor.writeUnexpectedFailure('AsyncError', error);
                throw error;
            });
        }
        catch (error) {
            qosMonitor.writeUnexpectedFailure('SyncError', error);
            return Promise.reject(error);
        }
    };
    Navigator.prototype.navigateToApplication = function (preloadedData) {
        var _this = this;
        var qosMonitor = new sp_diagnostics_["_QosMonitor"](navigateToPreloadedDataQosScenarioName);
        try {
            this._validatePreloadedData(preloadedData);
            this._preloadedData = preloadedData;
            return this._navigationOrchestrator.navigate(preloadedData).then(function (navigationResult) {
                _this._preloadedData = navigationResult.preloadedData;
                qosMonitor.writeSuccess();
                return Promise.resolve(navigationResult.application);
            });
        }
        catch (error) {
            qosMonitor.writeUnexpectedFailure(error);
            throw error;
        }
    };
    Navigator.prototype._loadApplicationCustomizers = function (preloadedData) {
        return this._navigationOrchestrator._loadApplicationCustomizers(preloadedData);
    };
    Navigator.prototype.invalidate = function (url) {
        return this._navigationDataProvider.invalidate(url);
    };
    Navigator.prototype._validatePreloadedData = function (preloadedData) {
        sp_core_library_["Validate"].isNotNullOrUndefined(preloadedData, 'preloadedData');
        sp_core_library_["Validate"].isNotNullOrUndefined(preloadedData.spPageContextInfo, 'preloadedData.spPageContextInfo');
        sp_core_library_["Validate"].isNonemptyString(preloadedData.clientSideApplicationId, 'preloadedData.clientSideApplicationId');
    };
    Navigator.prototype._isDataPrefetchSupported = function (componentId) {
        return componentId === 'b6917cb1-93a0-4b97-a84d-7cf49975d4ec';
    };
    Navigator.prototype._processDataPrefetch = function (url, preloadedData, prefetchData, 
    shouldRaiseEvent) {
        if (prefetchData &&
            this._isDataPrefetchSupported(preloadedData.clientSideApplicationId)) {
            prefetchData.then(function (data) {
                if (shouldRaiseEvent && data) {
                    sp_core_library_["_SPEventManager"].instance.raiseStickyEvent(lib_BaseApplication._prefetchedDataEventName, new navigator_PrefetchedDataEventArgs(preloadedData.clientSideApplicationId, url, data));
                }
            });
        }
    };
    return Navigator;
}());
/* harmony default export */ var navigator_Navigator = (Navigator_Navigator);

// CONCATENATED MODULE: ./lib/ApplicationManager.js








var startQosScenarioName = 'ApplicationManager.start';
var initializeQosScenarioName = 'ApplicationManager.initialize';
var applicationFailedToLoadFailure = 'ApplicationFailedToLoad';
var shellStartFailure = 'SPShell.Start';
var ApplicationManager_ApplicationManager =  (function () {
    function ApplicationManager(serviceScope, navigator) {
        sp_core_library_["Validate"].isNotNullOrUndefined(serviceScope, 'serviceScope');
        this._serviceScope = serviceScope;
        this._navigator = navigator || new navigator_Navigator(this._serviceScope, this);
    }
    ApplicationManager._isChromelessApplication = function (componentId) {
        return sp_core_library_["Environment"].type === sp_core_library_["EnvironmentType"].ClassicSharePoint ||
            componentId === 'b1ab4aaa-f779-405c-8683-d3a750b5d18d';
    };
    Object.defineProperty(ApplicationManager.prototype, "currentApplicationId", {
        get: function () {
            var appComponentId = this._currentApplication && this._currentApplication.componentId;
            return appComponentId ? sp_core_library_["Guid"].parse(appComponentId) : sp_core_library_["Guid"].empty;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ApplicationManager.prototype, "currentApplication", {
        get: function () {
            sp_core_library_["Validate"].isNotNullOrUndefined(this._currentApplication, 'currentApplication');
            return this._currentApplication;
        },
        enumerable: true,
        configurable: true
    });
    ApplicationManager.prototype.startApplication = function (preloadedData, pageChrome) {
        var _this = this;
        try {
            sp_core_library_["Validate"].isNonemptyString(preloadedData.clientSideApplicationId, 'preloadedData.clientSideApplicationId');
        }
        catch (error) {
            return Promise.reject(error);
        }
        var qosMonitor = new sp_diagnostics_["_QosMonitor"](startQosScenarioName);
        function error(message, failureId) {
            var err = new Error(message);
            sp_diagnostics_["_TraceLogger"].logError(ApplicationManager._logSource, err);
            qosMonitor.writeUnexpectedFailure(failureId, err);
            throw err;
        }
        var applicationId = preloadedData.clientSideApplicationId;
        if (!this._isChromelessApplication(applicationId) && !pageChrome) {
            pageChrome = new pageChrome_SPPageChrome(this._serviceScope);
        }
        var appManifest = sp_loader_["SPComponentLoader"].tryGetManifestById(applicationId);
        var appComponent = !!appManifest ? sp_loader_["SPComponentLoader"].tryGetLoadedComponent(appManifest) : undefined;
        if (appComponent) {
            if (!sp_loader_["_SPLoaderFlights"]._useNewBootSequence()) {
                this._navigator.navigateToPreloadedData(preloadedData);
            }
            return this._initializeApplicationWithTelemetry(appComponent, applicationId, pageChrome, qosMonitor, error).then(function (app) {
                if (!sp_loader_["_SPLoaderFlights"]._useNewBootSequence()) {
                    _this._navigator._loadApplicationCustomizers(preloadedData);
                }
                return app;
            });
        }
        else {
            var appComponentPromise = this._loadApplicationComponent(applicationId, error);
            if (!sp_loader_["_SPLoaderFlights"]._useNewBootSequence()) {
                this._navigator.navigateToPreloadedData(preloadedData);
            }
            return appComponentPromise.then(function (application) {
                return _this._initializeApplicationWithTelemetry(application, applicationId, pageChrome, qosMonitor, error).then(function (app) {
                    if (!sp_loader_["_SPLoaderFlights"]._useNewBootSequence()) {
                        _this._navigator._loadApplicationCustomizers(preloadedData);
                    }
                    return app;
                });
            });
        }
    };
    Object.defineProperty(ApplicationManager.prototype, "_applicationLoadType", {
        get: function () {
            return this._previousApplication ?
                ApplicationLoadType.InPlaceNavigation :
                ApplicationLoadType.FullPageLoad;
        },
        enumerable: true,
        configurable: true
    });
    ApplicationManager.prototype._shouldCreateNewAppInstance = function () {
        return !sp_core_library_["_SPKillSwitch"].isActivated(sp_core_library_["Guid"].parse('b37f208b-f531-4e75-924d-2ef4324d3f6b'), '12/06/2018', 'CreateNewAppInstance');
    };
    ApplicationManager.prototype._initializeApplicationWithTelemetry = function (application, applicationId, pageChrome, qosMonitor, error) {
        sp_telemetry_["_PerformanceLogger"].markApplicationStart();
        return this._initializeApplication(this._shouldCreateNewAppInstance() && application.application ?
            new application.application() :
            application.default, applicationId, pageChrome)
            .then(function (result) {
            qosMonitor.writeSuccess();
            return result;
        }).catch(function (e) {
            return error(sp_core_library_["Text"].format(SPApplicationBase_resx.applicationFailedToInitializeError, e), shellStartFailure);
        });
    };
    ApplicationManager.prototype._loadApplicationComponent = function (applicationId, error) {
        return sp_loader_["SPComponentLoader"].loadComponentById(applicationId)
            .catch(function (e) {
            return error(sp_core_library_["Text"].format(SPApplicationBase_resx.applicationFailedToLoadWithMessageError, applicationId, e.message), applicationFailedToLoadFailure);
        });
    };
    ApplicationManager.prototype._isChromelessApplication = function (applicationId) {
        return ApplicationManager._isChromelessApplication(applicationId);
    };
    ApplicationManager.prototype._initializeApplication = function (application, applicationId, pageChrome) {
        var _this = this;
        if (application['__type'] !== 'BaseApplication') { 
            return Promise.reject(new Error('The application is not a subclass of BaseApplication'));
        }
        var qosMonitor = new sp_diagnostics_["_QosMonitor"](initializeQosScenarioName);
        var applicationManifest = sp_loader_["SPComponentLoader"].tryGetManifestById(applicationId);
        var qosApplicationData = {
            alias: application.alias || applicationManifest.alias,
            isInternal: applicationManifest.isInternal,
            manifestId: applicationManifest.id
        };
        if (sp_loader_["_SPLoaderFlights"]._useNewBootSequence() && this._currentApplication) {
            this._previousApplication = this._currentApplication;
        }
        this._currentApplication = application;
        if (this._previousApplication) {
            this._previousApplication._unload();
        }
        try {
            return this._currentApplication._load({
                manifest: applicationManifest,
                parentServiceScope: this._serviceScope,
                navigator: this._navigator,
                instanceId: applicationManifest.id,
                loggingTag: "Application." + applicationManifest.id,
                chrome: pageChrome,
                loadType: this._applicationLoadType
            }).then(function () {
                if (_this._previousApplication) {
                    _this._previousApplication.dispose();
                    if (_this._shouldCreateNewAppInstance()) {
                        _this._previousApplication = undefined;
                    }
                }
                if (!_this._isChromelessApplication(applicationId)) {
                    _this._currentApplication._loadTheme();
                    _this._currentApplication._render();
                }
                qosMonitor.writeSuccess(qosApplicationData);
                return application;
            }).catch(function (e) {
                qosMonitor.writeUnexpectedFailure('AsyncError', e, qosApplicationData);
                return Promise.reject(e);
            });
        }
        catch (e) {
            qosMonitor.writeUnexpectedFailure('GeneralError', e, qosApplicationData);
            return Promise.reject(e);
        }
    };
    ApplicationManager._logSource = sp_diagnostics_["_LogSource"].create('ApplicationManager');
    return ApplicationManager;
}());
/* harmony default export */ var lib_ApplicationManager = (ApplicationManager_ApplicationManager);

// CONCATENATED MODULE: ./lib/BaseApplication.js















var BaseApplication_SUITE_NAV_USE_SPO_BEHAVIOR_KILL_SWITCH = sp_core_library_["Guid"].parse('22F8084E-9DEB-4642-B63E-E70A7F87C998');
var loadQosScenarioName = 'BaseApplication.load';
var renderQosScenarioName = 'BaseApplication.render';
var unloadQosScenarioName = 'BaseApplication.unload';
var BaseApplication_BaseApplication =  (function (_super) {
    tslib_es6["__extends"](BaseApplication, _super);
    function BaseApplication() {
        var _this = _super.call(this) || this;
        _this['__type'] = 'BaseApplication';
        return _this;
    }
    Object.defineProperty(BaseApplication.prototype, "domElement", {
        get: function () {
            sp_core_library_["Validate"].isNotNullOrUndefined(this.context, 'context');
            sp_core_library_["Validate"].isNotDisposed(this.context, 'context');
            sp_core_library_["Validate"].isNotNullOrUndefined(this.context.chrome, 'chrome');
            sp_core_library_["Validate"].isNotDisposed(this.context.chrome, 'chrome');
            return this.context.chrome.appDiv;
        },
        set: function (value) {
            throw new Error('The property cannot be assigned because it is read-only');
        },
        enumerable: true,
        configurable: true
    });
    BaseApplication.prototype._load = function (contextParameters) {
        var qosMonitor = new sp_diagnostics_["_QosMonitor"](loadQosScenarioName);
        try {
            var applicationContext = this._getApplicationContext(contextParameters);
            this._initializeContext(applicationContext);
            var aadPlaceholderManager = new frameworkPlaceholders_AadPlaceholderManager();
            aadPlaceholderManager.setUpTokenAcquistionFailurePlaceholder(this, this.context.serviceScope);
            return this.onLoad()
                .then(function () {
                qosMonitor.writeSuccess();
            }).catch(function (e) {
                qosMonitor.writeExpectedFailure('onLoadFailure', e);
                throw e;
            });
        }
        catch (error) {
            qosMonitor.writeUnexpectedFailure('SyncError', error);
            return Promise.reject(error);
        }
    };
    BaseApplication.prototype._render = function () {
        var qosMonitor = new sp_diagnostics_["_QosMonitor"](renderQosScenarioName);
        try {
            sp_load_themed_styles_["flush"]();
            this.context.chrome.show();
            var isFullPageLoad = sp_loader_["_SPLoaderFlights"]._useNewBootSequence() && Flights_Flights.useNewChromeSequence() ?
                this.context.loadType === ApplicationLoadType.FullPageLoad :
                true;
            var suiteNavManager = new lib_SuiteNavManager(this.context.chrome.suiteNavDiv, this.context.serviceScope, isFullPageLoad);
            this.context.initializeSuiteNavManager(suiteNavManager);
            if (!this.suiteNavConfiguration().isSuiteNavDisabled()) {
                if (sp_core_library_["_SPFlight"].isEnabled(1309 )
                    && this.suiteNavConfiguration().isSuiteNavLoadingDeferred()) {
                    suiteNavManager.loadSuiteNavNewFlow(this.suiteNavConfiguration()); 
                }
                else {
                    suiteNavManager.loadSuiteNav(this.suiteNavConfiguration());
                }
            }
            this.onRender();
            qosMonitor.writeSuccess();
        }
        catch (error) {
            qosMonitor.writeExpectedFailure('onRenderError', error);
        }
    };
    BaseApplication.prototype._unload = function () {
        if (!sp_loader_["_SPLoaderFlights"]._useNewBootSequence()) {
            return;
        }
        var qosMonitor = new sp_diagnostics_["_QosMonitor"](unloadQosScenarioName);
        try {
            this.onUnload();
            qosMonitor.writeSuccess();
        }
        catch (error) {
            qosMonitor.writeExpectedFailure('onUnloadError', error);
        }
    };
    BaseApplication.prototype._loadTheme = function () {
        if (Killswitches["a" /* Killswitches */].themeProviderChromelessKSActive()
            || !lib_ApplicationManager._isChromelessApplication(this.componentId)) {
            var themeProvider = this._getThemeProvider();
            themeProvider.loadThemedStyles();
        }
    };
    BaseApplication.prototype.dispose = function () {
        if (sp_loader_["_SPLoaderFlights"]._useNewBootSequence() && this.context.chrome) {
            this.context.chrome.hide();
        }
        this.onDispose();
        _super.prototype.dispose.call(this);
    };
    BaseApplication.prototype.getBrowserCompatibility = function () {
        return {
            supportLevel: 0 ,
            warning: undefined
        };
    };
    BaseApplication.prototype.suiteNavConfiguration = function () {
        var config = new lib_SuiteNavManagerConfiguration(this._getSuiteNavManagerConfigurationData());
        config.updateSuiteNavHeight = this._suiteNavHeightHandler.bind(this);
        return config;
    };
    BaseApplication.prototype._getApplicationContext = function (contextParameters) {
        return new lib_BaseApplicationContext(contextParameters);
    };
    BaseApplication.prototype._getThemeProvider = function () {
        return new pageChrome_SPThemeProvider(this.context.serviceScope);
    };
    BaseApplication.prototype.onLoad = function () {
        return Promise.resolve();
    };
    BaseApplication.prototype.onUnload = function () {
    };
    BaseApplication.prototype.onRender = function () {
    };
    BaseApplication.prototype.onDispose = function () {
    };
    BaseApplication.prototype._getSuiteNavManagerConfigurationData = function () {
        var pageContext = this.context.pageContext;
        var webTemplateId;
        if (!sp_core_library_["_SPKillSwitch"].isActivated(BaseApplication_SUITE_NAV_USE_SPO_BEHAVIOR_KILL_SWITCH, '9/08/2017', 'SuiteNavUseSPOBehaviors')) {
            webTemplateId = pageContext.legacyPageContext.webTemplateId;
        }
        return {
            currentUICultureName: pageContext.cultureInfo.currentUICultureName,
            disableSuiteNav: this._shouldDisableSuiteNav(),
            settingsData: pageContext.legacyPageContext.MenuData ?
                pageContext.legacyPageContext.MenuData.SettingsData :
                undefined,
            signoutUrl: pageContext.legacyPageContext.MenuData ?
                pageContext.legacyPageContext.MenuData.SignOutUrl :
                undefined,
            siteClientTag: pageContext.legacyPageContext.siteClientTag,
            systemUserKey: pageContext.legacyPageContext.systemUserKey,
            userDisplayName: pageContext.user.displayName,
            webServerRelativeUrl: pageContext.web.serverRelativeUrl,
            webTemplateId: webTemplateId
        };
    };
    BaseApplication.prototype._navigate = function (url, props) {
        var _this = this;
        sp_core_library_["Validate"].isNonemptyString(url, 'url');
        return this.context.navigator.navigate(url, props).then(function (res) {
            if (!sp_loader_["_SPLoaderFlights"]._useNewBootSequence()) {
                _this.context.navigator._loadApplicationCustomizers(res.preloadedData);
            }
            return res;
        });
    };
    BaseApplication.prototype._navigateToPreloadedData = function (preloadedData) {
        var _this = this;
        sp_core_library_["Validate"].isNotNullOrUndefined(preloadedData, 'preloadedData');
        this.context.navigator.navigateToPreloadedData(preloadedData).then(function () {
            if (!sp_loader_["_SPLoaderFlights"]._useNewBootSequence()) {
                _this.context.navigator._loadApplicationCustomizers(preloadedData);
            }
        });
    };
    BaseApplication.prototype._invalidate = function (url) {
        sp_core_library_["Validate"].isNonemptyString(url, 'url');
        return this.context.navigator.invalidate(url);
    };
    BaseApplication.prototype.raiseLayoutChangedEvent = function () {
        sp_core_library_["_SPEventManager"].instance.raiseEvent(BaseApplication._layoutChangedEventName, {});
    };
    BaseApplication.prototype._shouldDisableSuiteNav = function () {
        var urlQueryParams = new sp_core_library_["UrlQueryParameterCollection"](window.location.href);
        return window.location.hostname === 'localhost' ||
            urlQueryParams.getValue('disableSuiteNav') === 'true' ?
            true :
            false;
    };
    BaseApplication.prototype._suiteNavHeightHandler = function (height) {
        if (this.context.chrome) {
            this.context.chrome.changeSuiteNavHeight(height);
        }
    };
    BaseApplication._navigatedEventName = 'application.navigatedEvent';
    BaseApplication._layoutChangedEventName = 'application.layoutChangedEvent';
    BaseApplication._prefetchedDataEventName = 'application.prefetchedDataEvent';
    tslib_es6["__decorate"]([
        decorators_["override"]
    ], BaseApplication.prototype, "dispose", null);
    tslib_es6["__decorate"]([
        decorators_["virtual"]
    ], BaseApplication.prototype, "getBrowserCompatibility", null);
    tslib_es6["__decorate"]([
        decorators_["virtual"]
    ], BaseApplication.prototype, "suiteNavConfiguration", null);
    tslib_es6["__decorate"]([
        decorators_["virtual"]
    ], BaseApplication.prototype, "_getApplicationContext", null);
    tslib_es6["__decorate"]([
        decorators_["virtual"]
    ], BaseApplication.prototype, "_getThemeProvider", null);
    tslib_es6["__decorate"]([
        decorators_["virtual"]
    ], BaseApplication.prototype, "onLoad", null);
    tslib_es6["__decorate"]([
        decorators_["virtual"]
    ], BaseApplication.prototype, "onUnload", null);
    tslib_es6["__decorate"]([
        decorators_["virtual"]
    ], BaseApplication.prototype, "onRender", null);
    tslib_es6["__decorate"]([
        decorators_["virtual"]
    ], BaseApplication.prototype, "onDispose", null);
    return BaseApplication;
}(sp_component_base_["BaseComponent"]));
/* harmony default export */ var lib_BaseApplication = (BaseApplication_BaseApplication);

// CONCATENATED MODULE: ./lib/extensibility/ApplicationAccessor.js


var ApplicationAccessor_ApplicationAccessor =  (function () {
    function ApplicationAccessor(serviceScope) {
        this._navigatedEvent = new sp_core_library_["SPEvent"](lib_BaseApplication._navigatedEventName);
        this._privateLayoutChangedEvent = new sp_core_library_["SPEvent"](lib_BaseApplication._layoutChangedEventName);
    }
    Object.defineProperty(ApplicationAccessor.prototype, "navigatedEvent", {
        get: function () {
            return this._navigatedEvent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ApplicationAccessor.prototype, "_layoutChangedEvent", {
        get: function () {
            return this._privateLayoutChangedEvent;
        },
        enumerable: true,
        configurable: true
    });
    return ApplicationAccessor;
}());
/* harmony default export */ var extensibility_ApplicationAccessor = (ApplicationAccessor_ApplicationAccessor);

// CONCATENATED MODULE: ./lib/extensibility/ApplicationCustomizerContext.js




var ApplicationCustomizerContext_ApplicationCustomizerContext =  (function (_super) {
    tslib_es6["__extends"](ApplicationCustomizerContext, _super);
    function ApplicationCustomizerContext(extensionContextParameters, applicationCustomizerContextParameters) {
        var _this = _super.call(this, extensionContextParameters) || this;
        _this._placeholderProvider =
            new placeholder_PlaceholderProvider(_this.serviceScope, applicationCustomizerContextParameters.sequence);
        _this._applicationAccessor = new extensibility_ApplicationAccessor(_this.serviceScope);
        return _this;
    }
    Object.defineProperty(ApplicationCustomizerContext.prototype, "placeholderProvider", {
        get: function () {
            return this._placeholderProvider;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ApplicationCustomizerContext.prototype, "application", {
        get: function () {
            return this._applicationAccessor;
        },
        enumerable: true,
        configurable: true
    });
    ApplicationCustomizerContext.prototype.dispose = function () {
        if (!this.isDisposed) {
            this._placeholderProvider.dispose();
            delete this._placeholderProvider;
            delete this._applicationAccessor;
        }
        _super.prototype.dispose.call(this);
    };
    return ApplicationCustomizerContext;
}(sp_extension_base_["ExtensionContext"]));
/* harmony default export */ var extensibility_ApplicationCustomizerContext = (ApplicationCustomizerContext_ApplicationCustomizerContext);

// CONCATENATED MODULE: ./lib/index.js
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "ApplicationCustomizerContext", function() { return extensibility_ApplicationCustomizerContext; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "BaseApplicationCustomizer", function() { return extensibility_BaseApplicationCustomizer; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "ApplicationAccessor", function() { return extensibility_ApplicationAccessor; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_DialogManagerConfiguration", function() { return extensibility_DialogManagerConfiguration; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "PlaceholderContent", function() { return placeholder_PlaceholderContent; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "PlaceholderName", function() { return placeholder_PlaceholderName; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_Placeholder", function() { return placeholder_Placeholder; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "PlaceholderProvider", function() { return placeholder_PlaceholderProvider; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_PlaceholderManager", function() { return placeholder_PlaceholderManager; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "BaseApplication", function() { return lib_BaseApplication; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "BaseApplicationContext", function() { return lib_BaseApplicationContext; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_ApplicationManager", function() { return lib_ApplicationManager; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_Navigator", function() { return navigator_Navigator; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_NavigationOperation", function() { return NavigationOperation; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_PrefetchedDataEventArgs", function() { return navigator_PrefetchedDataEventArgs; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_ApplicationLoadType", function() { return ApplicationLoadType; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_SPThemeProvider", function() { return pageChrome_SPThemeProvider; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_ODSPThemeProvider", function() { return ThemeProvider_default.a; });




















/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var load_themed_styles_1 = __webpack_require__(41);
function loadFallbackShellThemableCss() {
    var strCss = ".o365cs-base .o365cs-nav-contextMenu {" +
        "    background-color: '[theme:white, default:#ffffff]';" + // BackgroundOverlay
        "}\n" +
        ".o365cs-base-visibility" +
        "{" +
        "  visibility: visible;" +
        "}\n" +
        ".o365cs-base .ms-fcl-tdr," +
        ".o365cs-base .ms-fcl-tdr-h:hover," +
        ".o365cs-base .ms-fcl-tdr-f:focus" +
        "{" +
        "    color: '[theme:themeDarker, default:#104a7d]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-tdr," +
        ".o365cs-base .ms-bgc-tdr-h:hover," +
        ".o365cs-base .ms-bgc-tdr-f:focus" +
        "{" +
        "    background-color: '[theme:themeDarker, default:#104a7d]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-tdr," +
        ".o365cs-base .ms-bcl-tdr-h:hover," +
        ".o365cs-base .ms-bcl-tdr-f:focus" +
        "{" +
        "    border-color: '[theme:themeDarker, default:#104a7d]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-td," +
        ".o365cs-base .ms-fcl-td-h:hover," +
        ".o365cs-base .ms-fcl-td-f:focus" +
        "{" +
        "    color: '[theme:themeDark, default:#0d62aa]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-td," +
        ".o365cs-base .ms-bgc-td-h:hover," +
        ".o365cs-base .ms-bgc-td-f:focus" +
        "{" +
        "    background-color: '[theme:themeDark, default:#0d62aa]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-td," +
        ".o365cs-base .ms-bcl-td-h:hover," +
        ".o365cs-base .ms-bcl-td-f:focus" +
        "{" +
        "    border-color: '[theme:themeDark, default:#0d62aa]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-tda," +
        ".o365cs-base .ms-fcl-tda-h:hover," +
        ".o365cs-base .ms-fcl-tda-f:focus" +
        "{" +
        "    color: '[theme:themeDarkAlt, default:#106ebe]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-tda," +
        ".o365cs-base .ms-bgc-tda-h:hover," +
        ".o365cs-base .ms-bgc-tda-f:focus" +
        "{" +
        "    background-color: '[theme:themeDarkAlt, default:#106ebe]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-tda," +
        ".o365cs-base .ms-bcl-tda-h:hover," +
        ".o365cs-base .ms-bcl-tda-f:focus" +
        "{" +
        "    border-color: '[theme:themeDarkAlt, default:#106ebe]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-tp," +
        ".o365cs-base .ms-fcl-tp-h:hover," +
        ".o365cs-base .ms-fcl-tp-f:focus" +
        "{" +
        "    color: '[theme:themePrimary, default:#0078d7]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-tp," +
        ".o365cs-base .ms-bgc-tp-h:hover," +
        ".o365cs-base .ms-bgc-tp-f:focus," +
        ".o365cs-base.ms-bgc-tp" +
        "{" +
        "    background-color: '[theme:themePrimary, default:#0078d7]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-tp," +
        ".o365cs-base .ms-bcl-tp-h:hover," +
        ".o365cs-base .ms-bcl-tp-f:focus" +
        "{" +
        "    border-color: '[theme:themePrimary, default:#0078d7]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-ts," +
        ".o365cs-base .ms-fcl-ts-h:hover," +
        ".o365cs-base .ms-fcl-ts-f:focus" +
        "{" +
        "    color: '[theme:themeSecondary, default:#2b88d8]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-ts," +
        ".o365cs-base .ms-bgc-ts-h:hover," +
        ".o365cs-base .ms-bgc-ts-f:focus" +
        "{" +
        "    background-color: '[theme:themeSecondary, default:#2b88d8]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-ts," +
        ".o365cs-base .ms-bcl-ts-h:hover," +
        ".o365cs-base .ms-bcl-ts-f:focus" +
        "{" +
        "    border-color: '[theme:themeSecondary, default:#2b88d8]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-tt," +
        ".o365cs-base .ms-fcl-tt-h:hover," +
        ".o365cs-base .ms-fcl-tt-f:focus" +
        "{" +
        "    color: '[theme:themeTertiary, default:#71afe5]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-tt," +
        ".o365cs-base .ms-bgc-tt-h:hover," +
        ".o365cs-base .ms-bgc-tt-f:focus" +
        "{" +
        "    background-color: '[theme:themeTertiary, default:#71afe5]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-tt," +
        ".o365cs-base .ms-bcl-tt-h:hover," +
        ".o365cs-base .ms-bcl-tt-f:focus" +
        "{" +
        "    border-color: '[theme:themeTertiary, default:#71afe5]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-tl," +
        ".o365cs-base .ms-fcl-tl-h:hover," +
        ".o365cs-base .ms-fcl-tl-f:focus" +
        "{" +
        "    color: '[theme:themeLight, default:#c7e0f4]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-tl," +
        ".o365cs-base .ms-bgc-tl-h:hover," +
        ".o365cs-base .ms-bgc-tl-f:focus" +
        "{" +
        "    background-color: '[theme:themeLight, default:#c7e0f4]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-tl," +
        ".o365cs-base .ms-bcl-tl-h:hover," +
        ".o365cs-base .ms-bcl-tl-f:focus" +
        "{" +
        "    border-color: '[theme:themeLight, default:#c7e0f4]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-tlr," +
        ".o365cs-base .ms-fcl-tlr-h:hover," +
        ".o365cs-base .ms-fcl-tlr-f:focus" +
        "{" +
        "    color: '[theme:themeLighter, default:#deecf9]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-tlr," +
        ".o365cs-base .ms-bgc-tlr-h:hover," +
        ".o365cs-base .ms-bgc-tlr-f:focus" +
        "{" +
        "    background-color: '[theme:themeLighter, default:#deecf9]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-tlr," +
        ".o365cs-base .ms-bcl-tlr-h:hover," +
        ".o365cs-base .ms-bcl-tlr-f:focus" +
        "{" +
        "    border-color: '[theme:themeLighter, default:#deecf9]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-tlra," +
        ".o365cs-base .ms-fcl-tlra-h:hover," +
        ".o365cs-base .ms-fcl-tlra-f:focus" +
        "{" +
        "    color: '[theme:themeLighterAlt, default:#eff6fc]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-tlra," +
        ".o365cs-base .ms-bgc-tlra-h:hover," +
        ".o365cs-base .ms-bgc-tlra-f:focus" +
        "{" +
        "    background-color: '[theme:themeLighterAlt, default:#eff6fc]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-tlra," +
        ".o365cs-base .ms-bcl-tlra-h:hover," +
        ".o365cs-base .ms-bcl-tlra-f:focus" +
        "{" +
        "    border-color: '[theme:themeLighterAlt, default:#eff6fc]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-w," +
        ".o365cs-base .ms-fcl-w-h:hover," +
        ".o365cs-base .ms-fcl-w-f:focus" +
        "{" +
        "    color: '[theme:white, default:#ffffff]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-w," +
        ".o365cs-base .ms-bgc-w-h:hover," +
        ".o365cs-base .ms-bgc-w-f:focus," +
        ".o365cs-base.ms-bgc-w" +
        "{" +
        "    background-color: '[theme:white, default:#ffffff]';" + // backgroundOverlay
        "}\n" +
        ".o365cs-base .ms-bcl-w," +
        ".o365cs-base .ms-bcl-w-h:hover," +
        ".o365cs-base .ms-bcl-w-f:focus" +
        "{" +
        "    border-color: '[theme:white, default:#ffffff]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-b," +
        ".o365cs-base .ms-fcl-b-h:hover," +
        ".o365cs-base .ms-fcl-b-f:focus" +
        "{" +
        "    color: '[theme:black, default:#000000]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-b.o365cs-nav-closeButton" + // Special case for button to close app launcher, since app launcher is not themed
        "{" +
        "    color: #000000;" +
        "}\n" +
        ".o365cs-base .ms-bgc-b," +
        ".o365cs-base .ms-bgc-b-h:hover," +
        ".o365cs-base .ms-bgc-b-f:focus," +
        ".o365cs-base.ms-bgc-b" +
        "{" +
        "    background-color: '[theme:black, default:#000000]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-b," +
        ".o365cs-base .ms-bcl-b-h:hover," +
        ".o365cs-base .ms-bcl-b-f:focus" +
        "{" +
        "    border-color: '[theme:black, default:#000000]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-nd," +
        ".o365cs-base .ms-fcl-nd-h:hover," +
        ".o365cs-base .ms-fcl-nd-f:focus" +
        "{" +
        "    color: '[theme:neutralDark, default:#212121]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-nd," +
        ".o365cs-base .ms-bgc-nd-h:hover," +
        ".o365cs-base .ms-bgc-nd-f:focus" +
        "{" +
        "    background-color: '[theme:neutralDark, default:#212121]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-nd," +
        ".o365cs-base .ms-bcl-nd-h:hover," +
        ".o365cs-base .ms-bcl-nd-f:focus" +
        "{" +
        "    border-color: '[theme:neutralDark, default:#212121]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-np," +
        ".o365cs-base .ms-fcl-np-h:hover," +
        ".o365cs-base .ms-fcl-np-f:focus" +
        "{" +
        "    color: '[theme:neutralPrimary, default:#333333]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-np," +
        ".o365cs-base .ms-bgc-np-h:hover," +
        ".o365cs-base .ms-bgc-np-f:focus" +
        "{" +
        "    background-color: '[theme:neutralPrimary, default:#333333]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-np," +
        ".o365cs-base .ms-bcl-np-h:hover," +
        ".o365cs-base .ms-bcl-np-f:focus" +
        "{" +
        "    border-color: '[theme:neutralPrimary, default:#333333]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-ns," +
        ".o365cs-base .ms-fcl-ns-h:hover," +
        ".o365cs-base .ms-fcl-ns-f:focus" +
        "{" +
        "    color: '[theme:neutralSecondary, default:#666666]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-ns.o365cs-nav-moduleLabel" + // Special case for the module label in the unthemed app launcher
        "{" +
        "    color: #666666;" +
        "}\n" +
        ".o365cs-base .ms-bgc-ns," +
        ".o365cs-base .ms-bgc-ns-h:hover," +
        ".o365cs-base .ms-bgc-ns-f:focus" +
        "{" +
        "    background-color: '[theme:neutralSecondary, default:#666666]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-ns," +
        ".o365cs-base .ms-bcl-ns-h:hover," +
        ".o365cs-base .ms-bcl-ns-f:focus" +
        "{" +
        "    border-color: '[theme:neutralSecondary, default:#666666]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-nsa," +
        ".o365cs-base .ms-fcl-nsa-h:hover," +
        ".o365cs-base .ms-fcl-nsa-f:focus" +
        "{" +
        "    color: '[theme:neutralSecondaryAlt, default:#767676]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-nsa," +
        ".o365cs-base .ms-bgc-nsa-h:hover," +
        ".o365cs-base .ms-bgc-nsa-f:focus" +
        "{" +
        "    background-color: '[theme:neutralSecondaryAlt, default:#767676]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-nsa," +
        ".o365cs-base .ms-bcl-nsa-h:hover," +
        ".o365cs-base .ms-bcl-nsa-f:focus" +
        "{" +
        "    border-color: '[theme:neutralSecondaryAlt, default:#767676]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-nt," +
        ".o365cs-base .ms-fcl-nt-h:hover," +
        ".o365cs-base .ms-fcl-nt-f:focus" +
        "{" +
        "    color: '[theme:neutralTertiary, default:#a6a6a6]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-nt," +
        ".o365cs-base .ms-bgc-nt-h:hover," +
        ".o365cs-base .ms-bgc-nt-f:focus" +
        "{" +
        "    background-color: '[theme:neutralTertiary, default:#a6a6a6]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-nt," +
        ".o365cs-base .ms-bcl-nt-h:hover," +
        ".o365cs-base .ms-bcl-nt-f:focus" +
        "{" +
        "    border-color: '[theme:neutralTertiary, default:#a6a6a6]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-nta," +
        ".o365cs-base .ms-fcl-nta-h:hover," +
        ".o365cs-base .ms-fcl-nta-f:focus" +
        "{" +
        "    color: '[theme:neutralTertiaryAlt, default:#c8c8c8]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-nta," +
        ".o365cs-base .ms-bgc-nta-h:hover," +
        ".o365cs-base .ms-bgc-nta-f:focus" +
        "{" +
        "    background-color: '[theme:neutralTertiaryAlt, default:#c8c8c8]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-nta," +
        ".o365cs-base .ms-bcl-nta-h:hover," +
        ".o365cs-base .ms-bcl-nta-f:focus" +
        "{" +
        "    border-color: '[theme:neutralTertiaryAlt, default:#c8c8c8]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-nl," +
        ".o365cs-base .ms-fcl-nl-h:hover," +
        ".o365cs-base .ms-fcl-nl-f:focus" +
        "{" +
        "    color: '[theme:neutralLight, default:#eaeaea]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-nl," +
        ".o365cs-base .ms-bgc-nl-h:hover," +
        ".o365cs-base .ms-bgc-nl-f:focus" +
        "{" +
        "    background-color: '[theme:neutralLight, default:#eaeaea]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-nl," +
        ".o365cs-base .ms-bcl-nl-h:hover," +
        ".o365cs-base .ms-bcl-nl-f:focus" +
        "{" +
        "    border-color: '[theme:neutralLight, default:#eaeaea]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-nlr," +
        ".o365cs-base .ms-fcl-nlr-h:hover," +
        ".o365cs-base .ms-fcl-nlr-f:focus" +
        "{" +
        "    color: '[theme:neutralLighter, default:#f4f4f4]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-nlr," +
        ".o365cs-base .ms-bgc-nlr-h:hover," +
        ".o365cs-base .ms-bgc-nlr-f:focus," +
        ".o365cs-base.ms-bgc-nlr" +
        "{" +
        "    background-color: '[theme:neutralLighter, default:#f4f4f4]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-nlr," +
        ".o365cs-base .ms-bcl-nlr-h:hover," +
        ".o365cs-base .ms-bcl-nlr-f:focus" +
        "{" +
        "    border-color: '[theme:neutralLighter, default:#f4f4f4]';" +
        "}\n" +
        ".o365cs-base .ms-fcl-nlra," +
        ".o365cs-base .ms-fcl-nlra-h:hover," +
        ".o365cs-base .ms-fcl-nlra-f:focus" +
        "{" +
        "    color: '[theme:neutralLighterAlt, default:#f8f8f8]';" +
        "}\n" +
        ".o365cs-base .ms-bgc-nlra," +
        ".o365cs-base .ms-bgc-nlra-h:hover," +
        ".o365cs-base .ms-bgc-nlra-f:focus," +
        ".o365cs-base.ms-bgc-nlra" +
        "{" +
        "    background-color: '[theme:neutralLighterAlt, default:#f8f8f8]';" +
        "}\n" +
        ".o365cs-base .ms-bcl-nlra," +
        ".o365cs-base .ms-bcl-nlra-h:hover," +
        ".o365cs-base .ms-bcl-nlra-f:focus" +
        "{" +
        "    border-color: '[theme:neutralLighterAlt, default:#f8f8f8]';" +
        "}\n" +
        ".o365cs-base .o365cs-topnavLinkBackground-2" +
        "{" +
        "    background-color: transparent;" +
        "}\n" +
        ".o365cs-base .o365cs-topnavText," +
        ".o365cs-base .o365cs-topnavText:hover" +
        "{" +
        "    color: '[theme:suiteBarText, default:#ffffff]';" + // $SuiteBarText
        "}\n" +
        ".o365cs-base .o365cs-appLauncherBackground" +
        "{" +
        "    background-color: '[theme:themeDarker, default:#104a7d]';" +
        "}\n" +
        ".o365cs-nav-header16 .o365cs-navMenuButton" +
        "{" +
        "    color: '[theme:white, default:#ffffff]';" + // Should this be hardcoded to #ffffff?
        "}\n" +
        ".o365cs-base .o365cs-navMenuButton" +
        "{" +
        "    color: '[theme:suiteBarText, default:#ffffff]';" + // $SuiteBarText
        "}\n" +
        ".o365cs-base.o365cs-topnavBGImage" +
        "{" +
        "    background-position: center top;" +
        "    background-repeat: repeat-x;" +
        "    background-image: none;" + // $ThemeTopnavBackgroundImage
        "}\n" +
        ".o365cs-base.o365cs-topnavBGColor-2" +
        "{" +
        "    background-color: '[theme:suiteBarBackground, default:#000000]';" + // $ThemeTopnavBackgroundColor
        "}\n";
    load_themed_styles_1.loadStyles(strCss);
}
exports.loadFallbackShellThemableCss = loadFallbackShellThemableCss;


/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_73__;

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_74__;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * This file exports members of ODSP-utilities that are directly used by telemetry. There is a second,
 *  "extended" odsp-utilities package in odsp-utilities-telemetry.ts
 *
 * IMPORTANT: When editing this file, make sure you make the corresponding edit to OdspUtilitiesWorkaroundLoader.ts
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Case 1: export multiple functions from the file.
// Case 2: export a named class from the file.
var EventBase_1 = __webpack_require__(25);
exports.addEventProps = EventBase_1.addEventProps;
exports.ClonedEventType = EventBase_1.ClonedEventType;
exports.ValidationErrorType = EventBase_1.ValidationErrorType;
exports.AccountType = EventBase_1.AccountType;
exports.EventBase = EventBase_1.EventBase;
var Engagement_event_1 = __webpack_require__(17);
exports.Engagement = Engagement_event_1.Engagement;
var Nav_event_1 = __webpack_require__(76);
exports.Nav = Nav_event_1.Nav;
var PLTHttpRequest_event_1 = __webpack_require__(77);
exports.PLTHttpRequest = PLTHttpRequest_event_1.PLTHttpRequest;
var Qos_event_1 = __webpack_require__(18);
exports.Qos = Qos_event_1.Qos;
var ResultTypeEnum_1 = __webpack_require__(79);
exports.ResultTypeEnum = ResultTypeEnum_1.ResultTypeEnum;
// Case 3: export a class as default from the file.
var APICallPerformanceData_1 = __webpack_require__(80);
exports.APICallPerformanceData = APICallPerformanceData_1.default;
var AriaLoggerCore_1 = __webpack_require__(54);
exports.AriaLoggerCore = AriaLoggerCore_1.default;
var Beacon_1 = __webpack_require__(92);
exports.Beacon = Beacon_1.default;
var BeaconCache_1 = __webpack_require__(58);
exports.BeaconCache = BeaconCache_1.default;
var ControlPerformanceData_1 = __webpack_require__(103);
exports.ControlPerformanceData = ControlPerformanceData_1.default;
var CorrelationVector_1 = __webpack_require__(104);
exports.CorrelationVector = CorrelationVector_1.default;
var ErrorHelper_1 = __webpack_require__(4);
exports.ErrorHelper = ErrorHelper_1.default;
var PageTransitionType_1 = __webpack_require__(52);
exports.PageTransitionType = PageTransitionType_1.default;
var RUMOneLogger_1 = __webpack_require__(29);
exports.RumOneLogger = RUMOneLogger_1.default;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventBase_1 = __webpack_require__(5);
exports.Nav = SingleEventBase_1.createSingleEvent({
    eventName: 'Nav,',
    shortEventName: 'Nav'
}, {
    viewParams: 4 /* Object */,
    url: 1 /* String */
});
exports.default = exports.Nav;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventBase_1 = __webpack_require__(5);
exports.PLTHttpRequest = SingleEventBase_1.createSingleEvent({
    eventName: 'PLTHttpRequest,',
    shortEventName: 'PLTHttpRequest',
    samplingFeature: { ODB: true, ODC: 'PLTHttpRequestSampling', Fallback: false }
}, {
    startTime: 2 /* Number */,
    url: 1 /* String */,
    duration: 2 /* Number */
});
exports.default = exports.PLTHttpRequest;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CircularBuffer = /** @class */ (function () {
    function CircularBuffer(size) {
        if (size <= 0) {
            throw new Error('Size must be positive');
        }
        this._size = size;
        this._buffer = new Array(size);
        this._length = 0;
        this._head = -1;
    }
    CircularBuffer.prototype.push = function (item) {
        if (this._length < this._size) {
            this._length++;
        }
        this._head++;
        if (this._head === this._size) {
            this._head = 0;
        }
        this._buffer[this._head] = item;
    };
    CircularBuffer.prototype.popOldest = function () {
        if (this._length === 0) {
            return null;
        }
        var tail = (this._head - this._length + 1 + this._size) % this._size;
        this._length--;
        return this._buffer[tail];
    };
    return CircularBuffer;
}());
exports.CircularBuffer = CircularBuffer;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
tslib_1.__exportStar(__webpack_require__(19), exports);


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var RUMOneLogger_1 = __webpack_require__(29);
exports.default = RUMOneLogger_1.APICallPerformanceData;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Use PlatformDetection to evaluate which user experience makes sense for the user's
 * platform. NOTE: This class is NOT COMPLETE! Meaning not all values are parsed out of
 * the user agent. If something is missing that you need, add it and add unit tests.
 * WARNING: Avoid using browser checks when you can use detection techniques for caps checking.
 */
var PlatformDetection = /** @class */ (function () {
    function PlatformDetection(inputAgent) {
        if (!inputAgent) {
            if (typeof window !== 'undefined') {
                inputAgent = (window && window.navigator && navigator.userAgent);
            }
            else if (typeof self !== 'undefined') {
                inputAgent = (self && self.navigator && navigator.userAgent);
            }
            inputAgent = inputAgent || '';
        }
        var userAgent = inputAgent;
        var agent = inputAgent.toLowerCase();
        // We want to figure out which ONE browser the user is most likely on.
        // The order of the checks is important so we're not deceived by (for example)
        // Chrome saying that it's Safari.
        // (Each regular expression captures the version number so we can parse it later.)
        var match;
        var isIE;
        var isIE9;
        var isEdge;
        var isFirefox;
        var isChrome;
        var isSafari;
        var isElectron;
        function testBrowserVersion(pattern) {
            return match = RegExp(pattern + "(\\d+)([\\d.]*)").exec(agent);
        }
        if (testBrowserVersion('msie ')) {
            // IE <= 10 has something like 'MSIE 9' in the user agent.
            // This is also what newer versions do in compatibility mode.
            isIE = true;
            isIE9 = !!match && match[1] === '9';
        }
        else if (testBrowserVersion('trident.*rv:')) {
            // This is IE 11. Sample user agent contains:
            // Trident/7.0; other stuff... rv:11.0
            isIE = true;
        }
        else if (testBrowserVersion('edge/')) {
            // This is Edge (it pretends to be Chrome and Safari).
            isEdge = true;
        }
        else if (testBrowserVersion('fxios|firefox/')) {
            isFirefox = true;
        }
        else if (testBrowserVersion('(?:chrome|crios)/')) {
            // Note: lots of random browsers say they're Chrome and will end up in this bucket
            isChrome = true;
        }
        else if (/safari\/(\d+)/.test(agent)) {
            isSafari = true;
            testBrowserVersion('version/');
        }
        if (RegExp('electron/' + "(\\d+)([\\d.]*)").exec(agent)) {
            isElectron = true;
        }
        // Some other browser categories:
        //   IE Mobile: /iemobile\/(\d+)/
        //   IE Mobile in desktop mode: contains WPDesktop; get version from Trident version
        //   Opera (currently goes into Chrome bucket): /opr\/(\d+)/
        // Parse the captured version number for user's browser.
        var browserMajor = match && parseInt(match[1], 10) || 0;
        var browserMinor = match && match[2] && match[2].substr(1) || '0';
        // Parse device which gives hints about os / mobile state.
        // Windows Phone IE sometimes pretends to be Android, so explicitly check for Windows Phone first.
        // (wpdesktop is used by Windows Phone in desktop mode.)
        var isWinPhone = /windows phone|wpdesktop/.test(agent);
        var deviceMatch = isWinPhone || /ipad|iphone|ipod|android/.exec(agent);
        var device = deviceMatch && deviceMatch[0];
        var isAndroid = device === 'android';
        var isIPad = device === 'ipad';
        var isIOS = !!device && !isAndroid;
        var isMac = !deviceMatch && agent.indexOf('macintosh') > -1;
        var isWindows = !deviceMatch && agent.indexOf('windows nt') > -1;
        // If user agent string has SharePointDesktop string , its SharePoint HWA
        // Lower case check here hence string compare with sharepointdesktop
        var isSharePointDesktopApp = agent.indexOf('sharepointdesktop') > -1;
        // Other operating systems:
        //   Chrome OS: /cros/
        //   Linux: /linux/ (Android can also say it's Linux, so check for Android first)
        // WARNING: Avoid using browser checks when you can use detection techniques for caps checking.
        var isUnlimitedStyleSheetsSupported = false;
        var isWebDavSupported = false;
        var isFolderUploadSupported = false;
        var isHtml5FileUploadSupported = false;
        if (((typeof window !== 'undefined') && window.document) || ((typeof self !== 'undefined') && self.document)) {
            /**
             * Checks to see if styleSheet exists as a property off of a style element.
             * This will determine if style registration should be done via cssText (<= IE9) or not
             */
            var emptyStyle = document.createElement('style');
            emptyStyle.type = 'text/css';
            isUnlimitedStyleSheetsSupported = !emptyStyle.styleSheet;
            isWebDavSupported = 'addBehavior' in document.createElement('div');
            var input = document.createElement('input');
            input.type = 'file';
            var file = window.File;
            var fileProto = file && file.prototype;
            isHtml5FileUploadSupported = !!(fileProto && (fileProto.slice || fileProto.mozSlice || fileProto.webkitSlice));
            isFolderUploadSupported = ('webkitdirectory' in input) && !isElectron;
        }
        var osVersionMatch = /[\s\(](os|os x|windows (?:phone|nt)|android) ([\d._]+)/.exec(agent);
        return {
            // Hosted Apps identification
            isSharePointDesktopApp: !!isSharePointDesktopApp,
            // Browser identification
            isChrome: !!isChrome,
            isEdge: !!isEdge,
            isFirefox: !!isFirefox,
            isIE: !!isIE,
            isIE9: !!isIE9,
            isSafari: !!isSafari,
            isElectron: !!isElectron,
            browserName: isIE ? 'IE' : isEdge ? 'Edge' : isChrome ? 'Chrome' : isFirefox ? 'Firefox' : isSafari ? 'Safari' : 'NA',
            browserMajor: browserMajor,
            browserMinor: browserMinor,
            // OS Identification
            isAndroid: isAndroid,
            isIOS: isIOS,
            isMac: isMac,
            isWindows: isWindows,
            isWinPhone: isWinPhone,
            osVersion: osVersionMatch ? osVersionMatch[2] : 'NA',
            osName: isWindows ? 'Windows' : isWinPhone ? 'Windows Phone' : isMac ? 'OSX' : isIOS ? 'IOS' : isAndroid ? 'Android' : 'NA',
            isWindows81: !deviceMatch && /windows (?:8\.1|nt 6\.3)/.test(agent),
            isWindows10: !deviceMatch && agent.indexOf('windows nt 10') > -1,
            isWindows7: !deviceMatch && agent.indexOf('windows nt 6.1') > -1,
            // Device identification
            isMobile: !!deviceMatch,
            isIPad: isIPad,
            // Capabilities
            areCSS3TransitionsSupported: !isIE || browserMajor > 9,
            areTouchEventsSupported: ((typeof window !== 'undefined') ? 'ontouchstart' in window
                : ((typeof self !== 'undefined') ? 'ontouchstart' in self
                    : false)),
            isFolderUploadSupported: isFolderUploadSupported,
            isHtml5FileUploadSupported: isHtml5FileUploadSupported,
            isRetinaSupported: ((typeof window !== 'undefined') ? window.devicePixelRatio > 1
                : ((typeof self !== 'undefined') && self.devicePixelRatio ? self.devicePixelRatio > 1
                    : false)),
            isUnlimitedStyleSheetsSupported: isUnlimitedStyleSheetsSupported,
            isWebDavSupported: isWebDavSupported,
            // Raw user agent
            userAgent: userAgent
        };
    }
    return PlatformDetection;
}());
exports.PlatformDetection = PlatformDetection;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// OneDrive:IgnoreCodeCoverage
var performance = window.performance;
var HighResolutionTimingSupported = !!performance && typeof performance.mark === 'function' &&
    typeof performance.clearMarks === 'function' &&
    typeof performance.now === 'function';
exports.HighResolutionTimingSupported = HighResolutionTimingSupported;
exports.MARKER_PREFIX = "EUPL.";
var _markCount = 0;
var _perfMarks = window['_perfMarks'] = window['_perfMarks'] || []; // used for browsers do not support native performance.mark
function mark(name, limit) {
    'use strict';
    var markName = name.lastIndexOf(exports.MARKER_PREFIX, 0) === 0 ? name : exports.MARKER_PREFIX + name;
    if (limit === null || limit === undefined || _markCount < limit) {
        if (HighResolutionTimingSupported) {
            performance.mark(markName);
        }
        else { // this is for browser does not support native performance.mark
            _perfMarks.push({
                name: markName,
                startTime: Date.now()
            });
        }
        _markCount++;
    }
}
exports.mark = mark;
function getMarkerTime(name) {
    'use strict';
    var markName = name.lastIndexOf(exports.MARKER_PREFIX, 0) === 0 ? name : exports.MARKER_PREFIX + name;
    if (HighResolutionTimingSupported) {
        var mark_1 = performance.getEntriesByName(markName);
        return mark_1 && mark_1.length > 0 ? Math.round(mark_1[0].startTime) : NaN;
    }
    else {
        var mark_2 = _perfMarks.filter(function (mark) { return mark.name === markName; })[0];
        return mark_2 && mark_2.startTime;
    }
}
exports.getMarkerTime = getMarkerTime;
function clearMarks(names) {
    'use strict';
    var markNames = [];
    if (names) {
        markNames = names.map(function (name) {
            return name.lastIndexOf(exports.MARKER_PREFIX, 0) === 0 ? name : exports.MARKER_PREFIX + name;
        });
    }
    if (HighResolutionTimingSupported) {
        performance.getEntriesByType("mark").filter(function (mark) {
            if (markNames.length > 0) {
                return markNames.indexOf(mark.name) >= 0;
            }
            return mark.name.lastIndexOf(exports.MARKER_PREFIX, 0) === 0;
        }).forEach(function (mark) {
            performance.clearMarks(mark.name);
        });
    }
    else {
        _perfMarks = [];
    }
}
exports.clearMarks = clearMarks;
function getAllMarks() {
    'use strict';
    if (HighResolutionTimingSupported) {
        return performance.getEntriesByType("mark").filter(function (mark) {
            return mark.name.lastIndexOf(exports.MARKER_PREFIX, 0) === 0;
        });
    }
    else {
        return _perfMarks;
    }
}
exports.getAllMarks = getAllMarks;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:CoverageThreshold(75)
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
tslib_1.__exportStar(__webpack_require__(49), exports);


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var XHR_1 = __webpack_require__(55);
var ErrorHelper_1 = __webpack_require__(4);
var DataCompletenessInfo = /** @class */ (function () {
    function DataCompletenessInfo(context, isSuccess, statusCode, timestamp, events) {
        this._endpointUrl = context.callbackEndpoint.authority + context.callbackEndpoint.path;
        var eventSummary = {};
        if (events) {
            for (var e = 0; e < events.length; ++e) {
                eventSummary[events[e].EventType] = eventSummary[events[e].EventType] + 1 || 1;
            }
        }
        var completenessDataObj = {
            'TelemetryTenantId': context.telemetryTenantToken.substring(0, 32),
            'AppVersion': context.appVersion,
            'EventType': isSuccess,
            'StatusCode': statusCode,
            'EventCount': events ? events.length : 0,
            'Timestamp': timestamp,
            'Environment': context.environment || "",
            'DatapointSchemaVersion': '1.0',
            'TelemetrySource': 'Aria',
            'EventSummary': eventSummary,
            'Workload': context.workload || "",
            'FarmLabel': context.farmLabel || ""
        };
        this._dataCompletenessJson = JSON.stringify(completenessDataObj);
    }
    Object.defineProperty(DataCompletenessInfo.prototype, "endpointUrl", {
        get: function () {
            return this._endpointUrl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataCompletenessInfo.prototype, "dataCompletenessJson", {
        get: function () {
            return this._dataCompletenessJson;
        },
        enumerable: true,
        configurable: true
    });
    DataCompletenessInfo.prototype.send = function () {
        var xhr = new XHR_1.default({
            method: 'POST',
            url: this._endpointUrl,
            json: this._dataCompletenessJson,
            requestTimeoutInMS: 1000
        });
        xhr.start(function (xhr, status) {
            // success, no op
        }, function (xhr, statusCode, timeout) {
            if (true) {
                // Display errors if the completeness info couldn't be sent
                ErrorHelper_1.default.log(new Error("DataCompletenessInfo failed to be sent with status code " + statusCode));
            }
        });
    };
    return DataCompletenessInfo;
}());
exports.DataCompletenessInfo = DataCompletenessInfo;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Deeply compares the objects by recursively comparing all their properties,
 * objects with circular references are not supported, prototype members and functions are ignored
 */
function deepCompare(objA, objB, equivalent) {
    // keep track of references that have been compared to find circular references while walking down either object
    var refsComparedA = [];
    var refsComparedB = [];
    var compare = equivalent ? equivalent : function (a, b) { return (a === b); };
    function equals(a, b) {
        // try a simple equality test first
        if (a === b) {
            return true;
        }
        if ((a === null) || (b === null)) {
            return false;
        }
        // if both are objects, then further comparison is required
        if ((typeof (a) === 'object') && (typeof (b) === 'object')) {
            // perform deep comparison over object's properties
            var aKeys = Object.keys(a).sort();
            var bKeys_1 = Object.keys(b).sort();
            // does one object have a different number of properties?
            if (aKeys.length !== bKeys_1.length) {
                return false;
            }
            var keysMatch = aKeys.every(function (key, index) {
                // key names should match
                if (key !== bKeys_1[index]) {
                    return false;
                }
                else if (typeof (a[key]) === 'function' || typeof (b[key]) === 'function') {
                    // skip comparison of function properties
                    return true;
                    // @ts-ignore
                }
                else if (!compare(a[key], b[key])) {
                    // if this is an Object then recursive testing is needed on its properties
                    if (typeof a[key] === 'object') {
                        // if this property was encountered before then we're going in circles, give up
                        // @ts-ignore
                        if (refsComparedA.indexOf(a[key]) !== -1) {
                            throw new Error("Cannot perform DeepCompare() because a circular reference was encountered, object: " + a + ", property: " + key);
                        }
                        // @ts-ignore
                        refsComparedA.push(a[key]);
                        // @ts-ignore
                        if (refsComparedB.indexOf(b[key]) !== -1) {
                            throw new Error("Cannot perform DeepCompare() because a circular reference was encountered, object: " + b + ", property: " + key);
                        }
                        // @ts-ignore
                        refsComparedB.push(b[key]);
                        // recursive compare object's properties
                        if (!equals(a[key], b[key])) {
                            return false;
                        }
                        refsComparedA.pop();
                        refsComparedB.pop();
                        return true;
                    }
                    else {
                        // properties don't match
                        return false;
                    }
                }
                else {
                    return true;
                }
            });
            if (!keysMatch) {
                return false;
            }
        }
        else {
            // parameters aren't equal, and at least one is not an Object
            return false;
        }
        // everything is equal
        return true;
    }
    return equals(objA, objB);
}
exports.deepCompare = deepCompare;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_resource_path_1 = __webpack_require__(87);
exports.SimpleUri = sp_resource_path_1.SPResourcePath;
exports.UriFormat = sp_resource_path_1.SPResourcePathFormat;
exports.default = sp_resource_path_1.SPResourcePath;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SPResourcePath_1 = __webpack_require__(88);
exports.SPResourcePath = SPResourcePath_1.SPResourcePath;
exports.SPResourcePathFormat = SPResourcePath_1.SPResourcePathFormat;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @public
 */
var SPResourcePathFormat;
(function (SPResourcePathFormat) {
    SPResourcePathFormat[SPResourcePathFormat["absolute"] = 0] = "absolute";
    SPResourcePathFormat[SPResourcePathFormat["relative"] = 1] = "relative";
    SPResourcePathFormat[SPResourcePathFormat["serverRelative"] = 2] = "serverRelative";
})(SPResourcePathFormat = exports.SPResourcePathFormat || (exports.SPResourcePathFormat = {}));
/**
 * Simplified implementation of a URI parser which does not attempt decoding of segments,
 * handling of query strings, or separation of the fragment. Intended for use on SharePoint
 * Resource Paths or other URL-like entities which may not actually conform to the URL
 * specification, but may be used for simple transformations of URLs.
 *
 * This class makes several assumptions about the format of input URLs:
 * - Absolute URLs begin with '<scheme>://<host>'
 * - Relative URLs being with '/'
 * - URLs never have a trailing '/'
 *
 * @public
 */
var SPResourcePath = /** @class */ (function () {
    /**
     * Creates an instance of SPResourcePath.
     *
     * @param value - A string representing a well-formed, decoded SharePoint resource path.
     */
    function SPResourcePath(value) {
        if (value === void 0) { value = ''; }
        var rootDelimeter = '//';
        var indexOfRootDelimeter = value.indexOf(rootDelimeter);
        var indexOfPathDelimeter = value.indexOf('/');
        // The root delimeter is the first instance of '//', unless preceded by a lone '/'
        var endIndexOfRootDelimeter = indexOfRootDelimeter > -1 && indexOfRootDelimeter <= indexOfPathDelimeter ?
            indexOfRootDelimeter + rootDelimeter.length :
            -1;
        var authority = getAuthority(value, endIndexOfRootDelimeter);
        var domain = authority && authority.slice(endIndexOfRootDelimeter);
        // By definition, everything after the authority is the path
        var path = value.slice(authority.length);
        var format = authority ?
            SPResourcePathFormat.absolute :
            path[0] === '/' ?
                SPResourcePathFormat.serverRelative :
                SPResourcePathFormat.relative;
        var segments = path.split('/');
        this.authority = authority;
        this.domain = domain;
        this.format = format;
        this.path = path;
        this.segments = segments;
        this.value = value;
    }
    return SPResourcePath;
}());
exports.SPResourcePath = SPResourcePath;
function getAuthority(value, endIndexOfRootDelimeter) {
    if (endIndexOfRootDelimeter > -1) {
        var indexOfNextSegment = value.indexOf('/', endIndexOfRootDelimeter);
        if (indexOfNextSegment > -1) {
            return value.slice(0, indexOfNextSegment);
        }
        else {
            return value;
        }
    }
    else {
        return '';
    }
}


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var EventBase_1 = __webpack_require__(11);
var AriaEventBuilder_1 = __webpack_require__(90);
var ErrorHelper = __webpack_require__(20);
var index_1 = __webpack_require__(33);
/**
 * Telemetry handler for reporting events to Aria.
 * This handler ensures that events logged to Aria are well-formed and supplied with baseline required metadata fields.
 *
 * Host applications should generally use a class derived from this class, such as WebSharedAriaTelemtryHandler,
 * which supply default metadata extracted from context.
 */
var AriaTelemetryHandler = /** @class */ (function () {
    function AriaTelemetryHandler(params) {
        var _a = params.logStartEvents, logStartEvents = _a === void 0 ? true : _a, _b = params.context, context = _b === void 0 ? {} : _b;
        this._ariaLoader = params.ariaLoader;
        this._logStartEvents = logStartEvents;
        this._disableCookies = params.disableCookies;
        this._tenantToken = params.tenantToken;
        this._ariaQosParams = params.ariaQos;
        this._ariaOfflineCacheParams = params.offlineCache;
        this._context = context;
        this._logConfiguration = params.ariaLogConfiguration;
    }
    AriaTelemetryHandler.prototype.attach = function (manager) {
        var _this = this;
        var isDetached = false;
        var logHandler;
        this._getAria().then(function (aria) {
            if (isDetached) {
                return;
            }
            logHandler = _this._createLogHandler(aria);
            manager.addLogHandler(logHandler).forEach(logHandler);
        });
        return function () {
            isDetached = true;
            if (logHandler) {
                manager.removeLogHandler(logHandler);
            }
        };
    };
    AriaTelemetryHandler.prototype._getAria = function () {
        var _this = this;
        var loadAria = this._ariaLoader().then(function (aria) {
            _this._initializeLogManager(aria);
            return aria;
        });
        this._getAria = function () { return loadAria; };
        return loadAria;
    };
    AriaTelemetryHandler.prototype._createLogHandler = function (aria) {
        var _this = this;
        var logger = this._createLogger(aria);
        var ariaQosParams = this._ariaQosParams;
        return function (event) {
            // Try/catch individual events so that one bad event doesn't cause the rest to fail to get logged
            try {
                if (event.enabled && (event.eventType !== EventBase_1.ClonedEventType.Start || _this._logStartEvents) &&
                    !(ariaQosParams && ariaQosParams.isQosEvent(event))) {
                    var eventProperties = AriaEventBuilder_1.buildAriaEvent(aria, event);
                    logger.logEvent(eventProperties);
                }
            }
            catch (exception) {
                var error = void 0;
                if (exception instanceof aria.Exception) {
                    error = new Error("Aria error: " + exception.toString());
                }
                if (!exception || !exception.handled) {
                    // Only log the exception if it was not already logged before
                    ErrorHelper.log(error || exception);
                }
            }
        };
    };
    AriaTelemetryHandler.prototype._initializeLogManager = function (aria) {
        var _this = this;
        var ariaOfflineCacheParams = this._ariaOfflineCacheParams;
        if (!aria.LogManager.isInitialized()) {
            aria.LogManager.initialize(this._tenantToken, tslib_1.__assign({ disableCookies: this._disableCookies }, (ariaOfflineCacheParams ? {
                browserOverrides: {
                    onGetData: ariaOfflineCacheParams.getData,
                    onSaveData: ariaOfflineCacheParams.saveData
                }
            } : {}), (this._logConfiguration || {})));
            if (typeof window !== 'undefined' && typeof window.addEventListener === 'function') {
                window.addEventListener('beforeunload', function (ev) {
                    aria.LogManager.flush();
                });
            }
        }
        var ariaQosParams = this._ariaQosParams;
        if (ariaQosParams) {
            aria.LogManager.addCallbackListener(function (callbackType, statusCode, tenantToken, events) {
                if (tenantToken !== _this._tenantToken) {
                    return;
                }
                ariaQosParams.reportQos({
                    result: callbackType,
                    statusCode: statusCode,
                    events: events
                });
            });
        }
    };
    AriaTelemetryHandler.prototype._createLogger = function (aria) {
        var logger = new aria.Logger(this._tenantToken);
        var context = this._context;
        var session = context.Session, version = context.Version, osName = context.OSName, osVersion = context.OSVersion, market = context.Market, userId = context.UserId, manifest = context.Manifest, otherContext = tslib_1.__rest(context, ["Session", "Version", "OSName", "OSVersion", "Market", "UserId", "Manifest"]);
        var semanticContext = logger.getSemanticContext();
        if (session) {
            logger.setContext('AppInfo.Session', session);
        }
        if (manifest) {
            logger.setContext('AppInfo.Manifest', manifest);
        }
        if (version) {
            semanticContext.setAppVersion(version);
        }
        semanticContext.setUserLanguage(market || '');
        if (userId) {
            semanticContext.setUserId(userId);
        }
        if (osName) {
            semanticContext.setDeviceOsName(osName);
        }
        if (osVersion) {
            semanticContext.setDeviceOsVersion(osVersion);
        }
        for (var key in otherContext) {
            if (Object.prototype.hasOwnProperty.call(otherContext, key)) {
                var value = otherContext[key];
                if (value === undefined || value === null) {
                    continue;
                }
                var finalKey = index_1.capitalize(key);
                logger.setContext(finalKey, otherContext[key]);
            }
        }
        return logger;
    };
    return AriaTelemetryHandler;
}());
exports.AriaTelemetryHandler = AriaTelemetryHandler;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var EventBase_1 = __webpack_require__(11);
var index_1 = __webpack_require__(33);
var ErrorHelper = __webpack_require__(20);
/**
 * Receives an event produced by the telemetry system and extracts and formats the data suitable
 * for logging to Aria.
 */
function getAriaEventInfo(event) {
    var e_1, _a;
    var values = {
        'CorrelationVector': event.vector.toString(),
        'ValidationErrors': event.validationErrors,
        'WebLog_FullName': event.eventName,
        'WebLog_EventType': EventBase_1.ClonedEventType[event.eventType]
    };
    if (event.eventType === EventBase_1.ClonedEventType.End) {
        values.Duration = event.endTime - event.startTime;
    }
    var names = event.eventName.split(',');
    try {
        for (var names_1 = tslib_1.__values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {
            var name_1 = names_1_1.value;
            if (name_1) {
                values["WebLog_Type_" + name_1] = 1;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var data = event.data, context = event.context;
    if (context) {
        for (var key in context) {
            if (Object.prototype.hasOwnProperty.call(context, key)) {
                var value = context[key];
                if (value === undefined || value === null) {
                    continue;
                }
                var loggingName = index_1.capitalize(key);
                values[loggingName] = value;
            }
        }
    }
    if (data) {
        for (var field in data) {
            if (Object.prototype.hasOwnProperty.call(data, field)) {
                var value = data[field];
                if (value === undefined || value === null) {
                    continue;
                }
                var propertyMetadata = event.metadata[field];
                if (propertyMetadata) {
                    var loggingName = propertyMetadata.isPrefixingDisabled ?
                        index_1.capitalize(field) :
                        index_1.capitalize(propertyMetadata.definedInName) + "_" + field;
                    var type = propertyMetadata.type;
                    if (type === 4 /* Object */) {
                        for (var subField in value) {
                            if (value[subField] !== undefined) {
                                values[loggingName + "_" + subField.replace('.', '_')] = value[subField];
                            }
                        }
                    }
                    else {
                        values[loggingName] = type === 6 /* Enum */ ? propertyMetadata.typeRef[value] : value;
                    }
                }
            }
        }
    }
    return {
        name: event.isEventTypePrefixingDisabled ? names[names.length - 2] : "ev_" + names[names.length - 2],
        values: values
    };
}
exports.getAriaEventInfo = getAriaEventInfo;
/**
 * Given an Aria implementation, builds an event suitable for logging.
 */
function buildAriaEvent(ariaTelemetry, event) {
    var _a = getAriaEventInfo(event), name = _a.name, values = _a.values;
    var eventProperties = new ariaTelemetry.EventProperties();
    eventProperties.name = name;
    setProperties(ariaTelemetry, eventProperties, values);
    return eventProperties;
}
exports.buildAriaEvent = buildAriaEvent;
function setProperties(ariaTelemetry, properties, values) {
    // We are getting a lot of errorCode 3 aria errors complaining about invalid property keys
    // In order to fix the problem we need to know what the problematic keys are
    var lastKey;
    try {
        for (var key in values) {
            if (Object.prototype.hasOwnProperty.call(values, key)) {
                lastKey = key;
                properties.setProperty(key, values[key]);
            }
        }
    }
    catch (exception) {
        var errorCode = void 0;
        var error = void 0;
        if (exception instanceof ariaTelemetry.Exception) {
            errorCode = exception.ErrorCode();
            error = new Error("Aria error: " + exception.toString());
        }
        if (error) {
            // If it is an aria error that is thrown then log it with the error code and the key we tried to set
            exception.handled = true;
            ErrorHelper.logError(error, {
                errorCode: errorCode,
                propertyKey: lastKey
            });
        }
        // Regardless of what kind of error it was, rethrow the error so we don't try to log the event
        throw exception;
    }
}


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GuidModule = __webpack_require__(45);
var Guid = GuidModule;
exports.default = Guid;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var ErrorHelper_1 = __webpack_require__(4);
var BeaconBase_1 = __webpack_require__(93);
var BeaconCache_1 = __webpack_require__(58);
var BaseDataStore_1 = __webpack_require__(9);
var DataStoreCachingType_1 = __webpack_require__(7);
var LogProcessor_1 = __webpack_require__(59);
var Beacon;
(function (Beacon) {
    "use strict";
    var LOGGING_REQUEST_TIMEOUT = 10000; // 10 seconds
    var FLUSH_TIMEOUT = 5000; // 5 seconds
    var BEACON_BATCH_SIZE = 100;
    var BEACON_MAX_CRITICAL_FLUSH_INTERVAL_SIZE = 5000; // 5 seconds
    // SLAPI
    var SLAPI_STREAM_ID = 1234;
    var SLAPI_JSON_VERSION = "V1";
    var SLAPI_IDX_VERSION = 0;
    var SLAPI_IDX_EVENTNAME = 1;
    var SLAPI_IDX_PROPERTY_START = 2;
    // BSQM Constants
    var SLAPI_MAX_DATA_SIZE = 64 * 1024;
    var SLAPI_MAX_ROWS_IN_STREAM = 1000;
    var SLAPI_SIZE_DWORD = 4;
    var SLAPI_SIZE_DATAPOINT_ENTRY = 3 * 4 /*SIZE_DWORD*/;
    var SLAPI_SIZE_STREAM_ENTRY = 3 * 4 /*SIZE_DATAPOINT_ENTRY*/;
    var SLAPI_MS_BTN_EPOCHS = 11644473600000; // Milliseconds between 1/1/1070 and 1/1/1601
    var SLAPI_MAX_INT32 = 0xFFFFFFFF;
    var SLAPI_MAX_SQM_DATAID = 0x7FFFFFFF;
    var SLAPI_DATAKEY_SESSION_NORMAL = 0;
    var SLAPI_DATAKEY_SESSION_CONTINUATION = 1;
    var SLAPI_FLAG_BSQM_ENABLED = 0x00000010;
    // const SLAPI_FLAG_QOS_ENABLED = 0x00000020;
    // SQM Datapoints
    var SLAPI_DATAID_BSQM_MAXSTREAMROWSSTREAMID = 8048;
    var SLAPI_DATAID_BSQM_MAXSTREAMROWS = 7993;
    var SLAPI_DATAID_SESSION_TYPE = 60;
    var WSAStreamRow = /** @class */ (function () {
        function WSAStreamRow(values) {
            this.Tic = 0;
            this.Vals = null;
            var _this = this;
            _this.Tic = _getTicks32();
            var numValues = values.length;
            _this.Vals = new Array(numValues);
            for (var i = 0; i < numValues; i++) {
                _this.Vals[i] = values[i];
            }
        }
        return WSAStreamRow;
    }());
    var WSADatapoint = /** @class */ (function () {
        function WSADatapoint(id, value) {
            var _this = this;
            _this.Id = id;
            _this.Val = value;
            _this.Tic = _getTicks32();
        }
        return WSADatapoint;
    }());
    var WSAStream = /** @class */ (function () {
        function WSAStream(id, width) {
            var _this = this;
            _this.Id = id;
            _this.Width = width;
            _this.Rows = new Array(0);
        }
        return WSAStream;
    }());
    var WSAData = /** @class */ (function () {
        function WSAData() {
            this.StartTime = null;
            this.EndTime = null;
            this.Flags = 0;
            this.wsaDatapoints = null;
            this.wsaStreams = null;
            var _this = this;
            _this.StartTime = _getTicks64();
            _this.EndTime = null;
            _this.CorrelationId = null;
            _this.Flags = SLAPI_FLAG_BSQM_ENABLED;
            _this.wsaDatapoints = new Array(0);
            _this.wsaStreams = new Array(0);
        }
        return WSAData;
    }());
    var _startTicks = 0;
    var _wsaData = null;
    var _numDatapoints = 0;
    var _numStreams = 0;
    var _numStreamBytes = 0;
    var _dictStreams = null;
    var _dictDatapoints = null;
    var _streamRowCount = 0;
    var _isDataAvailableForUpload = false;
    var _isContinuation = false;
    var _isInitialized = false;
    var _emptyCorrelationId = '00000000-0000-0000-0000-000000000000';
    var _eventNamePrefix = "";
    var _store = null;
    var _storeSize = null;
    var _instance = null;
    var _handlers = null;
    if (true) {
        try {
            console.log('Beacon: To enable logging to the console for this session, run \'sessionStorage.setItem("enableBeaconLogToConsole", "1")\' in the debug window');
        }
        catch (error) {
            // Ignore errors here. This code path, console.log, is only called during debug and it can throw while
            // debugging or stepping through the code polluting the UI with unhandled errors.
        }
    }
    var OdbBeacon = /** @class */ (function (_super) {
        tslib_1.__extends(OdbBeacon, _super);
        function OdbBeacon(eventNamePrefix, handlers, cacheEnabled, correlationId, flushTimeout) {
            if (flushTimeout === void 0) { flushTimeout = FLUSH_TIMEOUT; }
            var _this_1 = _super.call(this, '/_layouts/15/WsaUpload.ashx', BEACON_BATCH_SIZE, [flushTimeout], true, /* useSlidingWindow */ BEACON_MAX_CRITICAL_FLUSH_INTERVAL_SIZE, BeaconBase_1.default.DEFAULT_TOTAL_RETRIES, BeaconBase_1.default.DEFAULT_RESET_TOTAL_RETRIES_AFTER, cacheEnabled /* ignorePreviousEvents */) || this;
            _eventNamePrefix = eventNamePrefix;
            _handlers = handlers;
            _store = new BaseDataStore_1.default(LogProcessor_1.default.STORE_KEY, ( true) ? DataStoreCachingType_1.default.sharedMemory : DataStoreCachingType_1.default.session);
            _storeSize = _store.getValue(LogProcessor_1.default.STORE_SIZE_KEY);
            if (!_storeSize) {
                _storeSize = 0;
            }
            if (correlationId) {
                _this_1._cid = correlationId;
            }
            return _this_1;
        }
        OdbBeacon.prototype.beacon = function () {
            if (false) {
                var json = _getUploadData();
                if (json != null && json.length > 0) {
                    var headers = {};
                    headers["Content-Type"] = "application/json";
                    this.sendBeacon(json, headers, LOGGING_REQUEST_TIMEOUT);
                }
            }
            else if (sessionStorage.getItem("enableBeaconLogToConsole")) {
                try {
                    console.log('Beacon: Uploaded to COSMOS (To disable logging to the console for this session, run \'sessionStorage.setItem("enableBeaconLogToConsole", "")\' in the debug window)');
                }
                catch (error) {
                    // Ignore errors here. This code path, console.log, is only called during debug and it can throw while
                    // debugging or stepping through the code polluting the UI with unhandled errors.
                }
            }
            // Set session storage size to zero instead of clearing
            _storeSize = 0;
            _store.setValue(LogProcessor_1.default.STORE_SIZE_KEY, _storeSize);
        };
        OdbBeacon.prototype._createBeaconRequest = function (events) {
            _SetCorrelationId(this._correlationId);
            // Converts to SP logging format
            for (var x = 0; x < events.length; x++) {
                var event = events[x];
                LogProcessor_1.default.processAndLogEvent({
                    event: event,
                    logFunc: function (streamName, dictProperties) {
                        _WriteLog(streamName, dictProperties);
                    },
                    eventNamePrefix: _eventNamePrefix,
                    handlers: _handlers
                });
            }
            this.beacon();
        };
        OdbBeacon.prototype._onNewEvent = function (event) {
            // BeaconCache puts every new event to the session storage so that Sharepoint can upload it for us
            // if user navigates away before Beacon event. So we do nothing here.
        };
        Object.defineProperty(OdbBeacon.prototype, "_correlationId", {
            get: function () {
                // Avoid reading from the global variable if correlationId has been passed in.
                // The _spPageContextInfo may not always exist.
                if (this._cid) {
                    return this._cid;
                }
                var spPageContextInfo = window['_spPageContextInfo'];
                if (spPageContextInfo) {
                    return spPageContextInfo.CorrelationId;
                }
                return _emptyCorrelationId;
            },
            enumerable: true,
            configurable: true
        });
        return OdbBeacon;
    }(BeaconBase_1.default));
    function addToLoggingManager(eventNamePrefix, handlers, correlationId, flushTimeout) {
        if (!_instance) {
            var cacheEnabled = false;
            if (BeaconCache_1.default.instance) {
                eventNamePrefix = BeaconCache_1.default.eventNamePrefix;
                handlers = BeaconCache_1.default.handlers;
                cacheEnabled = true;
            }
            if (!eventNamePrefix || !handlers) {
                throw new Error("You have to pass in eventNamePrefix and IBeaconHandlers object if no BeaconCache present.");
            }
            _instance = new OdbBeacon(eventNamePrefix, handlers, cacheEnabled, correlationId, flushTimeout);
            // read any events Sharepoint (or BeaconCache) put into session storage but haven't uploaded
            for (var i = 0; i < _storeSize; i++) {
                var item = _store.getValue(i.toString());
                if (!item || !item['name'] || !item['props']) {
                    continue;
                }
                _WriteLog(item['name'], item['props']);
            }
        }
        else {
            throw new Error("The beacon has already been added to the logging manager with event name prefix " + _eventNamePrefix + ".");
        }
    }
    Beacon.addToLoggingManager = addToLoggingManager;
    function _initialize() {
        if (_isInitialized) {
            return;
        }
        _wsaData = new WSAData();
        _dictStreams = new Array(0);
        _dictDatapoints = new Array(0);
        _createStream(SLAPI_STREAM_ID, 1);
        _isInitialized = true;
    }
    function _createStream(streamId, width) {
        if (!Boolean(_dictStreams[streamId])) {
            var wsaStream = new WSAStream(streamId, width);
            var idxStream = _numStreams;
            _wsaData.wsaStreams[idxStream] = wsaStream;
            _numStreams++;
            _numStreamBytes += SLAPI_SIZE_STREAM_ENTRY;
            _dictStreams[streamId] = idxStream;
        }
    }
    function _addToStream(streamId, dictValues) {
        try {
            var wsaStreamRow = new WSAStreamRow(dictValues);
            if (_isMaxSizeReachedCheck()) {
                return;
            }
            _isDataAvailableForUpload = true;
            _setDatapoint(SLAPI_DATAID_BSQM_MAXSTREAMROWSSTREAMID, streamId);
            var wsaStream = _wsaData.wsaStreams[_dictStreams[streamId]];
            if (Boolean(wsaStream)) {
                if (_streamRowCount < SLAPI_MAX_ROWS_IN_STREAM) {
                    wsaStream.Rows[_streamRowCount++] = wsaStreamRow;
                    _numStreamBytes += _getTotalBytesForRow(wsaStreamRow);
                    _setDatapoint(SLAPI_DATAID_BSQM_MAXSTREAMROWS, _streamRowCount); // update row count datapoint
                }
                else {
                    throw ("Beacon: MAX_ROWS_IN_STREAM exceeded for stream ID " + String(streamId));
                }
            }
        }
        catch (e) {
            ErrorHelper_1.default.log(e);
        }
    }
    function _getTotalBytesForRow(row) {
        var numTotalBytes = SLAPI_SIZE_DWORD;
        for (var i = 0; i < row.Vals.length; i++) {
            var value = String(row.Vals[i]);
            numTotalBytes += value.length * 2; // A JavaScript char is 16 bit 2 byte
        }
        numTotalBytes += (row.Vals.length - 1) * 6; // plus the commas and quotes when serialized
        return numTotalBytes;
    }
    function _setDatapoint(datapointId, datapointValue) {
        if (datapointId < 1 || datapointId > SLAPI_MAX_SQM_DATAID) {
            return;
        }
        if (datapointValue < 0 || datapointValue > SLAPI_MAX_INT32) {
            return;
        }
        var savedDatapoint = null;
        var idxDP = _dictDatapoints[datapointId];
        if (Boolean(idxDP)) {
            savedDatapoint = _wsaData.wsaDatapoints[idxDP];
        }
        if (savedDatapoint == null) {
            var datapoint = new WSADatapoint(datapointId, datapointValue);
            var idxDatapoint = _numDatapoints;
            _wsaData.wsaDatapoints[idxDatapoint] = datapoint;
            _dictDatapoints[datapointId] = idxDatapoint;
            _numDatapoints++;
        }
        else {
            savedDatapoint.Val = datapointValue;
        }
    }
    function _uploadData() {
        if (_wsaData == null) {
            return "";
        }
        try {
            if (_isDataAvailableForUpload) {
                // Add final datapoints
                if (Boolean(_isContinuation)) {
                    _setDatapoint(SLAPI_DATAID_SESSION_TYPE, SLAPI_DATAKEY_SESSION_CONTINUATION);
                }
                else {
                    _setDatapoint(SLAPI_DATAID_SESSION_TYPE, SLAPI_DATAKEY_SESSION_NORMAL);
                    _isContinuation = true;
                }
                _wsaData.EndTime = _getTicks64();
                var jsonString = null;
                try {
                    jsonString = JSON.stringify(_wsaData);
                }
                catch (e) {
                    ErrorHelper_1.default.log(e);
                }
                // Initialize the session data for continuation session
                _initContinuationSession();
                return jsonString;
            }
        }
        catch (e) {
            ErrorHelper_1.default.log(e);
            return "";
        }
    }
    function _initContinuationSession() {
        _dictStreams = new Array(0);
        _dictDatapoints = new Array(0);
        _numDatapoints = 0;
        _numStreams = 0;
        _streamRowCount = 0;
        _numStreamBytes = 0;
        _numDatapoints = 0;
        var sessID = _wsaData.CorrelationId;
        _wsaData = new WSAData();
        _wsaData.CorrelationId = sessID;
        _createStream(SLAPI_STREAM_ID, 1);
        _isDataAvailableForUpload = false;
    }
    function _isMaxSizeReachedCheck() {
        var size = _numDatapoints * SLAPI_SIZE_DATAPOINT_ENTRY + _numStreamBytes;
        if (size >= SLAPI_MAX_DATA_SIZE) {
            _instance.beacon();
            size = _numDatapoints * SLAPI_SIZE_DATAPOINT_ENTRY + _numStreamBytes;
            return size >= SLAPI_MAX_DATA_SIZE;
        }
        return false;
    }
    function _SetCorrelationId(correlationId) {
        _initialize();
        if (Boolean(_wsaData)) {
            if (correlationId !== null && correlationId !== undefined) {
                _wsaData.CorrelationId = correlationId;
            }
            else {
                _wsaData.CorrelationId = _emptyCorrelationId;
            }
        }
    }
    function _WriteLog(eventName, dictProperties) {
        _initialize();
        if ((!Boolean(eventName)) || (!Boolean(dictProperties))) {
            return;
        }
        if (false) {
            var values = new Array(SLAPI_IDX_PROPERTY_START + 1);
            values[SLAPI_IDX_VERSION] = SLAPI_JSON_VERSION;
            values[SLAPI_IDX_EVENTNAME] = eventName;
            var index = SLAPI_IDX_PROPERTY_START;
            for (var key in dictProperties) {
                var propVal = dictProperties[key];
                if (propVal !== undefined && propVal !== null) { // do not need to upload null values wasting bandwidth
                    if (propVal instanceof Date) {
                        propVal = propVal.getTime();
                    }
                    values[index++] = key;
                    values[index++] = propVal;
                }
            }
            _addToStream(SLAPI_STREAM_ID, values);
        }
        else if (sessionStorage.getItem("enableBeaconLogToConsole")) {
            try {
                console.log("Beacon: Logged to " + eventName + " with properties: " + JSON.stringify(dictProperties));
            }
            catch (error) {
                // Ignore errors here. This code path, console.log, is only called during debug and it can throw while
                // debugging or stepping through the code polluting the UI with unhandled errors.
            }
        }
    }
    function _getUploadData() {
        _initialize();
        return _uploadData();
    }
    function _getTicks32() {
        var timeNow = new Date();
        var ticks64 = timeNow.getTime();
        if (_startTicks === 0) {
            _startTicks = ticks64;
        }
        return ((1 + ticks64 - _startTicks) & 0x7FFFFFFF);
    }
    function _getTicks64() {
        var timeNow = new Date();
        var ticks64 = timeNow.getTime();
        ticks64 = ticks64 + SLAPI_MS_BTN_EPOCHS; // Epoch change from 1/1/1070 to 1/1/1601
        ticks64 = ticks64 * 10000; // 1ms to 100ns resolution
        return ticks64;
    }
})(Beacon || (Beacon = {}));
exports.default = Beacon;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var Manager_1 = __webpack_require__(31);
var EventBatchCache_1 = __webpack_require__(94);
var XHR_1 = __webpack_require__(55);
var Beacon_event_1 = __webpack_require__(22);
var BeaconBase = /** @class */ (function () {
    function BeaconBase(endPointUrl, batchSize, flushTimeouts, useSlidingWindow, maxCriticalFlushInterval, totalRetries, resetTotalRetriesAfter, ignorePreviousEvents) {
        var _this = this;
        this._lastSendBeacon = 0;
        this._endPointUrl = endPointUrl;
        this._maxCriticalFlushInterval = maxCriticalFlushInterval;
        this._totalRetries = totalRetries === undefined ? BeaconBase.DEFAULT_TOTAL_RETRIES : totalRetries;
        this._totalRetriesStartValue = this._totalRetries;
        this._resetTotalRetriesAfter = resetTotalRetriesAfter === undefined ? BeaconBase.DEFAULT_RESET_TOTAL_RETRIES_AFTER : resetTotalRetriesAfter;
        this._ignorePreviousEvents = ignorePreviousEvents === undefined ? false : ignorePreviousEvents;
        this._eventBatchCache = new EventBatchCache_1.default(batchSize, flushTimeouts, function (event) {
            if (_this._onNewEvent) {
                _this._onNewEvent(event);
            }
        }, function (events) {
            // Create the beacon request
            _this._createBeaconRequest(events);
        }, useSlidingWindow);
        this.init();
    }
    BeaconBase.prototype.sendBeacon = function (json, headers, requestTimeoutInMS) {
        this._sendBeacon(json, headers, requestTimeoutInMS, 0);
    };
    BeaconBase.prototype._sendBeacon = function (json, headers, requestTimeoutInMS, retryCount) {
        var _this = this;
        if (retryCount === 0) {
            this._lastSendBeacon = Manager_1.Manager.getTime();
        }
        var xhr = new XHR_1.default({
            url: this._endPointUrl,
            json: json,
            headers: headers,
            requestTimeoutInMS: requestTimeoutInMS
        });
        var beaconEvent = new Beacon_event_1.Beacon({
            retryCount: retryCount,
            totalRetries: this._totalRetries
        });
        xhr.start(function (xhr, status) {
            beaconEvent.end({ status: status + '', success: true });
            if (++_this._successfulLogRequests >= _this._resetTotalRetriesAfter) {
                _this._successfulLogRequests = _this._resetTotalRetriesAfter;
                _this._totalRetries = _this._totalRetriesStartValue;
            }
        }, function (xhr, status, timeout) {
            _this._successfulLogRequests = 0;
            beaconEvent.end({ status: status + '', success: false });
            // Retry if we timed out since we failed
            if (status === -2 /* timeout */ && _this._totalRetries > 0) {
                _this._totalRetries--;
                _this._sendBeacon(json, headers, requestTimeoutInMS, retryCount + 1);
            }
        });
    };
    BeaconBase.prototype.init = function () {
        var _this = this;
        var bufferedEvents = Manager_1.Manager.addLogHandler(function (event) {
            _this.addEvent(event);
        });
        if (!this._ignorePreviousEvents) {
            for (var x = 0; x < bufferedEvents.length; x++) {
                this.addEvent(bufferedEvents[x]);
            }
        }
    };
    BeaconBase.prototype.addEvent = function (event) {
        if (event.enabled) {
            this._eventBatchCache.addEvent(event);
            if (event.critical &&
                (!this._lastSendBeacon ||
                    Manager_1.Manager.getTime() - this._lastSendBeacon > this._maxCriticalFlushInterval)) {
                this._eventBatchCache.flush();
            }
        }
    };
    BeaconBase.DEFAULT_TOTAL_RETRIES = 3;
    BeaconBase.DEFAULT_RESET_TOTAL_RETRIES_AFTER = 3;
    return BeaconBase;
}());
exports.default = BeaconBase;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var Beacon_event_1 = __webpack_require__(22);
var ErrorHelper_1 = __webpack_require__(4);
var EventBatchCache = /** @class */ (function () {
    function EventBatchCache(maxSize, maxFlushTimes, newEventHandler, flushHandler, useSlidingWindow) {
        this._events = [];
        this._flushCount = 0;
        this._maxSize = maxSize;
        this._newEventHandler = newEventHandler;
        this._flushHandler = flushHandler;
        this._maxFlushTimes = maxFlushTimes;
        this._useSlidingWindow = useSlidingWindow;
    }
    EventBatchCache.prototype.addEvent = function (event) {
        this._events.push(event);
        if (this._newEventHandler) {
            try {
                this._newEventHandler(event);
            }
            catch (e) {
                ErrorHelper_1.default.log(e);
            }
        }
        // Dont create a timer for events that are of type beacon
        if (Beacon_event_1.Beacon.isTypeOf(event)) {
            return;
        }
        if (this._events.length >= this._maxSize) {
            this.flush();
        }
        else {
            this._setFlushTimeout(false);
        }
    };
    EventBatchCache.prototype.flush = function () {
        this._setFlushTimeout(true);
    };
    EventBatchCache.prototype._handleFlush = function () {
        this._clearFlushTimeout();
        if (this._events.length) {
            this._flushHandler(this._events);
            // Reset the events array
            this._events = [];
        }
    };
    EventBatchCache.prototype._clearFlushTimeout = function () {
        if (this._flushTimeoutId) {
            /* tslint:disable-next-line:ban-native-functions */
            window.clearTimeout(this._flushTimeoutId);
            this._flushTimeoutId = null;
        }
        if (this._immediateflushTimeoutId) {
            /* tslint:disable-next-line:ban-native-functions */
            window.clearTimeout(this._immediateflushTimeoutId);
            this._immediateflushTimeoutId = null;
        }
    };
    EventBatchCache.prototype._setFlushTimeout = function (immediate) {
        var _this = this;
        // if another immediate flush is already queued, disregard
        if (!!this._immediateflushTimeoutId) {
            return;
        }
        if (this._useSlidingWindow) {
            this._clearFlushTimeout();
            if (immediate) {
                /* tslint:disable-next-line:ban-native-functions */
                this._immediateflushTimeoutId = window.setTimeout(function () {
                    _this._handleFlush();
                }, 0);
            }
            else {
                /* tslint:disable-next-line:ban-native-functions */
                this._flushTimeoutId = window.setTimeout(function () {
                    _this._handleFlush();
                }, this._getFlushTime());
            }
        }
        else {
            if (immediate) {
                if (!this._immediateflushTimeoutId) {
                    /* tslint:disable-next-line:ban-native-functions */
                    this._immediateflushTimeoutId = window.setTimeout(function () {
                        _this._handleFlush();
                    }, 0);
                }
            }
            else if (!this._flushTimeoutId) {
                /* tslint:disable-next-line:ban-native-functions */
                this._flushTimeoutId = window.setTimeout(function () {
                    _this._handleFlush();
                }, this._getFlushTime());
            }
        }
    };
    EventBatchCache.prototype._getFlushTime = function () {
        if (this._flushCount < this._maxFlushTimes.length) {
            var flushCount = this._flushCount;
            this._flushCount++;
            return this._maxFlushTimes[flushCount];
        }
        else {
            return this._maxFlushTimes[this._maxFlushTimes.length - 1];
        }
    };
    return EventBatchCache;
}());
exports.default = EventBatchCache;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventBase_1 = __webpack_require__(5);
exports.PLT = SingleEventBase_1.createSingleEvent({
    eventName: 'PLT,',
    shortEventName: 'PLT',
    samplingFeature: { ODB: true, ODC: 'PLTLoggingSampling', Fallback: false }
}, {
    name: {
        isKey: true,
        type: 1 /* String */
    },
    w3cResponseEnd: 2 /* Number */,
    prefetchStart: 2 /* Number */,
    deferredListDataRender: 2 /* Number */,
    appStart: 2 /* Number */,
    preRender: 2 /* Number */,
    dataFetch: 2 /* Number */,
    dataFetchServerTime: 2 /* Number */,
    postRender: 2 /* Number */,
    render: 2 /* Number */,
    plt: 2 /* Number */,
    pltWithUnload: 2 /* Number */,
    httpRequests: 2 /* Number */,
    appCacheHit: 3 /* Boolean */
});
exports.default = exports.PLT;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventBase_1 = __webpack_require__(5);
exports.UnhandledError = SingleEventBase_1.createSingleEvent({
    eventName: 'UnhandledError,',
    shortEventName: 'UnhandledError',
    critical: true,
    requiresParent: false
}, {
    message: 1 /* String */,
    stack: 1 /* String */,
    builtStack: 1 /* String */,
    line: 2 /* Number */,
    col: 2 /* Number */,
    url: 1 /* String */
});
exports.default = exports.UnhandledError;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventBase_1 = __webpack_require__(5);
exports.RequireJSError = SingleEventBase_1.createSingleEvent({
    eventName: 'RequireJSError,',
    shortEventName: 'RequireJSError',
    critical: true,
    requiresParent: false
}, {
    message: 1 /* String */,
    requireModules: 5 /* Array */,
    requireType: 1 /* String */,
    stack: 1 /* String */
});
exports.default = exports.RequireJSError;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
tslib_1.__exportStar(__webpack_require__(21), exports);
var CaughtError_event_1 = __webpack_require__(21);
exports.default = CaughtError_event_1.CaughtError;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
tslib_1.__exportStar(__webpack_require__(26), exports);
var QosError_event_1 = __webpack_require__(26);
exports.default = QosError_event_1.QosError;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
tslib_1.__exportStar(__webpack_require__(27), exports);
var Verbose_event_1 = __webpack_require__(27);
exports.default = Verbose_event_1.Verbose;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventBase_1 = __webpack_require__(5);
exports.PageInit = SingleEventBase_1.createSingleEvent({
    eventName: 'PageInit,',
    shortEventName: 'PageInit',
    requiresParent: false
}, {
    screenWidth: 2 /* Number */,
    screenHeight: 2 /* Number */,
    availableScreenWidth: 2 /* Number */,
    availableScreenHeight: 2 /* Number */,
    renderWidth: 2 /* Number */,
    renderHeight: 2 /* Number */,
    browserWidth: 2 /* Number */,
    browserHeight: 2 /* Number */,
    devicePixelRatio: 2 /* Number */,
    referrer: 1 /* String */
});
exports.default = exports.PageInit;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var DebugPriorityLevel;
(function (DebugPriorityLevel) {
    DebugPriorityLevel[DebugPriorityLevel["Low"] = 0] = "Low";
    DebugPriorityLevel[DebugPriorityLevel["Normal"] = 1] = "Normal";
})(DebugPriorityLevel || (DebugPriorityLevel = {}));
exports.default = DebugPriorityLevel;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// OneDrive:IgnoreCodeCoverage
var RUMOneLogger_1 = __webpack_require__(29);
exports.default = RUMOneLogger_1.ControlPerformanceData;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CorrelationVector_1 = __webpack_require__(44);
exports.default = CorrelationVector_1.CorrelationVector;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * This file exports members of ODSP-utilities that are not directly used by telemetry. There is a second,
 *  "telemetry" odsp-utilities package in odsp-utilities-telemetry.ts
 *
 * IMPORTANT: When editing this file, make sure you make the corresponding edit to OdspUtilitiesWorkaroundLoader.ts
 */
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:max-line-length */
// Case 1: export multiple functions from the file.
var StringHelper = __webpack_require__(60);
exports.StringHelper = StringHelper;
var SPAlternativeUrls = __webpack_require__(106);
exports.SPAlternativeUrls = SPAlternativeUrls;
// Case 2: export a named class from the file.
var ABExperiment_1 = __webpack_require__(107);
exports.ABExperiment = ABExperiment_1.ABExperiment;
exports.ABExpHash = ABExperiment_1.ABExpHash;
exports.TargetType = ABExperiment_1.TargetType;
var Killswitch_1 = __webpack_require__(13);
exports.Killswitch = Killswitch_1.Killswitch;
exports.getKillSwitch = Killswitch_1.getKillSwitch;
var FeaturesBasic_1 = __webpack_require__(35);
exports.isSPFeatureEnabled = FeaturesBasic_1.isSPFeatureEnabled;
// Case 3: export a class as default from the file.
var Component_1 = __webpack_require__(110);
exports.Component = Component_1.default;
var EventGroup_1 = __webpack_require__(112);
exports.EventGroup = EventGroup_1.default;
var Features_1 = __webpack_require__(34);
exports.Features = Features_1.default;
var FeatureOverrides_1 = __webpack_require__(65);
exports.FeatureOverrides = FeatureOverrides_1.default;
var HtmlEncoding_1 = __webpack_require__(113);
exports.HtmlEncoding = HtmlEncoding_1.default;
var Locale_1 = __webpack_require__(61);
exports.Locale = Locale_1.default;
var PlatformDetection_1 = __webpack_require__(30);
exports.PlatformDetection = PlatformDetection_1.default;
var Promise_1 = __webpack_require__(12);
exports.Promise = Promise_1.default;
var SiteHeaderLogoAcronym_1 = __webpack_require__(114);
exports.SiteHeaderLogoAcronym = SiteHeaderLogoAcronym_1.default;
var Uri_1 = __webpack_require__(62);
exports.Uri = Uri_1.default;
var UriEncoding_1 = __webpack_require__(32);
exports.UriEncoding = UriEncoding_1.default;
var ItemType_1 = __webpack_require__(68);
exports.ItemType = ItemType_1.default;
var FileTypeIconMap_1 = __webpack_require__(115);
exports.FileTypeIconMap = FileTypeIconMap_1.default;
var SharingType_1 = __webpack_require__(116);
exports.SharingType = SharingType_1.default;
var Signal_1 = __webpack_require__(67);
exports.Signal = Signal_1.default;
var Scope_1 = __webpack_require__(36);
exports.Scope = Scope_1.default;
var AriaLoggerCore_1 = __webpack_require__(54);
exports.AriaLoggerCore = AriaLoggerCore_1.default;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Uri_1 = __webpack_require__(62);
var Qos_event_1 = __webpack_require__(18);
/**
 * This enum defines sizes of the user photos.
 * Small is 48x48 px
 * Medium is 96x96 px
 * Large is as uploaded by the user
 *
 * @alpha
 */
var UserPhotoSize;
(function (UserPhotoSize) {
    /**
     * Small image is 48x48 px.
     */
    UserPhotoSize[UserPhotoSize["Small"] = 1] = "Small";
    /**
     * Medium image is 96x96 px.
     */
    UserPhotoSize[UserPhotoSize["Medium"] = 2] = "Medium";
    /**
     * Large image dimensions are as uploaded by the user.
     */
    UserPhotoSize[UserPhotoSize["Large"] = 3] = "Large";
})(UserPhotoSize = exports.UserPhotoSize || (exports.UserPhotoSize = {}));
var EXPIRATION_TOKEN = '_eat_';
var EXPIRATION_TOKEN_SEPARATOR = '_';
// @internalremarks: Note - 'UserPhotoAspx' is defined by a constant UserPhotoKey specified in
// @internalremarks: depot/devmainoverride/sporel/sts/stsom/SitePages/SitePageAlternativeUrlMapBuilder.cs
var USER_PHOTO_KEY = 'UserPhotoAspx';
var DEFAULT_USER_PHOTO_BASE_URL = '/_layouts/15/userphoto.aspx';
var USER_PHOTO_SIZE_PARAM = 'size';
var USER_PHOTO_ACCOUNT_NAME_PARAM = 'accountname';
var _urlTable = {};
var QOS_TRYGETALTERNATIVEURLFAILURE = 'TryGetAlternativeUrlFailure';
/**
 * If an alternative URL is available, then this returns the URL that should be used
 * for rendering the image.  Otherwise, undefined is returned.
 */
function tryGetAlternativeUrl(primaryUrl) {
    try {
        var alternativeUrl = _urlTable && _urlTable[primaryUrl];
        if (!alternativeUrl) {
            return undefined;
        }
        // Check for expired items.
        // Private CDN item will have a query string parameter _eat_=xxxx_yyyyyyyyyy, where xxxx is an expiration
        // time in Epoch format (number of seconds since 1970/1/1).
        // The real URL example is
        // https://privatecdn.sharepointonline.com/msft.spoppe.com/sites/wex/SiteAssets/SitePages/SamplePage/image.jpg
        //   ?_eat_=1480392900_16330f287fe138cea33c424221c6fa1d79e6cdeb470bc0000894645994ba1a14
        //   &_oat_=1480392900_f312136e0ffd87c26165973f042a98dfd40130d4981d6d3fd71643c7e4fdb485
        //   &width=300
        // If the parameter is available in the alternative Url,
        // check whether this is at least 30 seconds out in the future, and return the alternative
        // URL only if still valid. Return undefined otherwise, falling back to the original non-optimized behavior
        // note that the URLs provided by the server always have at least 15 minutes of the valid time, so it is
        // unlikely expired situation will appear too often.
        var uri = new Uri_1.default(alternativeUrl);
        var authToken = uri.getQueryParameter(EXPIRATION_TOKEN);
        if (authToken) {
            var split = authToken.split(EXPIRATION_TOKEN_SEPARATOR);
            var expirationTime = undefined;
            if (split.length === 2) {
                expirationTime = Number(split[0]);
            }
            if (!expirationTime) {
                // hightly unexpected, but logging nevertheless
                var qosEvent = new Qos_event_1.Qos({ name: QOS_TRYGETALTERNATIVEURLFAILURE });
                qosEvent.end({
                    resultType: Qos_event_1.ResultTypeEnum.Failure,
                    resultCode: 'EatParamUnexpectedFormat',
                    extraData: {
                        eatParam: authToken
                    }
                });
                return alternativeUrl;
            }
            // Shift expiration time by 30 seconds to ensure the browser has ample time to fetch the resource
            // before it actually does expire.
            expirationTime -= 30;
            // getTime() returns Epoch time in milliseconds.
            if (Date.now() / 1000 > expirationTime) {
                delete _urlTable[primaryUrl];
                return undefined;
            }
        }
        return alternativeUrl;
    }
    catch (ex) {
        var qosEvent = new Qos_event_1.Qos({ name: QOS_TRYGETALTERNATIVEURLFAILURE });
        qosEvent.end({
            resultType: Qos_event_1.ResultTypeEnum.Failure,
            resultCode: 'Unexpected',
            extraData: {
                error: ex
            }
        });
    }
    return undefined;
}
exports.tryGetAlternativeUrl = tryGetAlternativeUrl;
/**
 * Updates the map by adding the specified entries, overwriting any previous entries
 * with the same key names.
 */
function updateMap(alternativeUrlTable) {
    if (!alternativeUrlTable) {
        return;
    }
    for (var key in alternativeUrlTable) {
        _urlTable[key] = alternativeUrlTable[key];
    }
}
exports.updateMap = updateMap;
/**
 * For diagnostic purposes, this returns the current map.
 * The key is the primaryUrl, and the value is the alternativeUrl.
 */
function getUrlTable() {
    return _urlTable;
}
exports.getUrlTable = getUrlTable;
/**
 * UserPhoto mapping is auto added into the Alternative URL map when private CDN is enabled
 * and tenant admin configured origin * /userphoto.aspx
 * If CDN is not enabled, the default _layouts/15/userphoto.aspx will be used.
 * @param size Parameter may have value S,L,M. If none or other is provided, S will be used by default.
 */
function getUserPhotoUrl(accountName, size) {
    var userPhotoBaseUrl = tryGetAlternativeUrl(USER_PHOTO_KEY) || DEFAULT_USER_PHOTO_BASE_URL;
    var sizeLetter;
    switch (size) {
        case 2 /* Medium */:
            sizeLetter = 'M';
            break;
        case 3 /* Large */:
            sizeLetter = 'L';
            break;
        default:
            // Default to small if size is not provided. Server will assume small either way, but having the
            // parameter explicitly will reduce variability in CDN, and will increase probability of the cache hit.
            sizeLetter = 'S';
    }
    var userPhotoUri = new Uri_1.default(userPhotoBaseUrl);
    userPhotoUri.setQueryParameter(USER_PHOTO_SIZE_PARAM, sizeLetter);
    // empty accountName will resolve to the default doughboy picture
    userPhotoUri.setQueryParameter(USER_PHOTO_ACCOUNT_NAME_PARAM, accountName || '');
    return userPhotoUri.toString();
}
exports.getUserPhotoUrl = getUserPhotoUrl;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Engagement_event_1 = __webpack_require__(17);
var Experiment_event_1 = __webpack_require__(108);
var ExperimentTypeEnum_1 = __webpack_require__(63);
var Killswitch_1 = __webpack_require__(13);
var AddressParser_1 = __webpack_require__(64);
var ErrorHelper_1 = __webpack_require__(4);
var FeatureOverrides_1 = __webpack_require__(65);
var murmurhash = __webpack_require__(109);
/**
 * Enum for the types of targets that can be used to run an experiment.
 */
var TargetType;
(function (TargetType) {
    TargetType[TargetType["user"] = 1] = "user";
    TargetType[TargetType["tenant"] = 2] = "tenant";
    TargetType[TargetType["farm"] = 3] = "farm";
    TargetType[TargetType["site"] = 4] = "site";
})(TargetType = exports.TargetType || (exports.TargetType = {}));
/**
 * Enum for the types of algorithms used for assignment
 */
var ABExpHash;
(function (ABExpHash) {
    /** Original implementation using DJB2 hash, and using user or site ID, farm label and site subscription ID as hash input. */
    ABExpHash[ABExpHash["v1"] = 1] = "v1";
    /** New implementation using Murmur hash, and only user or site id as hash input. */
    ABExpHash[ABExpHash["v2"] = 2] = "v2";
})(ABExpHash = exports.ABExpHash || (exports.ABExpHash = {}));
/**
 * This class will be used for AB Testing type of experiments.
 *
 * You can force a single experiment on or off using query params:
 *   `enableExp=MyExperimentName` or `disableExp=MyExperimentName`
 *
 * (Note: even if an experiment is forced on/off, the actual experiment state for the given target
 * will be logged, rather than the forced state.)
 */
var ABExperiment = /** @class */ (function () {
    /**
     * @param experimentData The data for the experiment. e.g.
     * ```
     * { name: "ExperimentName", startData: "01/01/2018", version: ABExpHash.v2 }.
     * ```
     * Note: property `name` should only contain alphanumeric characters (no spaces or other
     * special characters).
     * @param aaToABFeature If provided, the experiment will initially run as an A/A experiment
     * under the given `name` plus "AA" at the end (e.g. "MyExperimentAA"). When the feature
     * is enabled, the experiment will convert to an A/B experiment using the original `name`.
     * (In an "A/A experiment," data is logged to help ensure everything is working correctly, but
     * everyone gets the old experience.)
     *
     * @example
     * // set the experiment data
     * let newMenuExperimentData: IABExperimentData = { name: "NewMenu", startDate: "11/17/2016", segmentPopulation: 0.4};
     * // create the experiment object
     * let newMenuExperiment: ABExperiment = new ABExperiment(newMenuExperimentData);
     */
    function ABExperiment(experimentData, aaToABFeature) {
        var originalName = experimentData.name;
        var isAAExperiment = aaToABFeature && !FeatureOverrides_1.default.isFeatureEnabled(aaToABFeature);
        if (!Killswitch_1.Killswitch.isActivated('ecfe2fe1-07c6-4117-98d8-27582d0384f7', '10/25/2018') && !this._isValidName(experimentData.name)) {
            ErrorHelper_1.default.log("Experiment name '" + experimentData.name + "' is invalid.");
        }
        this._experimentData = experimentData = tslib_1.__assign({ segmentPopulation: 0.5, targetType: TargetType.user, version: ABExpHash.v1 }, experimentData);
        if (isAAExperiment) {
            experimentData.name += 'AA';
        }
        this._isOn = false;
        if (!ABExperiment._pageContext) {
            // log that the App that wants to do experiments
            // does not have host settings and quit doing the experiment checks
            Engagement_event_1.Engagement.logData({ name: this._experimentData.name + ".Experiment.HostSettingsMissing" });
        }
        else {
            // set the isOn flag based on the target type
            // if it ever reaches the default then return false
            switch (this._experimentData.targetType) {
                case TargetType.user:
                    this._isOn = this._isUserExperimentOn();
                    break;
                case TargetType.tenant:
                    this._isOn = this._isTenantExperimentOn();
                    break;
                case TargetType.farm:
                    this._isOn = this._isFarmExperimentOn();
                    break;
                case TargetType.site:
                    this._isOn = this._isSiteExperimentOn();
                    break;
            }
        }
        // If we're in A/A experiment stage, everyone gets the old experience
        // (the checks above are still needed so we log which population segment the target is in)
        if (isAAExperiment) {
            this._isOn = false;
        }
        // Check whether the experiment has been forced on or off
        // (do this after the checks above so it doesn't affect logging)
        var viewParams = AddressParser_1.deserializeQuery((window.location.search || '').substr(1));
        var enabledExps = (viewParams['enableExp'] || '').split(',');
        var disabledExps = (viewParams['disableExp'] || '').split(',');
        if (enabledExps.indexOf(originalName) !== -1) {
            this._isOn = true;
        }
        else if (disabledExps.indexOf(originalName) !== -1) {
            this._isOn = false;
        }
    }
    /**
     * Initializes ABExperiment with the pageContext.
     * @param pageContext The _spPageContextInfo of the app where is experiment is running.
     */
    ABExperiment.init = function (pageContext) {
        ABExperiment._pageContext = tslib_1.__assign({}, pageContext, { userLoginName: pageContext.userLoginName || 'missing_user', siteSubscriptionId: pageContext.siteSubscriptionId || 'missing_tenant', farmLabel: pageContext.farmLabel || 'missing_farm', siteId: pageContext.siteId || 'missing_site' });
    };
    /** @deprecated Please use `init` */
    ABExperiment.Init = function (pageContext) {
        ABExperiment.init(pageContext);
    };
    /**
     * Returns the experiment data to be used for logging purposes.
     */
    ABExperiment.prototype.getExperimentData = function () {
        return this._experimentData;
    };
    /**
     * Checks if the current target is selected to be part of the experiment.
     */
    ABExperiment.prototype.isOn = function () {
        return this._isOn;
    };
    /**
     * Checks if the current target is selected to be part of the experiment.
     * @deprecated Use `isOn`
     */
    ABExperiment.prototype.IsExperimentOn = function () {
        return this._isOn;
    };
    /**
     * Checks if the current user is being selected to be part of the experiment.
     */
    ABExperiment.prototype._isUserExperimentOn = function () {
        // in case there are no host settings default to no experiments
        var pageContext = ABExperiment._pageContext;
        if (!pageContext) {
            return false;
        }
        var targetToken = '';
        var _a = this._experimentData, experimentName = _a.name, version = _a.version;
        if (version === ABExpHash.v1) {
            targetToken = experimentName + '_' +
                pageContext.userLoginName + '_' +
                pageContext.siteSubscriptionId + '_' +
                pageContext.farmLabel;
        }
        else if (version === ABExpHash.v2) {
            targetToken = experimentName + pageContext.userLoginName;
        }
        return this._isExperimentOn(targetToken);
    };
    /**
     * Checks if the current tenant is being selected to be part of the experiment.
     */
    ABExperiment.prototype._isTenantExperimentOn = function () {
        // in case there are no settings default to no experiment path
        var pageContext = ABExperiment._pageContext;
        if (!pageContext) {
            return false;
        }
        var targetToken = '';
        var _a = this._experimentData, experimentName = _a.name, version = _a.version;
        if (version === ABExpHash.v1) {
            targetToken = experimentName + '_' +
                pageContext.siteSubscriptionId + '_' +
                pageContext.farmLabel;
        }
        else if (version === ABExpHash.v2) {
            targetToken = experimentName + pageContext.siteSubscriptionId;
        }
        return this._isExperimentOn(targetToken);
    };
    /**
     * Checks if the current farm is being selected to be part of the experiment.
     */
    ABExperiment.prototype._isFarmExperimentOn = function () {
        // in case there are no settings default to no experiment path
        var pageContext = ABExperiment._pageContext;
        if (!pageContext) {
            return false;
        }
        var targetToken = '';
        var _a = this._experimentData, experimentName = _a.name, version = _a.version;
        if (version === ABExpHash.v1) {
            targetToken = experimentName + '_' +
                this._getSiteId() + '_' +
                pageContext.siteSubscriptionId + '_' +
                pageContext.farmLabel;
        }
        else if (version === ABExpHash.v2) {
            targetToken = experimentName + this._getSiteId();
        }
        return this._isExperimentOn(targetToken);
    };
    /**
     * Checks if the current site in the current tenant is being selected to be part of the experiment.
     */
    ABExperiment.prototype._isSiteExperimentOn = function () {
        // in case there are no settings default to no experiment path
        var pageContext = ABExperiment._pageContext;
        if (!pageContext) {
            return false;
        }
        // build the token using siteId and SiteSubscriptionId
        // since siteId is unique inside a tenant
        var targetToken = this._experimentData.name + '_' +
            this._getSiteId() + '_' +
            pageContext.siteSubscriptionId + '_' +
            pageContext.farmLabel;
        return this._isExperimentOn(targetToken);
    };
    /**
     * Ensures the experiment data passed is valid. For now this means making sure the name only
     * contains alphanumeric characters (no spaces or underscores).
     *
     * @param experimentData experiment data passed to the constructor
     */
    ABExperiment.prototype._isValidName = function (experimentName) {
        return !/[^A-Za-z0-9]/.test(experimentName);
    };
    /**
     * Returns the siteId if it is passed when ABExperiment is instantiated, else
     * returns the siteId present in the page context
     */
    ABExperiment.prototype._getSiteId = function () {
        var pageContext = ABExperiment._pageContext;
        return !!this._experimentData.siteId ? this._experimentData.siteId : pageContext.siteId;
    };
    /**
     * Returns true if the curent target type is being selected to be part of the experiment.
     * @param targetToken this is the unique identfier for target.
     * @returns true if the targetToken is in the segementPopulation defined for the experiment.
     */
    ABExperiment.prototype._isExperimentOn = function (targetToken) {
        if (!targetToken) {
            return false;
        }
        // get the hash number for the specified targetToken
        var varHash = 0;
        if (this._experimentData.version === ABExpHash.v1) {
            varHash = this._getHashNumber(targetToken);
        }
        else if (this._experimentData.version === ABExpHash.v2) {
            varHash = this._getHashNumberMurmur(targetToken);
        }
        // it returns true if varHash is less than segementPopulation
        // same time, it logs experiment info
        var result = varHash <= this._experimentData.segmentPopulation;
        this._logData(result);
        return result;
    };
    /**
     * Returns an unique number based on the string provided.
     * @param inputString this is the unique uber identfier for target.
     */
    ABExperiment.prototype._getHashNumber = function (inputString) {
        // in case there will be empty strings returns 1
        // this will take it to the experiment off path
        if (inputString.length === 0) {
            return 1;
        }
        var hash = 5381;
        for (var i = 0; i < inputString.length; ++i) {
            hash = ((hash << 5) + hash) + inputString.charCodeAt(i);
            hash = hash & hash;
        }
        hash = hash & 0xFFFF;
        return hash / 0xFFFF;
    };
    /**
     * Returns an unique number based on Murmur hash of string provided
     * @param inputString this is the unique uber identfier for target.
     */
    ABExperiment.prototype._getHashNumberMurmur = function (inputString) {
        return murmurhash.v3(inputString, 1) / 0xFFFFFFFF;
    };
    /**
     * Returns experiment type based on target type set
     */
    ABExperiment.prototype._getExperimentType = function () {
        if (this._experimentData.targetType === TargetType.user) {
            return ExperimentTypeEnum_1.ExperimentTypeEnum.User;
        }
        else if (this._experimentData.targetType === TargetType.site) {
            return ExperimentTypeEnum_1.ExperimentTypeEnum.Site;
        }
        else {
            // only user and site level experiments are supported
            return ExperimentTypeEnum_1.ExperimentTypeEnum.Unknown;
        }
    };
    /**
     * Log the experiment data for testing purposes.
     */
    ABExperiment.prototype._logData = function (isOn) {
        Experiment_event_1.Experiment.logData({
            name: "",
            isInRamp: isOn,
            experiment: this._experimentData.name,
            variant: isOn.toString(),
            assignmentType: this._getExperimentType(),
            // site level experiments require logging assignment IDs because unlike user IDs, it is not automatically captured.
            assignmentId: this._experimentData.targetType === TargetType.site ? this._getSiteId() : ""
        });
    };
    return ABExperiment;
}());
exports.ABExperiment = ABExperiment;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventBase_1 = __webpack_require__(5);
var ExperimentTypeEnum_1 = __webpack_require__(63);
exports.Experiment = SingleEventBase_1.createSingleEvent({
    eventName: 'Experiment,',
    shortEventName: 'Experiment'
}, {
    name: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    isInRamp: {
        isPrefixingDisabled: true,
        type: 3 /* Boolean */
    },
    experiment: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    variant: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    assignmentType: {
        isPrefixingDisabled: true,
        type: 6 /* Enum */,
        typeRef: ExperimentTypeEnum_1.ExperimentTypeEnum
    },
    assignmentId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    }
});
exports.default = exports.Experiment;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

(function(){
  var _global = this;

  /**
   * JS Implementation of MurmurHash2
   *
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *
   * @param {string} str ASCII only
   * @param {number} seed Positive integer only
   * @return {number} 32-bit positive integer hash
   */
  function MurmurHashV2(str, seed) {
    var
      l = str.length,
      h = seed ^ l,
      i = 0,
      k;

    while (l >= 4) {
      k =
        ((str.charCodeAt(i) & 0xff)) |
        ((str.charCodeAt(++i) & 0xff) << 8) |
        ((str.charCodeAt(++i) & 0xff) << 16) |
        ((str.charCodeAt(++i) & 0xff) << 24);

      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));
      k ^= k >>> 24;
      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));

    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^ k;

      l -= 4;
      ++i;
    }

    switch (l) {
    case 3: h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
    case 2: h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
    case 1: h ^= (str.charCodeAt(i) & 0xff);
            h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
    }

    h ^= h >>> 13;
    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
    h ^= h >>> 15;

    return h >>> 0;
  };

  /**
   * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
   *
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *
   * @param {string} key ASCII only
   * @param {number} seed Positive integer only
   * @return {number} 32-bit positive integer hash
   */
  function MurmurHashV3(key, seed) {
    var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;

    remainder = key.length & 3; // key.length % 4
    bytes = key.length - remainder;
    h1 = seed;
    c1 = 0xcc9e2d51;
    c2 = 0x1b873593;
    i = 0;

    while (i < bytes) {
        k1 =
          ((key.charCodeAt(i) & 0xff)) |
          ((key.charCodeAt(++i) & 0xff) << 8) |
          ((key.charCodeAt(++i) & 0xff) << 16) |
          ((key.charCodeAt(++i) & 0xff) << 24);
      ++i;

      k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
      k1 = (k1 << 15) | (k1 >>> 17);
      k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

      h1 ^= k1;
          h1 = (h1 << 13) | (h1 >>> 19);
      h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
      h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
    }

    k1 = 0;

    switch (remainder) {
      case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
      case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
      case 1: k1 ^= (key.charCodeAt(i) & 0xff);

      k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
      k1 = (k1 << 15) | (k1 >>> 17);
      k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
      h1 ^= k1;
    }

    h1 ^= key.length;

    h1 ^= h1 >>> 16;
    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= h1 >>> 13;
    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
    h1 ^= h1 >>> 16;

    return h1 >>> 0;
  }

  var murmur = MurmurHashV3;
  murmur.v2 = MurmurHashV2;
  murmur.v3 = MurmurHashV3;

  if (true) {
    module.exports = murmur;
  } else {
    var _previousRoot = _global.murmur;
    murmur.noConflict = function() {
      _global.murmur = _previousRoot;
      return murmur;
    }
    _global.murmur = murmur;
  }
}());


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Scope_1 = __webpack_require__(36);
var Resources_1 = __webpack_require__(111);
/**
 * Base class for lifetime-managed, scoped components.
 *
 * Many web components ultimately need to set up subscriptions to events,
 * manage HTML elements, wait on asychronous activities, and clean up
 * loaded state. The `Component` base class provides a way to create a hierarchy
 * of objects with lifetime management and automatic resource scoping.
 *
 * `Component` combines the benefits of `ResourceScope` and `Scope` into a single
 *  package for convenience.
 *
 * If a component-like class needs the benefits of lifetime management but cannot
 * extend `Component`, consider wrapping a `Scope` and a `ResourceScope` in order
 * to create child components.
 *
 * @export
 * @class Component
 * @implements {IDisposable}
 *
 * @example
 *  export interface ISearchServiceParams extends IComponentParams {
 *      searchMode: SearchMode;
 *  }
 *
 *  export interface ISearchDependencies extends IComponentDependencies {
 *      context: IContext
 *      DataRequestor?: typeof DataRequestor;
 *  }
 *
 *  export default class SearchService extends Component {
 *      public static readonly dependencies: IResourceDependencies<ISearchDependencies> = {
 *          ...Component.dependencies,
 *          context: contextKey
 *      }
 *
 *      private _dataRequestor: DataRequestor;
 *      private _context: IContext;
 *      private _searchMode: SearchMode;
 *
 *      constructor(params: ISearchServiceParams, dependencies: ISearchServiceDependencies) {
 *          super(params, dependencies);
 *
 *          const {
 *              searchMode
 *          } = params;
 *
 *          const {
 *              context
 *              DataRequestor: dataRequestorType // This parameter is only used in unit tests
 *          } = dependencies;
 *
 *          this._searchMode = searchMode;
 *
 *          this._context = context;
 *
 *          this._dataRequestor = new (this.child(dataRequestorType))();
 *      }
 *
 *      public search(options: ISearchOptions): Promise<ISearchResult> {
 *          return this._dataRequestor.getData(...).then((data: ISearchResponse) => {
 *              return this._processResponse(data);
 *          });
 *      }
 *  }
 */
var Component = /** @class */ (function () {
    /**
     * Creates an instance of Component.
     * In general, derived classes should invoke `super(params, dependencies)`, supplying both
     * `params` and `dependencies` to the `Component` class.
     * When creating a new instance of a derived component, use either
     * `new (resources.injected(MyComponent))()`
     * when outside a `Component` or
     * `new (this.child(MyComponent))()`
     * when inside a `Component`. This will ensure that resources are properly passed and lifetimes
     * are properly managed.
     *
     * @param {IComponentParams} [params={}] Optional params to control behaviors of this class.
     * In general, classes which extend components
     * @param {IComponentDependencies} [dependencies={}] Optional dependencies to override types consumed by this class.
     * `dependencies` is intended for use during unit testing, to override types consumed outside of resourcing.
     * Most dependency injection should be done using `ResourceScope`.
     */
    function Component(params, dependencies) {
        if (params === void 0) { params = {}; }
        if (dependencies === void 0) { dependencies = {}; }
        var _a = this.resources, resources = _a === void 0 ? (dependencies.resources ?
            // If the resource scope comes via dependencies, then it might not be unique to this component instance.
            // To be safe, create a new child resource scope for resource exposures.
            new Resources_1.ResourceScope(dependencies.resources) :
            params.resources) : _a;
        this.resources = resources;
        this._Component_scope = new Scope_1.default();
    }
    Object.defineProperty(Component.prototype, "scope", {
        /**
         * Gets the lifetime scope manager for this component.
         * In general, use `new (this.child(Type))()` to create child components
         * with proper lifetime management.
         * However, `this.scope` can be used to attach arbitrary disposable objects
         * to bind their lifetimes to the current component instance.
         *
         * @protected
         * @type {Scope}
         */
        get: function () {
            return this._Component_scope;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "isDisposed", {
        /**
         * Determines whether or not this component has been disposed.
         *
         * @readonly
         * @protected
         * @type {boolean}
         */
        get: function () {
            return this.scope.isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    Component.prototype.dispose = function () {
        this._Component_scope.dispose();
    };
    /**
     * Produces a constructor for a type which injects instances
     * with this component's current resources and binds them
     * to this component's lifetime. New code should prefer `this.child`.
     *
     * @protected
     * @template T
     * @param {T} type
     * @returns {T}
     */
    Component.prototype.managed = function (type) {
        if (this.resources) {
            type = this.resources.injected(type);
        }
        return this.scope.attached(type);
    };
    Component.prototype.child = function (keyOrType) {
        var type;
        if (keyOrType instanceof Resources_1.ResourceKey) {
            type = this.resources.consume(keyOrType);
        }
        else if (this.resources) {
            type = this.resources.injected(keyOrType, {
                injectChildResourceScope: true
            });
        }
        else {
            type = keyOrType;
        }
        return this.scope.attached(type);
    };
    Component.dependencies = {
        resources: Resources_1.resourceScopeKey
    };
    return Component;
}());
exports.Component = Component;
exports.default = Component;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var ResourceScope_1 = __webpack_require__(66);
var Disposable_1 = __webpack_require__(37);
/**
 * An implementation of IResourceLoader that constructs a {ResolvedResourceFactory} from the type that the load function resolves to.
 */
var ResolvedResourceLoader = /** @class */ (function () {
    function ResolvedResourceLoader(load, dependencies) {
        this._load = load;
        this._dependencies = dependencies;
    }
    ResolvedResourceLoader.prototype.load = function () {
        var _this = this;
        var promise = this._load().then(function (type) {
            return new ResolvedResourceFactory(type, _this._dependencies);
        });
        this.load = function () { return promise; };
        return promise;
    };
    return ResolvedResourceLoader;
}());
exports.ResolvedResourceLoader = ResolvedResourceLoader;
/**
 * An implementation of IResourceFactory that instantiates the passed type, resolving any dependencies from resources.
 */
var ResolvedResourceFactory = /** @class */ (function () {
    function ResolvedResourceFactory(type, dependencies) {
        this._type = type;
        this.dependencies = tslib_1.__assign({}, (type.dependencies || {}), (dependencies || {}));
    }
    ResolvedResourceFactory.prototype.create = function (dependencies) {
        var instance = new this._type({}, dependencies);
        return {
            instance: instance,
            disposable: instance
        };
    };
    return ResolvedResourceFactory;
}());
exports.ResolvedResourceFactory = ResolvedResourceFactory;
/**
 * An implementation of IResourceFactory that provides a constructor for the passed type with dependencies resolved from resources.
 */
var ResolvedResourceTypeFactory = /** @class */ (function () {
    function ResolvedResourceTypeFactory(type, dependencies) {
        this._type = type;
        this.dependencies = tslib_1.__assign({}, (type.dependencies || {}), (dependencies || {}));
    }
    ResolvedResourceTypeFactory.prototype.create = function (dependencies) {
        return {
            instance: ResourceScope_1.getResolvedConstructor(this._type, dependencies)
        };
    };
    return ResolvedResourceTypeFactory;
}());
exports.ResolvedResourceTypeFactory = ResolvedResourceTypeFactory;
/**
 * An implementation of IResourceFactory for classes that have no dependencies and take no parameters.
 */
var SimpleResourceFactory = /** @class */ (function () {
    function SimpleResourceFactory(type) {
        this._type = type;
        this.dependencies = {};
    }
    SimpleResourceFactory.prototype.create = function () {
        var instance = new this._type();
        return {
            instance: instance,
            disposable: Disposable_1.isDisposable(instance) && instance
        };
    };
    return SimpleResourceFactory;
}());
exports.SimpleResourceFactory = SimpleResourceFactory;
var AliasResourceLoader = /** @class */ (function () {
    function AliasResourceLoader(load) {
        this._load = load;
    }
    AliasResourceLoader.prototype.load = function () {
        var promise = this._load().then(function (dependency) {
            return new AliasResourceFactory(dependency);
        });
        this.load = function () { return promise; };
        return promise;
    };
    return AliasResourceLoader;
}());
exports.AliasResourceLoader = AliasResourceLoader;
/**
 * An implementation of IResourceFactory which wraps an existing resource key.
 */
var AliasResourceFactory = /** @class */ (function () {
    function AliasResourceFactory(dependency) {
        this.dependencies = {
            value: dependency.lazy
        };
    }
    AliasResourceFactory.prototype.create = function (dependencies) {
        return {
            instance: dependencies.value()
        };
    };
    return AliasResourceFactory;
}());
exports.AliasResourceFactory = AliasResourceFactory;
function createDefaultResourceKey(syncRequire, type, dependencies) {
    return createResolvedResourceKey(syncRequire('module').id, type, dependencies);
}
exports.createDefaultResourceKey = createDefaultResourceKey;
function createResolvedResourceKey(name, type, dependencies) {
    return new ResourceScope_1.ResourceKey({
        name: name,
        factory: new ResolvedResourceFactory(type, dependencies)
    });
}
exports.createResolvedResourceKey = createResolvedResourceKey;
function createDefaultTypeResourceKey(syncRequire, type, dependencies) {
    return createResolvedTypeResourceKey(syncRequire('module').id, type, dependencies);
}
exports.createDefaultTypeResourceKey = createDefaultTypeResourceKey;
function createResolvedTypeResourceKey(name, type, dependencies) {
    return new ResourceScope_1.ResourceKey({
        name: name,
        factory: new ResolvedResourceTypeFactory(type, dependencies)
    });
}
exports.createResolvedTypeResourceKey = createResolvedTypeResourceKey;
tslib_1.__exportStar(__webpack_require__(66), exports);


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ErrorHelper_1 = __webpack_require__(4);
var Events = __webpack_require__(57);
function logToErrorHelper(error) {
    ErrorHelper_1.default.log(error);
}
/** An instance of EventGroup allows anything with a handle to it to trigger events on it.
 *  If the target is an HTMLElement, the event will be attached to the element and can be
 *  triggered as usual (like clicking for onclick).
 *  The event can be triggered by calling EventGroup.raise() here. If the target is an
 *  HTMLElement, the event gets raised and is handled by the browser. Otherwise, it gets
 *  handled here in EventGroup, and the handler is called in the context of the parent
 *  (which is passed in in the constructor).
 */
var EventGroup = /** @class */ (function () {
    /** parent: the context in which events attached to non-HTMLElements are called */
    function EventGroup(parent, onError) {
        if (onError === void 0) { onError = logToErrorHelper; }
        this._id = EventGroup._uniqueId++;
        this._parent = parent;
        this._onError = onError;
        this._eventRecords = [];
    }
    /**
     *  Events raised here by default have bubbling set to false and cancelable set to true.
     *  This applies also to built-in events being raised manually here on HTMLElements,
     *  which may lead to unexpected behavior if it differs from the defaults.
     */
    EventGroup.raise = function (target, eventName, eventArgs, bubbleEvent) {
        return Events.raise(target, eventName, eventArgs, bubbleEvent);
    };
    EventGroup.isObserved = function (target, eventName) {
        var events = target && target.__events__;
        return !!events && !!events[eventName];
    };
    /** Check to see if the target has declared support of the given event. */
    EventGroup.isDeclared = function (target, eventName) {
        var declaredEvents = target && target.__declaredEvents;
        return !!declaredEvents && !!declaredEvents[eventName];
    };
    EventGroup.stopPropagation = function (event) {
        if (event.stopPropagation) {
            event.stopPropagation();
        }
    };
    EventGroup.prototype.dispose = function () {
        if (!this._isDisposed) {
            this._isDisposed = true;
            this.off();
            this._parent = null;
        }
    };
    /** On the target, attach a set of events, where the events object is a name to function mapping. */
    EventGroup.prototype.onAll = function (target, events, useCapture) {
        for (var eventName in events) {
            this.on(target, eventName, events[eventName], useCapture);
        }
    };
    /** On the target, attach an event whose handler will be called in the context of the parent
     * of this instance of EventGroup.
     */
    EventGroup.prototype.on = function (target, eventName, callback, useCapture) {
        var _this = this;
        if (eventName.indexOf(',') > -1) {
            var events = eventName.split(/[ ,]+/);
            for (var i = 0; i < events.length; i++) {
                this.on(target, events[i], callback, useCapture);
            }
        }
        else {
            var parent = this._parent;
            var eventRecord = {
                target: target,
                eventName: eventName,
                parent: parent,
                callback: callback,
                objectCallback: null,
                elementCallback: null,
                useCapture: useCapture
            };
            // Initialize and wire up the record on the target, so that it can call the callback if the event fires.
            var events_1 = (target.__events__ = target.__events__ || {});
            events_1[eventName] = events_1[eventName] || {
                count: 0
            };
            events_1[eventName][this._id] = events_1[eventName][this._id] || [];
            events_1[eventName][this._id].push(eventRecord);
            events_1[eventName].count++;
            if (Events.isDOMEventTarget(target)) {
                var processElementEvent = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    if (_this._isDisposed) {
                        return;
                    }
                    try {
                        var result = callback.apply(parent, args);
                        if (result === false && args[0] && args[0].preventDefault) {
                            var e = args[0];
                            e.preventDefault();
                            EventGroup.stopPropagation(e);
                        }
                    }
                    catch (e) {
                        _this._onError(e);
                    }
                    return result;
                };
                eventRecord.elementCallback = processElementEvent;
                /* tslint:disable:ban-native-functions */
                target.addEventListener(eventName, processElementEvent, useCapture);
                /* tslint:enable:ban-native-functions */
            }
            else {
                var processObjectEvent = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    if (_this._isDisposed) {
                        return;
                    }
                    return callback.apply(parent, args);
                };
                eventRecord.objectCallback = processObjectEvent;
            }
            // Remember the record locally, so that it can be removed.
            this._eventRecords.push(eventRecord);
        }
    };
    EventGroup.prototype.off = function (target, eventName, callback, useCapture) {
        for (var i = 0; i < this._eventRecords.length; i++) {
            var eventRecord = this._eventRecords[i];
            if ((!target || target === eventRecord.target) &&
                (!eventName || eventName === eventRecord.eventName) &&
                (!callback || callback === eventRecord.callback) &&
                ((typeof useCapture !== 'boolean') || useCapture === eventRecord.useCapture)) {
                var events = eventRecord.target.__events__;
                var targetArrayLookup = events[eventRecord.eventName];
                var targetArray = targetArrayLookup ? targetArrayLookup[this._id] : null;
                // We may have already target's entries, so check for null.
                if (targetArray) {
                    if (targetArray.length === 1 || !callback) {
                        targetArrayLookup.count -= targetArray.length;
                        delete events[eventRecord.eventName][this._id];
                    }
                    else {
                        targetArrayLookup.count--;
                        targetArray.splice(targetArray.indexOf(eventRecord), 1);
                    }
                    if (!targetArrayLookup.count) {
                        delete events[eventRecord.eventName];
                    }
                }
                if (eventRecord.elementCallback) {
                    if (eventRecord.target.removeEventListener) {
                        eventRecord.target.removeEventListener(eventRecord.eventName, eventRecord.elementCallback, eventRecord.useCapture);
                    }
                }
                this._eventRecords.splice(i--, 1);
            }
        }
    };
    /** Trigger the given event in the context of this instance of EventGroup. */
    EventGroup.prototype.raise = function (eventName, eventArgs, bubbleEvent) {
        return EventGroup.raise(this._parent, eventName, eventArgs, bubbleEvent);
    };
    /** Declare an event as being supported by this instance of EventGroup. */
    EventGroup.prototype.declare = function (event) {
        var declaredEvents = this._parent.__declaredEvents = this._parent.__declaredEvents || {};
        if (typeof event === 'string') {
            declaredEvents[event] = true;
        }
        else {
            for (var i = 0; i < event.length; i++) {
                declaredEvents[event[i]] = true;
            }
        }
    };
    EventGroup._uniqueId = 0;
    return EventGroup;
}());
exports.EventGroup = EventGroup;
exports.default = EventGroup;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// encode <>&'"
var ENCODE_HTML_TEXT_REGEX = /[<>&'"\\]/g;
var CODES = {
    '<': '&lt;',
    '>': '&gt;',
    '&': '&amp;',
    '"': '&quot;',
    '\'': '&#39;',
    '\\': '&#92;'
};
function replacer(match) {
    return CODES[match];
}
var HtmlEncoding = /** @class */ (function () {
    function HtmlEncoding() {
    }
    /**
     * Encodes a string for use in HTML text. Not recommended for attribute values
     * or anything that might be used in a URL.
     */
    HtmlEncoding.encodeText = function (inputString) {
        if (!inputString) {
            return "";
        }
        return inputString.replace(ENCODE_HTML_TEXT_REGEX, replacer);
    };
    return HtmlEncoding;
}());
exports.default = HtmlEncoding;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This datasource makes a call to the Acronyms and Colors service and returns an IAcronymColor object.
 */
var SiteHeaderLogoAcronym = /** @class */ (function () {
    /**
     * @constructor
     */
    function SiteHeaderLogoAcronym(pageContext) {
        this._pageContext = pageContext;
    }
    /**
     * Given a site name, return an URL to a REST endpoint where the site logo acronym and color information can be retrieved from.
     * The REST endpoint is through the GetAcronymsAndColors API.
     * Note: API takes in additional optional arguments like lcid, which as of this writing this method doesn't support.
     *       Please extend as appropriate.
     *
     * @param {string} siteName Name of the site.
     * @returns { string} the REST endpoint relative URL.
     */
    SiteHeaderLogoAcronym.prototype.getAcronymRESTUrl = function (siteName) {
        return this._pageContext.webServerRelativeUrl + ("/_api/sphome/GetAcronymsAndColors?labels=[{Text:" + encodeURIComponent('"' + siteName + '"') + "}]");
    };
    SiteHeaderLogoAcronym.prototype.getAcronymColor = function (responseText) {
        //parse the responseText
        var rtnObj = { acronym: undefined, color: undefined };
        try {
            var response = JSON.parse(responseText);
            var responseResult = response.d.GetAcronymsAndColors.results[0];
            rtnObj.acronym = responseResult.Acronym;
            rtnObj.color = responseResult.Color;
        }
        catch (e) {
            // try xml parsing
            var parser = this._parseFn();
            var elements = void 0;
            var xmlDoc = parser(responseText);
            if (elements = xmlDoc.getElementsByTagName("element")) {
                var element = elements[0];
                for (var i = 0; i < element.childNodes.length; i++) {
                    switch (element.childNodes[i].nodeName) {
                        case 'Acronym':
                            rtnObj.acronym = element.childNodes[i].nodeValue;
                            break;
                        case 'Color':
                            rtnObj.color = element.childNodes[i].nodeValue;
                            break;
                    }
                }
            }
        }
        return rtnObj;
    };
    /**
     * Returns an XML parser.
     */
    SiteHeaderLogoAcronym.prototype._parseFn = function () {
        var parseXml;
        if (DOMParser) {
            parseXml = function (xmlStr) {
                return (new DOMParser()).parseFromString(xmlStr, "text/xml");
            };
        }
        else if (ActiveXObject &&
            new ActiveXObject("Microsoft.XMLDOM")) {
            parseXml = function (xmlStr) {
                var xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = "false";
                xmlDoc.loadXML(xmlStr);
                return xmlDoc;
            };
        }
        else {
            throw new Error("No XML parser found");
        }
        return parseXml;
    };
    return SiteHeaderLogoAcronym;
}());
exports.default = SiteHeaderLogoAcronym;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ItemType_1 = __webpack_require__(68);
/**
 * THIS IS DEPRECATED. DO NOT USE!
 * Legacy enumeration of icon file names, and what extensions they map to.
 * Please use the fabric file-type-icons package and the getFileTypeIconProps method to fetch file icons.
 */
var FileTypeIconMap = {
    'accdb': { extensions: ['accdb', 'mdb'] },
    'archive': { type: ItemType_1.default.Unknown, extensions: ['7z', 'ace', 'arc', 'arj', 'dmg', 'gz', 'iso', 'lzh', 'pkg', 'rar', 'sit', 'tgz', 'tar', 'z'] },
    'audio': { type: ItemType_1.default.Unknown, extensions: ['aif', 'aiff', 'aac', 'amr', 'au', 'awb', 'dct', 'dss', 'dvf', 'flac', 'gsm', 'm4a', 'm4p', 'mid', 'mmf', 'mp3', 'ogg', 'oga', 'ra', 'rm', 'wav', 'wma', 'wv'] },
    'code': { extensions: ['abap', 'ada', 'adp', 'ahk', 'as', 'as3', 'asc', 'ascx', 'asm', 'asp', 'awk', 'bash', 'bash_login', 'bash_logout', 'bash_profile', 'bashrc', 'bat', 'bib', 'bsh', 'build', 'builder', 'c', 'c++', 'capfile', 'cc', 'cfc', 'cfm', 'cfml', 'cl', 'clj', 'cls', 'cmake', 'cmd', 'coffee', 'config', 'cpp', 'cpt', 'cpy', 'cs', 'cshtml', 'cson', 'csproj', 'css', 'ctp', 'cxx', 'd', 'ddl', 'di', 'disco', 'dml', 'dtd', 'dtml', 'el', 'emakefile', 'erb', 'erl', 'f', 'f90', 'f95', 'fs', 'fsi', 'fsscript', 'fsx', 'gemfile', 'gemspec', 'gitconfig', 'go', 'groovy', 'gvy', 'Hcp', 'h', 'h++', 'haml', 'handlebars', 'hbs', 'hh', 'hpp', 'hrl', 'hs', 'htc', 'hxx', 'idl', 'iim', 'inc', 'inf', 'ini', 'inl', 'ipp', 'irbrc', 'jade', 'jav', 'java', 'js', 'json', 'jsp', 'jsx', 'l', 'less', 'lhs', 'lisp', 'log', 'lst', 'ltx', 'lua', 'm', 'mak', 'make', 'manifest', 'master', 'md', 'markdn', 'markdown', 'mdown', 'mkdn', 'ml', 'mli', 'mll', 'mly', 'mm', 'mud', 'nfo', 'opml', 'osascript', 'p', 'pas', 'patch', 'php', 'php2', 'php3', 'php4', 'php5', 'phtml', 'pl', 'pm', 'pod', 'pp', 'profile', 'ps1', 'pss', 'pt', 'py', 'pyw', 'r', 'rake', 'rb', 'rbx', 'rc', 'rdf', 're', 'reg', 'rest', 'resw', 'resx', 'rhtml', 'rjs', 'rprofile', 'rpy', 'rss', 'rst', 'ruby', 'rxml', 's', 'sass', 'scala', 'scm', 'sconscript', 'sconstruct', 'script', 'scss', 'sgml', 'sh', 'sh', 'shtml', 'sml', 'svn-base', 'sql', 'sql', 'sty', 'tcl', 'tex', 'textile', 'tld', 'tli', 'tmpl', 'tpl', 'vb', 'vi', 'vim', 'vmg', 'webpart', 'wsp', 'wsdl', 'xhtml', 'xoml', 'xsd', 'xslt', 'yaml', 'yaws', 'yml', 'zsh'] },
    'css': {},
    'csv': { extensions: ['csv'] },
    'docset': { type: ItemType_1.default.Folder, iconType: 'svg' },
    'docx': { extensions: ['doc', 'docm', 'docx', 'docb'] },
    'dotx': { extensions: ['dot', 'dotm', 'dotx'] },
    'email': { type: ItemType_1.default.Unknown, extensions: ['eml', 'msg', 'ost', 'pst'] },
    'exe': { type: ItemType_1.default.Unknown, extensions: ['application', 'appref-ms', 'apk', 'app', 'appx', 'exe', 'ipa', 'msi', 'xap'] },
    'folder': { type: ItemType_1.default.Folder, iconType: 'svg' },
    'font': { type: ItemType_1.default.Unknown, extensions: ['ttf', 'otf', 'woff'] },
    'genericfile': { type: ItemType_1.default.Unknown },
    'html': { extensions: ['htm', 'html', 'mht'] },
    'link': { type: ItemType_1.default.Unknown, extensions: ['lnk', 'link', 'url', 'website', 'webloc'] },
    'splist': { type: ItemType_1.default.Unknown, extensions: ['listitem'] },
    'model': { extensions: ['3ds', '3mf', 'blend', 'cool', 'dae', 'df', 'dwfx', 'dwg', 'dxf', 'fbx', 'glb', 'gltf', 'holo', 'layout', 'max', 'off', 'ply', 'skp', 'stp', 'stl', 't', 'thl', 'x'] },
    'mpp': { extensions: ['mpp'] },
    'mpt': { extensions: ['mpt'] },
    'odp': { extensions: ['odp'] },
    'ods': { extensions: ['ods'] },
    'odt': { extensions: ['odt'] },
    'one': { type: ItemType_1.default.OneNote, extensions: ['one', 'onepkg'] },
    'onetoc': { type: ItemType_1.default.OneNote, extensions: ['ms-one-stub', 'onetoc', 'onetoc2'] },
    'pdf': { extensions: ['pdf'] },
    'photo': { type: ItemType_1.default.Media, extensions: ['arw', 'bmp', 'cr2', 'crw', 'dcr', 'dds', 'dib', 'dng', 'erf', 'gif', 'heic', 'heif', 'ico', 'jfi', 'jfif', 'jif', 'jpe', 'jpeg', 'jpg', 'kdc', 'mrw', 'nef', 'orf', 'pct', 'pict', 'png', 'pns', 'psd', 'raw', 'tga', 'tif', 'tiff', 'wdp'] },
    'photo360': {},
    'potx': { extensions: ['pot', 'potm', 'potx'] },
    'ppsx': { extensions: ['pps', 'ppsm', 'ppsx'] },
    'pptx': { extensions: ['ppt', 'pptm', 'pptx', 'sldx', 'sldm'] },
    'pub': { extensions: ['pub'] },
    'spo': { extensions: ['aspx'] },
    'rtf': { extensions: ['epub', 'rtf', 'wri'] },
    'sharedfolder': { type: ItemType_1.default.Folder, iconType: 'svg' },
    'sysfile': { type: ItemType_1.default.Unknown, extensions: ['bak', 'bin', 'cab', 'cache', 'cat', 'cer', 'class', 'dat', 'db', 'dbg', 'dl_', 'dll', 'ithmb', 'jar', 'kb', 'kdc', 'ldt', 'lrprev', 'ppa', 'ppam', 'pdb', 'rom', 'thm', 'thmx', 'vsl', 'xla', 'xlam', 'xll'] },
    'txt': { extensions: ['dif', 'diff', 'readme', 'out', 'plist', 'properties', 'text', 'txt'] },
    'vector': { type: ItemType_1.default.Unknown, extensions: ['ai', 'dgn', 'gdraw', 'pd', 'emf', 'eps', 'fig', 'indd', 'indt', 'ps', 'svg', 'svgz', 'wmf', 'oxps', 'xps', 'xd', 'sketch'] },
    'video': { type: ItemType_1.default.Media, extensions: ['3g2', '3gp', '3gp2', '3gpp', 'asf', 'avi', 'dvr-ms', 'flv', 'm1v', 'm4v', 'mkv', 'mod', 'mov', 'mm4p', 'mp2', 'mp2v', 'mp4', ' mpa', 'mpe', 'mpeg', 'mpg', 'mpv', 'mpv2', 'mts', 'ogg', 'qt', 'swf', 'ts', 'vob', 'webm', 'wlmp', 'wm', 'wmv', 'wmx'] },
    'video360': {},
    'vsdx': { extensions: ['vsd', 'vsdm', 'vsdx', 'vdw'] },
    'vssx': { extensions: ['vss', 'vssm', 'vssx'] },
    'vstx': { extensions: ['vst', 'vstm', 'vstx'] },
    'xlsx': { extensions: ['xls', 'xlsb', 'xlsm', 'xlsx'] },
    'xltx': { extensions: ['xlt', 'xltm', 'xltx'] },
    'xml': { extensions: ['xaml', 'xml', 'xsl'] },
    'xsn': { extensions: ['xsn'] },
    'zip': { type: ItemType_1.default.Unknown, extensions: ['zip'] }
};
exports.default = FileTypeIconMap;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SharingType;
(function (SharingType) {
    SharingType[SharingType["Public"] = 0] = "Public";
    SharingType[SharingType["PublicUnlisted"] = 2] = "PublicUnlisted";
    SharingType[SharingType["Shared"] = 3] = "Shared";
    SharingType[SharingType["Private"] = 4] = "Private";
    SharingType[SharingType["Unknown"] = 5] = "Unknown";
})(SharingType || (SharingType = {}));
exports.default = SharingType;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var RgbaColor_1 = __webpack_require__(14);
var WhiteShadeTable = [0.537, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043, 0.027]; // white fg
var BlackTintTable = [0.537, 0.45, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043]; // black fg
var LumTintTable = [0.88, 0.77, 0.66, 0.55, 0.44, 0.33, 0.22, 0.11]; // light (strongen all)
var LumShadeTable = [0.11, 0.22, 0.33, 0.44, 0.55, 0.66, 0.77, 0.88]; // dark (soften all)
var ColorTintTable = [0.96, 0.84, 0.7, 0.4, 0.12]; // default soften
var ColorShadeTable = [0.1, 0.24, 0.44]; // default strongen
// If the given shade's luminance is below/above these values, we'll swap to using the White/Black tables above
var LowLuminanceThreshold = 0.2;
var HighLuminanceThreshold = 0.8;
/** Shades of a given color, from softest to strongest. */
var Shade;
(function (Shade) {
    Shade[Shade["Unshaded"] = 0] = "Unshaded";
    Shade[Shade["Shade1"] = 1] = "Shade1";
    Shade[Shade["Shade2"] = 2] = "Shade2";
    Shade[Shade["Shade3"] = 3] = "Shade3";
    Shade[Shade["Shade4"] = 4] = "Shade4";
    Shade[Shade["Shade5"] = 5] = "Shade5";
    Shade[Shade["Shade6"] = 6] = "Shade6";
    Shade[Shade["Shade7"] = 7] = "Shade7";
    Shade[Shade["Shade8"] = 8] = "Shade8";
    // remember to update isValidShade()!
})(Shade = exports.Shade || (exports.Shade = {}));
/**
 * Returns true if the argument is a valid Shade value
 * @param {Shade} shade The Shade value to validate.
 */
function isValidShade(shade) {
    return typeof shade === 'number' && shade >= Shade.Unshaded && shade <= Shade.Shade8;
}
exports.isValidShade = isValidShade;
function _isBlack(color) {
    return color.R === 0 && color.G === 0 && color.B === 0;
}
function _isWhite(color) {
    return color.R === 255 && color.G === 255 && color.B === 255;
}
function _darken(hsv, factor) {
    return {
        h: hsv.h,
        s: hsv.s,
        v: hsv.v - hsv.v * factor
    };
}
function _lighten(hsv, factor) {
    return {
        h: hsv.h,
        s: hsv.s - hsv.s * factor,
        v: hsv.v + (100 - hsv.v) * factor
    };
}
/**
 * Given a color and a shade specification, generates the requested shade of the color.
 * Logic:
 * if white
 *  darken via tables defined above
 * if black
 *  lighten
 * if light
 *  strongen
 * if dark
 *  soften
 * else default
 *  soften or strongen depending on shade#
 * @param {IColor} color The base color whose shade is to be computed
 * @param {Shade} shade The shade of the base color to compute
 * @param {Boolean} isInverted Default false. Whether the given theme is inverted (reverse strongen/soften logic)
 */
function getShade(color, shade, isInverted) {
    if (!color || shade === Shade.Unshaded || !isValidShade(shade)) {
        return color;
    }
    var _soften = _lighten;
    var _strongen = _darken;
    if (isInverted) {
        _soften = _darken;
        _strongen = _lighten;
    }
    var hsv = rgb2hsv(color);
    var hsl = hsv2hsl(hsv);
    var tableIndex = shade - 1;
    if (_isWhite(color)) { // white
        hsv = _darken(hsv, WhiteShadeTable[tableIndex]);
    }
    else if (_isBlack(color)) { // black
        hsv = _lighten(hsv, BlackTintTable[tableIndex]);
    }
    else if (hsl.l / 100 > HighLuminanceThreshold) { // light
        hsv = _strongen(hsv, LumShadeTable[tableIndex]);
    }
    else if (hsl.l / 100 < LowLuminanceThreshold) { // dark
        hsv = _soften(hsv, LumTintTable[tableIndex]);
    }
    else { // default
        if (tableIndex < ColorTintTable.length) {
            hsv = _soften(hsv, ColorTintTable[tableIndex]);
        }
        else {
            hsv = _strongen(hsv, ColorShadeTable[tableIndex - ColorTintTable.length]);
        }
    }
    return hsv2rgb(hsv);
}
exports.getShade = getShade;
function rgb2hsv(rgb) {
    var h = NaN;
    var s;
    var v;
    var R = rgb.R, G = rgb.G, B = rgb.B;
    var max = Math.max(R, G, B);
    var min = Math.min(R, G, B);
    var delta = max - min;
    // hue
    if (delta === 0) {
        h = 0;
    }
    else if (R === max) {
        h = ((G - B) / delta) % 6;
    }
    else if (G === max) {
        h = (B - R) / delta + 2;
    }
    else if (B === max) {
        h = (R - G) / delta + 4;
    }
    h = Math.round(h * 60);
    if (h < 0) {
        h += 360;
    }
    s = Math.round((max === 0 ? 0 : delta / max) * 100);
    v = Math.round((max / 255) * 100);
    return { h: h, s: s, v: v };
}
function hsv2hsl(hsv) {
    var h = hsv.h, s = hsv.s, v = hsv.v;
    s /= 100;
    v /= 100;
    var l = (2 - s) * v;
    var sl = s * v;
    sl /= l <= 1 ? l : 2 - l;
    sl = sl || 0;
    l /= 2;
    return { h: h, s: sl * 100, l: l * 100 };
}
function hsv2rgb(hsv) {
    var h = hsv.h, s = hsv.s, v = hsv.v;
    s = s / 100;
    v = v / 100;
    var rgb = [];
    var c = v * s;
    var hh = h / 60;
    var x = c * (1 - Math.abs((hh % 2) - 1));
    var m = v - c;
    switch (Math.floor(hh)) {
        case 0:
            rgb = [c, x, 0];
            break;
        case 1:
            rgb = [x, c, 0];
            break;
        case 2:
            rgb = [0, c, x];
            break;
        case 3:
            rgb = [0, x, c];
            break;
        case 4:
            rgb = [x, 0, c];
            break;
        case 5:
            rgb = [c, 0, x];
            break;
    }
    return RgbaColor_1.default.fromRgba(Math.round(255 * (rgb[0] + m)), Math.round(255 * (rgb[1] + m)), Math.round(255 * (rgb[2] + m)));
}


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDataStore_1 = __webpack_require__(9);
var DataStoreCachingType_1 = __webpack_require__(7);
var THEME_CACHE_VERSION = '1.7';
var THEME_CACHE_PREFIX = 'odTheme';
var DATA_KEY = 'Data';
var TOKEN_KEY = 'CacheToken';
var VERSION_KEY = 'CacheVersion';
/**
 * Utility methods for caching theme data.
 */
var ThemeCache = /** @class */ (function () {
    function ThemeCache() {
    }
    /**
     * Clears the theme cache.
     */
    ThemeCache.clearThemeCache = function () {
        "use strict";
        var ds = ThemeCache.getThemeDataStore();
        ds.remove(DATA_KEY);
        ds.remove(TOKEN_KEY);
        ds.remove(VERSION_KEY);
    };
    /**
     * Reads the cached theme, if the cacheToken is compatible.
     * @param {string} cacheToken The cached value will only be returned if it has the same cache token.
     */
    ThemeCache.getCachedTheme = function (cacheToken) {
        "use strict";
        var cachedTheme;
        var ds = ThemeCache.getThemeDataStore();
        try {
            // Make sure the data was cached with the expected version and
            // the current theme cache token. Otherwise, return undefined.
            if (cacheToken === ds.getValue(TOKEN_KEY) &&
                THEME_CACHE_VERSION === ds.getValue(VERSION_KEY)) {
                cachedTheme = ds.getValue(DATA_KEY);
            }
        }
        catch (exReadCache) {
            // Ignore.
        }
        return cachedTheme;
    };
    /**
     * Updates the theme data in the cache.
     * @param {IThemeData} themeData The new theme data to cache.
     */
    ThemeCache.updateThemeCache = function (themeData, cacheToken) {
        "use strict";
        var ds = ThemeCache.getThemeDataStore();
        ds.setValue(DATA_KEY, themeData);
        ds.setValue(TOKEN_KEY, cacheToken || themeData.cacheToken);
        ds.setValue(VERSION_KEY, THEME_CACHE_VERSION);
    };
    /**
     * Returns an instance of the supporting data store for this cache.
     */
    ThemeCache.getThemeDataStore = function () {
        "use strict";
        return new BaseDataStore_1.default(THEME_CACHE_PREFIX, DataStoreCachingType_1.default.local);
    };
    return ThemeCache;
}());
exports.default = ThemeCache;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
Object.defineProperty(exports, "__esModule", { value: true });
var FabricTheming_1 = __webpack_require__(69);
var RgbaColor_1 = __webpack_require__(14);
var UriEncoding_1 = __webpack_require__(32);
/**
 * Utility methods which can be used to load the theme of a SharePoint site.
 */
var WebTheme = /** @class */ (function () {
    function WebTheme() {
    }
    /**
     * Constructs the URL of a REST endpoint which will return the web theme.
     * @param {IWebContextInfo} webContextInfo Context information about the web.
     * @param {string} cultureName Current UI culture.
     * @param {string} themeOverride URL to a temporary override theme (e.g. preview).
     */
    WebTheme.makeWebThemeRestUrl = function (webServerRelativeUrl, cultureName, themeOverride) {
        "use strict";
        var webUrl = webServerRelativeUrl;
        if (webUrl && webUrl[webUrl.length - 1] === '/') {
            // Trim trailing slash.
            webUrl = webUrl.substring(0, webUrl.length - 1);
        }
        webUrl = UriEncoding_1.default.escapeUrlForCallback(webUrl);
        var webThemeRestEndpoint = UriEncoding_1.default.escapeUrlForCallback(webUrl) +
            '/_api/SP.Web.GetContextWebThemeData?noImages=true&lcid=' +
            UriEncoding_1.default.encodeURIComponent(cultureName);
        if (themeOverride) {
            webThemeRestEndpoint += "&ThemeOverride=" + UriEncoding_1.default.encodeURIComponent(themeOverride);
        }
        return webThemeRestEndpoint;
    };
    /**
     * Constructs the URL of a REST endpoint which will return the web theme.
     * @param {IWebContextInfo} webContextInfo Context information about the web.
     */
    WebTheme.processWebThemeRestResponse = function (responseText) {
        // This could throw if the handler returns an HTML error page or invalis JSON.
        // DataSource will count that as an error and call the error callback.
        "use strict";
        var response = JSON.parse(responseText);
        var rawThemeData;
        if (response && response.d && response.d.GetContextWebThemeData) {
            rawThemeData = JSON.parse(response.d.GetContextWebThemeData);
        }
        var themeData = WebTheme.processRawThemeData(rawThemeData);
        return themeData;
    };
    /**
     * Converts an IThemeDataRaw into an IThemeData.
     * @param {IThemeDataRaw} themeData Raw theme data to process.
     */
    WebTheme.processRawThemeData = function (themeData) {
        "use strict";
        if (themeData) {
            var coerceToColor = WebTheme.coerceToColor;
            var setColorIfMissing = WebTheme.SetColorIfMissing;
            var colors = {};
            var inputColors = themeData.Palette ? themeData.Palette.Colors : {};
            colors = WebTheme.convertColorsToRgba(inputColors);
            var fabricColors = FabricTheming_1.default.generateFabricColors(colors['ContentAccent1'], themeData.IsInverted);
            var pageBG = coerceToColor(colors['PageBackground']) || null;
            var bgOverlay = coerceToColor(colors['BackgroundOverlay']) || null;
            var alpha40 = Math.round(0.4 * RgbaColor_1.default.maxComponent);
            for (var colorKey in fabricColors) {
                setColorIfMissing(colors, colorKey, fabricColors[colorKey]);
            }
            setColorIfMissing(colors, 'white', pageBG);
            // RgbaColor.fromRgba and RgbaColor.clone both return new objects.
            // This is important for avoiding duplicate filtering logic in the caching layer.
            setColorIfMissing(colors, 'primaryBackground', RgbaColor_1.default.clone(pageBG));
            setColorIfMissing(colors, 'primaryText', fabricColors['primaryText'] || coerceToColor('#333'));
            setColorIfMissing(colors, 'whiteTranslucent40', pageBG && RgbaColor_1.default.fromRgba(pageBG.R, pageBG.G, pageBG.B, alpha40));
            setColorIfMissing(colors, 'backgroundOverlay', bgOverlay);
            setColorIfMissing(colors, 'suiteBarBackground', coerceToColor(colors['SuiteBarBackground']) || null);
            setColorIfMissing(colors, 'suiteBarText', coerceToColor(colors['SuiteBarText']) || null);
            setColorIfMissing(colors, 'suiteBarDisabledText', coerceToColor(colors['SuiteBarDisabledText']) || null);
            setColorIfMissing(colors, 'topBarBackground', coerceToColor(colors['TopBarBackground']) || null);
            setColorIfMissing(colors, 'topBarText', coerceToColor(colors['TopBarText']) || null);
            setColorIfMissing(colors, 'topBarHoverText', coerceToColor(colors['TopBarHoverText']) || null);
            setColorIfMissing(colors, 'dialogBorder', coerceToColor(colors['DialogBorder']) || null);
            return {
                backgroundImageUri: themeData.BackgroundImageUri,
                cacheToken: themeData.ThemeCacheToken,
                isDefault: themeData.IsDefault,
                isInverted: themeData.IsInverted,
                palette: colors,
                version: themeData.Version
            };
        }
        return {
            backgroundImageUri: "",
            cacheToken: "",
            isDefault: true,
            isInverted: false,
            palette: {},
            version: ""
        };
    };
    WebTheme.convertColorsToRgba = function (colors) {
        var convertedColors = {};
        for (var colorKey in colors) {
            if (colors.hasOwnProperty(colorKey)) {
                var colorValue = WebTheme.coerceToColor(colors[colorKey]);
                // TODO: console.warn if colorValue is undefined?
                if (colorValue) {
                    convertedColors[colorKey] = colorValue;
                }
            }
        }
        return convertedColors;
    };
    /**
     * Coerces an HTML color string or a color object in raw web theme data into an RgbaColor.
     * @param {any} toColor Object to be converted into an RgbaColor.
     */
    WebTheme.coerceToColor = function (toColor) {
        "use strict";
        var resultColor;
        // Use duck typing to extract a color
        if (!toColor) {
            resultColor = null;
        }
        else if (typeof toColor === "string" || toColor instanceof String) {
            resultColor = RgbaColor_1.default.fromHtmlColor(String(toColor));
        }
        else if ("DefaultColor" in toColor) {
            resultColor = WebTheme.coerceToColor(toColor["DefaultColor"]);
        }
        else if ("R" in toColor && "G" in toColor && "B" in toColor) {
            resultColor = RgbaColor_1.default.fromRgba(toColor.R, toColor.G, toColor.B, toColor.A);
        }
        return resultColor;
    };
    WebTheme.SetColorIfMissing = function (palette, slot, color) {
        if (!(palette[slot])) {
            palette[slot] = color;
        }
    };
    return WebTheme;
}());
exports.default = WebTheme;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(121);
var loader = __webpack_require__(41);

if(typeof content === "string") content = [[module.i, content]];

// add the styles to the DOM
for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1], true);

if(content.locals) module.exports = content.locals;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(122)(false);
// imports


// module
exports.push([module.i, "body{height:100vh;margin:0;padding:0}.SPPageChrome{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;height:100%}#SuiteNavPlaceHolder{background-color:#333;width:100%;z-index:5}#SuiteNavPlaceHolder:empty{display:none}.SPPageChrome-app,.SPPageChrome-app>div{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-ms-flexbox;display:flex;max-width:100%}.SPPageChromeNoFlexbox-app{position:absolute;right:0;bottom:0;left:0;overflow:visible}.spAppAndPropertyPanelContainer{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;height:100%}.spPropertyPaneContainer{width:0;position:relative;z-index:999}.spAppAndPropertyPanelNavBelowHeader .SPPageChrome-app{min-width:0}.spAppAndPropertyPanelNavBelowHeader .spPropertyPaneContainer{-ms-flex-negative:0;flex-shrink:0}.spPropertyPaneContainerNoFlexbox{top:50px;position:fixed;right:-340px;bottom:0;z-index:999}.spPageContentTransition_6b79199f{transition:width 367ms cubic-bezier(.1,.9,.2,1);-webkit-transition:width 367ms cubic-bezier(.1,.9,.2,1)}", ""]);

// exports


/***/ }),
/* 122 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ })
/******/ ])});;
//# sourceMappingURL=sp-application-base.js.map