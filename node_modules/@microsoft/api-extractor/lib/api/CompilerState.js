"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const ts = require("typescript");
const colors = require("colors");
const node_core_library_1 = require("@microsoft/node-core-library");
const ExtractorConfig_1 = require("./ExtractorConfig");
const TypeScriptMessageFormatter_1 = require("../analyzer/TypeScriptMessageFormatter");
/**
 * This class represents the TypeScript compiler state.  This allows an optimization where multiple invocations
 * of API Extractor can reuse the same TypeScript compiler analysis.
 *
 * @public
 */
class CompilerState {
    constructor(properties) {
        this.program = properties.program;
    }
    /**
     * Create a compiler state for use with the specified `IExtractorInvokeOptions`.
     */
    static create(extractorConfig, options) {
        let tsconfig = extractorConfig.overrideTsconfig;
        if (!tsconfig) {
            // If it wasn't overridden, then load it from disk
            tsconfig = node_core_library_1.JsonFile.load(extractorConfig.tsconfigFilePath);
        }
        const commandLine = ts.parseJsonConfigFileContent(tsconfig, ts.sys, extractorConfig.projectFolder);
        if (!commandLine.options.skipLibCheck && extractorConfig.skipLibCheck) {
            commandLine.options.skipLibCheck = true;
            console.log(colors.cyan('API Extractor was invoked with skipLibCheck. This is not recommended and may cause ' +
                'incorrect type analysis.'));
        }
        CompilerState._updateCommandLineForTypescriptPackage(commandLine, options);
        const inputFilePaths = commandLine.fileNames.concat(extractorConfig.mainEntryPointFilePath);
        if (options && options.additionalEntryPoints) {
            inputFilePaths.push(...options.additionalEntryPoints);
        }
        // Append the entry points and remove any non-declaration files from the list
        const analysisFilePaths = CompilerState._generateFilePathsForAnalysis(inputFilePaths);
        const program = ts.createProgram(analysisFilePaths, commandLine.options);
        if (commandLine.errors.length > 0) {
            const errorText = TypeScriptMessageFormatter_1.TypeScriptMessageFormatter.format(commandLine.errors[0].messageText);
            throw new Error(`Error parsing tsconfig.json content: ${errorText}`);
        }
        return new CompilerState({
            program
        });
    }
    /**
      * Given a list of absolute file paths, return a list containing only the declaration
      * files.  Duplicates are also eliminated.
      *
      * @remarks
      * The tsconfig.json settings specify the compiler's input (a set of *.ts source files,
      * plus some *.d.ts declaration files used for legacy typings).  However API Extractor
      * analyzes the compiler's output (a set of *.d.ts entry point files, plus any legacy
      * typings).  This requires API Extractor to generate a special file list when it invokes
      * the compiler.
      *
      * Duplicates are removed so that entry points can be appended without worrying whether they
      * may already appear in the tsconfig.json file list.
      */
    static _generateFilePathsForAnalysis(inputFilePaths) {
        const analysisFilePaths = [];
        const seenFiles = new Set();
        for (const inputFilePath of inputFilePaths) {
            const inputFileToUpper = inputFilePath.toUpperCase();
            if (!seenFiles.has(inputFileToUpper)) {
                seenFiles.add(inputFileToUpper);
                if (!path.isAbsolute(inputFilePath)) {
                    throw new Error('Input file is not an absolute path: ' + inputFilePath);
                }
                if (ExtractorConfig_1.ExtractorConfig.hasDtsFileExtension(inputFilePath)) {
                    analysisFilePaths.push(inputFilePath);
                }
            }
        }
        return analysisFilePaths;
    }
    /**
     * Update the parsed command line to use paths from the specified TS compiler folder, if
     * a TS compiler folder is specified.
     */
    static _updateCommandLineForTypescriptPackage(commandLine, options) {
        const DEFAULT_BUILTIN_LIBRARY = 'lib.d.ts';
        const OTHER_BUILTIN_LIBRARIES = ['lib.es5.d.ts', 'lib.es6.d.ts'];
        if (options && options.typescriptCompilerFolder) {
            commandLine.options.noLib = true;
            const compilerLibFolder = path.join(options.typescriptCompilerFolder, 'lib');
            let foundBaseLib = false;
            const filesToAdd = [];
            for (const libFilename of commandLine.options.lib || []) {
                if (libFilename === DEFAULT_BUILTIN_LIBRARY) {
                    // Ignore the default lib - it'll get added later
                    continue;
                }
                if (OTHER_BUILTIN_LIBRARIES.indexOf(libFilename) !== -1) {
                    foundBaseLib = true;
                }
                const libPath = path.join(compilerLibFolder, libFilename);
                if (!node_core_library_1.FileSystem.exists(libPath)) {
                    throw new Error(`lib ${libFilename} does not exist in the compiler specified in typescriptLibPackage`);
                }
                filesToAdd.push(libPath);
            }
            if (!foundBaseLib) {
                // If we didn't find another version of the base lib library, include the default
                filesToAdd.push(path.join(compilerLibFolder, 'lib.d.ts'));
            }
            if (!commandLine.fileNames) {
                commandLine.fileNames = [];
            }
            commandLine.fileNames.push(...filesToAdd);
            commandLine.options.lib = undefined;
        }
    }
}
exports.CompilerState = CompilerState;
//# sourceMappingURL=CompilerState.js.map