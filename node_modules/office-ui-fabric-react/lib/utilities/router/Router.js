import * as tslib_1 from "tslib";
import * as React from 'react';
import { initializeComponentRef, on } from '../../Utilities';
var Router = /** @class */ (function (_super) {
    tslib_1.__extends(Router, _super);
    function Router(props) {
        var _this = _super.call(this, props) || this;
        _this._disposables = [];
        initializeComponentRef(_this);
        _this.state = {
            path: _this._getPath()
        };
        return _this;
    }
    Router.prototype.componentDidMount = function () {
        var _this = this;
        this._disposables.push(on(window, 'hashchange', function () {
            // Don't update unless the route itself (not an anchor link) actually changed
            var path = _this._getPath();
            if (path !== _this.state.path) {
                _this.setState({ path: path });
            }
        }));
    };
    Router.prototype.componentWillUnmount = function () {
        this._disposables.forEach(function (dispose) { return dispose(); });
    };
    Router.prototype.render = function () {
        return this._resolveRoute();
    };
    Router.prototype._getPath = function () {
        var path = location.hash;
        var hashIndex = path.lastIndexOf('#'), questionMarkIndex = path.indexOf('?');
        // Look for the start of a query in the currentPath, then strip out the query to find the correct page to render
        if (questionMarkIndex > -1) {
            path = path.substr(0, questionMarkIndex);
        }
        // If the hash has a second # (for an anchor), strip that out since it's not used for routing
        if (hashIndex > 0) {
            path = path.substr(0, hashIndex);
        }
        return _normalizePath(path);
    };
    Router.prototype._resolveRoute = function (children) {
        var _this = this;
        var path = this.state.path;
        children = children || this.props.children;
        // The children are supposed to be Route elements, but we verify this below.
        var routes = React.Children.toArray(children);
        var _loop_1 = function (route) {
            if (!route.props) {
                return "continue";
            }
            // Use this route if it has no path, or if the path matches the current path (from the hash)
            var routePath = _normalizePath(route.props.path);
            if (!routePath || routePath === path) {
                var component_1 = route.props.component;
                // The loaded component is stored as a prop on the loader function...because obviously
                var getComponent_1 = route.props.getComponent;
                if (getComponent_1) {
                    var asynchronouslyResolved_1 = false;
                    if (getComponent_1.component) {
                        component_1 = getComponent_1.component;
                    }
                    else {
                        getComponent_1(function (resolved) {
                            if (!resolved) {
                                throw new Error("Router: Calling getComponent for the route with path " + route.props.path + " " +
                                    ("returned " + resolved + ", not a component. Check your getComponent implementation ") +
                                    "(including the name of the module member you're attempting to return).");
                            }
                            component_1 = getComponent_1.component = resolved;
                            if (asynchronouslyResolved_1) {
                                _this.forceUpdate();
                            }
                        });
                    }
                    // Note: in webpack 2, this ends up always async.
                    asynchronouslyResolved_1 = true;
                }
                if (component_1) {
                    var componentChildren = this_1._resolveRoute(route.props.children || []);
                    return { value: React.createElement(component_1, { key: route.key }, componentChildren) };
                }
                else if (getComponent_1) {
                    return { value: null };
                }
            }
        };
        var this_1 = this;
        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {
            var route = routes_1[_i];
            var state_1 = _loop_1(route);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return null;
    };
    return Router;
}(React.Component));
export { Router };
/** Normalize path for comparison: strip any trailing slash and convert to lowercase */
function _normalizePath(path) {
    if (path && path.slice(-1) === '/') {
        path = path.slice(0, -1);
    }
    return (path || '').toLowerCase();
}
//# sourceMappingURL=Router.js.map