"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const Span_1 = require("../analyzer/Span");
class ExcerptBuilder {
    static build(options) {
        const span = new Span_1.Span(options.startingNode);
        const tokenRangesByNode = new Map();
        for (const excerpt of options.nodesToCapture || []) {
            if (excerpt.node) {
                tokenRangesByNode.set(excerpt.node, excerpt.tokenRange);
            }
        }
        const excerptTokens = [];
        ExcerptBuilder._buildSpan(excerptTokens, span, {
            nodeToStopAt: options.nodeToStopAt,
            tokenRangesByNode,
            disableMergingForNextToken: false
        });
        return excerptTokens;
    }
    static createEmptyTokenRange() {
        return { startIndex: 0, endIndex: 0 };
    }
    static _buildSpan(excerptTokens, span, state) {
        if (state.nodeToStopAt && span.kind === state.nodeToStopAt) {
            return false;
        }
        if (span.kind === ts.SyntaxKind.JSDocComment) {
            // Discard any comments
            return true;
        }
        // Can this node start a excerpt?
        const capturedTokenRange = state.tokenRangesByNode.get(span.node);
        let excerptStartIndex = 0;
        if (capturedTokenRange) {
            // We will assign capturedTokenRange.startIndex to be the index of the next token to be appended
            excerptStartIndex = excerptTokens.length;
            state.disableMergingForNextToken = true;
        }
        if (span.prefix) {
            if (span.kind === ts.SyntaxKind.Identifier) {
                ExcerptBuilder._appendToken(excerptTokens, "Reference" /* Reference */, span.prefix, state);
            }
            else {
                ExcerptBuilder._appendToken(excerptTokens, "Content" /* Content */, span.prefix, state);
            }
        }
        for (const child of span.children) {
            if (!this._buildSpan(excerptTokens, child, state)) {
                return false;
            }
        }
        if (span.suffix) {
            ExcerptBuilder._appendToken(excerptTokens, "Content" /* Content */, span.suffix, state);
        }
        if (span.separator) {
            ExcerptBuilder._appendToken(excerptTokens, "Content" /* Content */, span.separator, state);
        }
        // Are we building a excerpt?  If so, set its range
        if (capturedTokenRange) {
            capturedTokenRange.startIndex = excerptStartIndex;
            // We will assign capturedTokenRange.startIndex to be the index after the last token that was appended so far
            capturedTokenRange.endIndex = excerptTokens.length;
            state.disableMergingForNextToken = true;
        }
        return true;
    }
    static _appendToken(excerptTokens, excerptTokenKind, text, state) {
        if (text.length === 0) {
            return;
        }
        if (excerptTokenKind !== "Content" /* Content */) {
            excerptTokens.push({ kind: excerptTokenKind, text: text });
            state.disableMergingForNextToken = false;
        }
        else {
            // If someone referenced this index, then we need to start a new token
            if (excerptTokens.length > 0 && !state.disableMergingForNextToken) {
                // Otherwise, can we merge with the previous token?
                const previousToken = excerptTokens[excerptTokens.length - 1];
                if (previousToken.kind === excerptTokenKind) {
                    previousToken.text += text;
                    return;
                }
            }
            excerptTokens.push({ kind: excerptTokenKind, text: text });
            state.disableMergingForNextToken = false;
        }
    }
}
exports.ExcerptBuilder = ExcerptBuilder;
//# sourceMappingURL=ExcerptBuilder.js.map